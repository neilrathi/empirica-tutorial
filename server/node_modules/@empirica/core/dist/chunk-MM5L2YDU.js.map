{"version":3,"sources":["../../../../node_modules/fs.realpath/old.js","../../../../node_modules/fs.realpath/index.js","../../../../node_modules/concat-map/index.js","../../../../node_modules/balanced-match/index.js","../../../../node_modules/brace-expansion/index.js","../../../../node_modules/minimatch/minimatch.js","../../../../node_modules/inherits/inherits_browser.js","../../../../node_modules/inherits/inherits.js","../../../../node_modules/path-is-absolute/index.js","../../../../node_modules/glob/common.js","../../../../node_modules/glob/sync.js","../../../../node_modules/wrappy/wrappy.js","../../../../node_modules/once/once.js","../../../../node_modules/inflight/inflight.js","../../../../node_modules/glob/glob.js","../../../../node_modules/rimraf/rimraf.js","../node_modules/tmp/lib/tmp.js","../src/admin/classic/api/connection_test_helper.ts","../src/admin/classic/classic.ts","../src/utils/random.ts","../src/admin/classic/helpers.ts","../src/admin/classic/models.ts","../src/admin/classic/schemas.ts","../src/admin/classic/api/api.ts","../src/admin/classic/export/export_csv.ts","../src/admin/classic/export/export.ts","../src/admin/classic/loader.ts","../src/admin/classic/lobby.ts","../src/admin/classic/proxy.ts"],"sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar pathModule = require('path');\nvar isWindows = process.platform === 'win32';\nvar fs = require('fs');\n\n// JavaScript implementation of realpath, ported from node pre-v6\n\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\n\nfunction rethrow() {\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  var callback;\n  if (DEBUG) {\n    var backtrace = new Error;\n    callback = debugCallback;\n  } else\n    callback = missingCallback;\n\n  return callback;\n\n  function debugCallback(err) {\n    if (err) {\n      backtrace.message = err.message;\n      err = backtrace;\n      missingCallback(err);\n    }\n  }\n\n  function missingCallback(err) {\n    if (err) {\n      if (process.throwDeprecation)\n        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n      else if (!process.noDeprecation) {\n        var msg = 'fs: missing callback ' + (err.stack || err.message);\n        if (process.traceDeprecation)\n          console.trace(msg);\n        else\n          console.error(msg);\n      }\n    }\n  }\n}\n\nfunction maybeCallback(cb) {\n  return typeof cb === 'function' ? cb : rethrow();\n}\n\nvar normalize = pathModule.normalize;\n\n// Regexp that finds the next partion of a (partial) path\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\nif (isWindows) {\n  var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\n} else {\n  var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\n}\n\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\nif (isWindows) {\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\n} else {\n  var splitRootRe = /^[\\/]*/;\n}\n\nexports.realpathSync = function realpathSync(p, cache) {\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return cache[p];\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstatSync(base);\n      knownHard[base] = true;\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      continue;\n    }\n\n    var resolvedLink;\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // some known symbolic link.  no need to stat again.\n      resolvedLink = cache[base];\n    } else {\n      var stat = fs.lstatSync(base);\n      if (!stat.isSymbolicLink()) {\n        knownHard[base] = true;\n        if (cache) cache[base] = base;\n        continue;\n      }\n\n      // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      var linkTarget = null;\n      if (!isWindows) {\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n        if (seenLinks.hasOwnProperty(id)) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        fs.statSync(base);\n        linkTarget = fs.readlinkSync(base);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n      // track this, if given a cache.\n      if (cache) cache[base] = resolvedLink;\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n\n  if (cache) cache[original] = p;\n\n  return p;\n};\n\n\nexports.realpath = function realpath(p, cache, cb) {\n  if (typeof cb !== 'function') {\n    cb = maybeCallback(cache);\n    cache = null;\n  }\n\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return process.nextTick(cb.bind(null, null, cache[p]));\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function(err) {\n        if (err) return cb(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      if (cache) cache[original] = p;\n      return cb(null, p);\n    }\n\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      return process.nextTick(LOOP);\n    }\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // known symbolic link.  no need to stat again.\n      return gotResolvedLink(cache[base]);\n    }\n\n    return fs.lstat(base, gotStat);\n  }\n\n  function gotStat(err, stat) {\n    if (err) return cb(err);\n\n    // if not a symlink, skip to the next path part\n    if (!stat.isSymbolicLink()) {\n      knownHard[base] = true;\n      if (cache) cache[base] = base;\n      return process.nextTick(LOOP);\n    }\n\n    // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n    if (!isWindows) {\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n      if (seenLinks.hasOwnProperty(id)) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n    fs.stat(base, function(err) {\n      if (err) return cb(err);\n\n      fs.readlink(base, function(err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return cb(err);\n\n    var resolvedLink = pathModule.resolve(previous, target);\n    if (cache) cache[base] = resolvedLink;\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n};\n","module.exports = realpath\nrealpath.realpath = realpath\nrealpath.sync = realpathSync\nrealpath.realpathSync = realpathSync\nrealpath.monkeypatch = monkeypatch\nrealpath.unmonkeypatch = unmonkeypatch\n\nvar fs = require('fs')\nvar origRealpath = fs.realpath\nvar origRealpathSync = fs.realpathSync\n\nvar version = process.version\nvar ok = /^v[0-5]\\./.test(version)\nvar old = require('./old.js')\n\nfunction newError (er) {\n  return er && er.syscall === 'realpath' && (\n    er.code === 'ELOOP' ||\n    er.code === 'ENOMEM' ||\n    er.code === 'ENAMETOOLONG'\n  )\n}\n\nfunction realpath (p, cache, cb) {\n  if (ok) {\n    return origRealpath(p, cache, cb)\n  }\n\n  if (typeof cache === 'function') {\n    cb = cache\n    cache = null\n  }\n  origRealpath(p, cache, function (er, result) {\n    if (newError(er)) {\n      old.realpath(p, cache, cb)\n    } else {\n      cb(er, result)\n    }\n  })\n}\n\nfunction realpathSync (p, cache) {\n  if (ok) {\n    return origRealpathSync(p, cache)\n  }\n\n  try {\n    return origRealpathSync(p, cache)\n  } catch (er) {\n    if (newError(er)) {\n      return old.realpathSync(p, cache)\n    } else {\n      throw er\n    }\n  }\n}\n\nfunction monkeypatch () {\n  fs.realpath = realpath\n  fs.realpathSync = realpathSync\n}\n\nfunction unmonkeypatch () {\n  fs.realpath = origRealpath\n  fs.realpathSync = origRealpathSync\n}\n","module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    if(a===b) {\n      return [ai, bi];\n    }\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n","var concatMap = require('concat-map');\nvar balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n","module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = (function () { try { return require('path') } catch (e) {}}()) || {\n  sep: '/'\n}\nminimatch.sep = path.sep\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = require('brace-expansion')\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  b = b || {}\n  var t = {}\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n  m.Minimatch.defaults = function defaults (options) {\n    return orig.defaults(ext(def, options)).Minimatch\n  }\n\n  m.filter = function filter (pattern, options) {\n    return orig.filter(pattern, ext(def, options))\n  }\n\n  m.defaults = function defaults (options) {\n    return orig.defaults(ext(def, options))\n  }\n\n  m.makeRe = function makeRe (pattern, options) {\n    return orig.makeRe(pattern, ext(def, options))\n  }\n\n  m.braceExpand = function braceExpand (pattern, options) {\n    return orig.braceExpand(pattern, ext(def, options))\n  }\n\n  m.match = function (list, pattern, options) {\n    return orig.match(list, pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  assertValidPattern(pattern)\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  assertValidPattern(pattern)\n\n  if (!options) options = {}\n\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (!options.allowWindowsEscape && path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n  this.partial = !!options.partial\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = function debug() { console.error.apply(console, arguments) }\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\nvar MAX_PATTERN_LENGTH = 1024 * 64\nvar assertValidPattern = function (pattern) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  assertValidPattern(pattern)\n\n  var options = this.options\n\n  // shortcuts\n  if (pattern === '**') {\n    if (!options.noglobstar)\n      return GLOBSTAR\n    else\n      pattern = '*'\n  }\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      /* istanbul ignore next */\n      case '/': {\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n      }\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        // split where the last [ was, make sure we don't have\n        // an invalid re. if so, re-walk the contents of the\n        // would-be class to re-translate any characters that\n        // were passed through as-is\n        // TODO: It would probably be faster to determine this\n        // without a try/catch and a new RegExp, but it's tricky\n        // to do safely.  For now, this is safe and works.\n        var cs = pattern.substring(classStart + 1, i)\n        try {\n          RegExp('[' + cs + ']')\n        } catch (er) {\n          // not a valid class!\n          var sp = this.parse(cs, SUBPARSE)\n          re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n          hasMagic = hasMagic || sp[1]\n          inClass = false\n          continue\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '[': case '.': case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) /* istanbul ignore next - should be impossible */ {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) /* istanbul ignore next - should be impossible */ {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = function match (f, partial) {\n  if (typeof partial === 'undefined') partial = this.partial\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    /* istanbul ignore if */\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      /* istanbul ignore if */\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      hit = f === p\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else /* istanbul ignore else */ if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    return (fi === fl - 1) && (file[fi] === '')\n  }\n\n  // should be unreachable.\n  /* istanbul ignore next */\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","try {\n  var util = require('util');\n  /* istanbul ignore next */\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  /* istanbul ignore next */\n  module.exports = require('./inherits_browser.js');\n}\n","'use strict';\n\nfunction posix(path) {\n\treturn path.charAt(0) === '/';\n}\n\nfunction win32(path) {\n\t// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56\n\tvar splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\n\tvar result = splitDeviceRe.exec(path);\n\tvar device = result[1] || '';\n\tvar isUnc = Boolean(device && device.charAt(1) !== ':');\n\n\t// UNC paths are always absolute\n\treturn Boolean(result[2] || isUnc);\n}\n\nmodule.exports = process.platform === 'win32' ? win32 : posix;\nmodule.exports.posix = posix;\nmodule.exports.win32 = win32;\n","exports.setopts = setopts\nexports.ownProp = ownProp\nexports.makeAbs = makeAbs\nexports.finish = finish\nexports.mark = mark\nexports.isIgnored = isIgnored\nexports.childrenIgnored = childrenIgnored\n\nfunction ownProp (obj, field) {\n  return Object.prototype.hasOwnProperty.call(obj, field)\n}\n\nvar fs = require(\"fs\")\nvar path = require(\"path\")\nvar minimatch = require(\"minimatch\")\nvar isAbsolute = require(\"path-is-absolute\")\nvar Minimatch = minimatch.Minimatch\n\nfunction alphasort (a, b) {\n  return a.localeCompare(b, 'en')\n}\n\nfunction setupIgnores (self, options) {\n  self.ignore = options.ignore || []\n\n  if (!Array.isArray(self.ignore))\n    self.ignore = [self.ignore]\n\n  if (self.ignore.length) {\n    self.ignore = self.ignore.map(ignoreMap)\n  }\n}\n\n// ignore patterns are always in dot:true mode.\nfunction ignoreMap (pattern) {\n  var gmatcher = null\n  if (pattern.slice(-3) === '/**') {\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '')\n    gmatcher = new Minimatch(gpattern, { dot: true })\n  }\n\n  return {\n    matcher: new Minimatch(pattern, { dot: true }),\n    gmatcher: gmatcher\n  }\n}\n\nfunction setopts (self, pattern, options) {\n  if (!options)\n    options = {}\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\")\n    }\n    pattern = \"**/\" + pattern\n  }\n\n  self.silent = !!options.silent\n  self.pattern = pattern\n  self.strict = options.strict !== false\n  self.realpath = !!options.realpath\n  self.realpathCache = options.realpathCache || Object.create(null)\n  self.follow = !!options.follow\n  self.dot = !!options.dot\n  self.mark = !!options.mark\n  self.nodir = !!options.nodir\n  if (self.nodir)\n    self.mark = true\n  self.sync = !!options.sync\n  self.nounique = !!options.nounique\n  self.nonull = !!options.nonull\n  self.nosort = !!options.nosort\n  self.nocase = !!options.nocase\n  self.stat = !!options.stat\n  self.noprocess = !!options.noprocess\n  self.absolute = !!options.absolute\n  self.fs = options.fs || fs\n\n  self.maxLength = options.maxLength || Infinity\n  self.cache = options.cache || Object.create(null)\n  self.statCache = options.statCache || Object.create(null)\n  self.symlinks = options.symlinks || Object.create(null)\n\n  setupIgnores(self, options)\n\n  self.changedCwd = false\n  var cwd = process.cwd()\n  if (!ownProp(options, \"cwd\"))\n    self.cwd = cwd\n  else {\n    self.cwd = path.resolve(options.cwd)\n    self.changedCwd = self.cwd !== cwd\n  }\n\n  self.root = options.root || path.resolve(self.cwd, \"/\")\n  self.root = path.resolve(self.root)\n  if (process.platform === \"win32\")\n    self.root = self.root.replace(/\\\\/g, \"/\")\n\n  // TODO: is an absolute `cwd` supposed to be resolved against `root`?\n  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')\n  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)\n  if (process.platform === \"win32\")\n    self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\")\n  self.nomount = !!options.nomount\n\n  // disable comments and negation in Minimatch.\n  // Note that they are not supported in Glob itself anyway.\n  options.nonegate = true\n  options.nocomment = true\n  // always treat \\ in patterns as escapes, not path separators\n  options.allowWindowsEscape = false\n\n  self.minimatch = new Minimatch(pattern, options)\n  self.options = self.minimatch.options\n}\n\nfunction finish (self) {\n  var nou = self.nounique\n  var all = nou ? [] : Object.create(null)\n\n  for (var i = 0, l = self.matches.length; i < l; i ++) {\n    var matches = self.matches[i]\n    if (!matches || Object.keys(matches).length === 0) {\n      if (self.nonull) {\n        // do like the shell, and spit out the literal glob\n        var literal = self.minimatch.globSet[i]\n        if (nou)\n          all.push(literal)\n        else\n          all[literal] = true\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches)\n      if (nou)\n        all.push.apply(all, m)\n      else\n        m.forEach(function (m) {\n          all[m] = true\n        })\n    }\n  }\n\n  if (!nou)\n    all = Object.keys(all)\n\n  if (!self.nosort)\n    all = all.sort(alphasort)\n\n  // at *some* point we statted all of these\n  if (self.mark) {\n    for (var i = 0; i < all.length; i++) {\n      all[i] = self._mark(all[i])\n    }\n    if (self.nodir) {\n      all = all.filter(function (e) {\n        var notDir = !(/\\/$/.test(e))\n        var c = self.cache[e] || self.cache[makeAbs(self, e)]\n        if (notDir && c)\n          notDir = c !== 'DIR' && !Array.isArray(c)\n        return notDir\n      })\n    }\n  }\n\n  if (self.ignore.length)\n    all = all.filter(function(m) {\n      return !isIgnored(self, m)\n    })\n\n  self.found = all\n}\n\nfunction mark (self, p) {\n  var abs = makeAbs(self, p)\n  var c = self.cache[abs]\n  var m = p\n  if (c) {\n    var isDir = c === 'DIR' || Array.isArray(c)\n    var slash = p.slice(-1) === '/'\n\n    if (isDir && !slash)\n      m += '/'\n    else if (!isDir && slash)\n      m = m.slice(0, -1)\n\n    if (m !== p) {\n      var mabs = makeAbs(self, m)\n      self.statCache[mabs] = self.statCache[abs]\n      self.cache[mabs] = self.cache[abs]\n    }\n  }\n\n  return m\n}\n\n// lotta situps...\nfunction makeAbs (self, f) {\n  var abs = f\n  if (f.charAt(0) === '/') {\n    abs = path.join(self.root, f)\n  } else if (isAbsolute(f) || f === '') {\n    abs = f\n  } else if (self.changedCwd) {\n    abs = path.resolve(self.cwd, f)\n  } else {\n    abs = path.resolve(f)\n  }\n\n  if (process.platform === 'win32')\n    abs = abs.replace(/\\\\/g, '/')\n\n  return abs\n}\n\n\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\nfunction childrenIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n","module.exports = globSync\nglobSync.GlobSync = GlobSync\n\nvar rp = require('fs.realpath')\nvar minimatch = require('minimatch')\nvar Minimatch = minimatch.Minimatch\nvar Glob = require('./glob.js').Glob\nvar util = require('util')\nvar path = require('path')\nvar assert = require('assert')\nvar isAbsolute = require('path-is-absolute')\nvar common = require('./common.js')\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nfunction globSync (pattern, options) {\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  return new GlobSync(pattern, options).found\n}\n\nfunction GlobSync (pattern, options) {\n  if (!pattern)\n    throw new Error('must provide pattern')\n\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  if (!(this instanceof GlobSync))\n    return new GlobSync(pattern, options)\n\n  setopts(this, pattern, options)\n\n  if (this.noprocess)\n    return this\n\n  var n = this.minimatch.set.length\n  this.matches = new Array(n)\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false)\n  }\n  this._finish()\n}\n\nGlobSync.prototype._finish = function () {\n  assert.ok(this instanceof GlobSync)\n  if (this.realpath) {\n    var self = this\n    this.matches.forEach(function (matchset, index) {\n      var set = self.matches[index] = Object.create(null)\n      for (var p in matchset) {\n        try {\n          p = self._makeAbs(p)\n          var real = rp.realpathSync(p, self.realpathCache)\n          set[real] = true\n        } catch (er) {\n          if (er.syscall === 'stat')\n            set[self._makeAbs(p)] = true\n          else\n            throw er\n        }\n      }\n    })\n  }\n  common.finish(this)\n}\n\n\nGlobSync.prototype._process = function (pattern, index, inGlobStar) {\n  assert.ok(this instanceof GlobSync)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // See if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) ||\n      isAbsolute(pattern.map(function (p) {\n        return typeof p === 'string' ? p : '[*]'\n      }).join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip processing\n  if (childrenIgnored(this, read))\n    return\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)\n}\n\n\nGlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar)\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix.slice(-1) !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix)\n      newPattern = [prefix, e]\n    else\n      newPattern = [e]\n    this._process(newPattern.concat(remain), index, inGlobStar)\n  }\n}\n\n\nGlobSync.prototype._emitMatch = function (index, e) {\n  if (isIgnored(this, e))\n    return\n\n  var abs = this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute) {\n    e = abs\n  }\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  if (this.stat)\n    this._stat(e)\n}\n\n\nGlobSync.prototype._readdirInGlobStar = function (abs) {\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false)\n\n  var entries\n  var lstat\n  var stat\n  try {\n    lstat = this.fs.lstatSync(abs)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      // lstat failed, doesn't exist\n      return null\n    }\n  }\n\n  var isSym = lstat && lstat.isSymbolicLink()\n  this.symlinks[abs] = isSym\n\n  // If it's not a symlink or a dir, then it's definitely a regular file.\n  // don't bother doing a readdir in that case.\n  if (!isSym && lstat && !lstat.isDirectory())\n    this.cache[abs] = 'FILE'\n  else\n    entries = this._readdir(abs, false)\n\n  return entries\n}\n\nGlobSync.prototype._readdir = function (abs, inGlobStar) {\n  var entries\n\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return null\n\n    if (Array.isArray(c))\n      return c\n  }\n\n  try {\n    return this._readdirEntries(abs, this.fs.readdirSync(abs))\n  } catch (er) {\n    this._readdirError(abs, er)\n    return null\n  }\n}\n\nGlobSync.prototype._readdirEntries = function (abs, entries) {\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n\n  // mark and cache dir-ness\n  return entries\n}\n\nGlobSync.prototype._readdirError = function (f, er) {\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        throw error\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict)\n        throw er\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n}\n\nGlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\n\n  var entries = this._readdir(abs, inGlobStar)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false)\n\n  var len = entries.length\n  var isSym = this.symlinks[abs]\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true)\n  }\n}\n\nGlobSync.prototype._processSimple = function (prefix, index) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var exists = this._stat(prefix)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlobSync.prototype._stat = function (f) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return false\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return c\n\n    if (needDir && c === 'FILE')\n      return false\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (!stat) {\n    var lstat\n    try {\n      lstat = this.fs.lstatSync(abs)\n    } catch (er) {\n      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n        this.statCache[abs] = false\n        return false\n      }\n    }\n\n    if (lstat && lstat.isSymbolicLink()) {\n      try {\n        stat = this.fs.statSync(abs)\n      } catch (er) {\n        stat = lstat\n      }\n    } else {\n      stat = lstat\n    }\n  }\n\n  this.statCache[abs] = stat\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return false\n\n  return c\n}\n\nGlobSync.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlobSync.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","var wrappy = require('wrappy')\nvar reqs = Object.create(null)\nvar once = require('once')\n\nmodule.exports = wrappy(inflight)\n\nfunction inflight (key, cb) {\n  if (reqs[key]) {\n    reqs[key].push(cb)\n    return null\n  } else {\n    reqs[key] = [cb]\n    return makeres(key)\n  }\n}\n\nfunction makeres (key) {\n  return once(function RES () {\n    var cbs = reqs[key]\n    var len = cbs.length\n    var args = slice(arguments)\n\n    // XXX It's somewhat ambiguous whether a new callback added in this\n    // pass should be queued for later execution if something in the\n    // list of callbacks throws, or if it should just be discarded.\n    // However, it's such an edge case that it hardly matters, and either\n    // choice is likely as surprising as the other.\n    // As it happens, we do go ahead and schedule it for later execution.\n    try {\n      for (var i = 0; i < len; i++) {\n        cbs[i].apply(null, args)\n      }\n    } finally {\n      if (cbs.length > len) {\n        // added more in the interim.\n        // de-zalgo, just in case, but don't call again.\n        cbs.splice(0, len)\n        process.nextTick(function () {\n          RES.apply(null, args)\n        })\n      } else {\n        delete reqs[key]\n      }\n    }\n  })\n}\n\nfunction slice (args) {\n  var length = args.length\n  var array = []\n\n  for (var i = 0; i < length; i++) array[i] = args[i]\n  return array\n}\n","// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern, false)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern, inGlobStar)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n//\n// If inGlobStar and PREFIX is symlink and points to dir\n//   set ENTRIES = []\n// else readdir(PREFIX) as ENTRIES\n//   If fail, END\n//\n// with ENTRIES\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       // Mark that this entry is a globstar match\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\nmodule.exports = glob\n\nvar rp = require('fs.realpath')\nvar minimatch = require('minimatch')\nvar Minimatch = minimatch.Minimatch\nvar inherits = require('inherits')\nvar EE = require('events').EventEmitter\nvar path = require('path')\nvar assert = require('assert')\nvar isAbsolute = require('path-is-absolute')\nvar globSync = require('./sync.js')\nvar common = require('./common.js')\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar inflight = require('inflight')\nvar util = require('util')\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nvar once = require('once')\n\nfunction glob (pattern, options, cb) {\n  if (typeof options === 'function') cb = options, options = {}\n  if (!options) options = {}\n\n  if (options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return globSync(pattern, options)\n  }\n\n  return new Glob(pattern, options, cb)\n}\n\nglob.sync = globSync\nvar GlobSync = glob.GlobSync = globSync.GlobSync\n\n// old api surface\nglob.glob = glob\n\nfunction extend (origin, add) {\n  if (add === null || typeof add !== 'object') {\n    return origin\n  }\n\n  var keys = Object.keys(add)\n  var i = keys.length\n  while (i--) {\n    origin[keys[i]] = add[keys[i]]\n  }\n  return origin\n}\n\nglob.hasMagic = function (pattern, options_) {\n  var options = extend({}, options_)\n  options.noprocess = true\n\n  var g = new Glob(pattern, options)\n  var set = g.minimatch.set\n\n  if (!pattern)\n    return false\n\n  if (set.length > 1)\n    return true\n\n  for (var j = 0; j < set[0].length; j++) {\n    if (typeof set[0][j] !== 'string')\n      return true\n  }\n\n  return false\n}\n\nglob.Glob = Glob\ninherits(Glob, EE)\nfunction Glob (pattern, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = null\n  }\n\n  if (options && options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return new GlobSync(pattern, options)\n  }\n\n  if (!(this instanceof Glob))\n    return new Glob(pattern, options, cb)\n\n  setopts(this, pattern, options)\n  this._didRealPath = false\n\n  // process each pattern in the minimatch set\n  var n = this.minimatch.set.length\n\n  // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n  this.matches = new Array(n)\n\n  if (typeof cb === 'function') {\n    cb = once(cb)\n    this.on('error', cb)\n    this.on('end', function (matches) {\n      cb(null, matches)\n    })\n  }\n\n  var self = this\n  this._processing = 0\n\n  this._emitQueue = []\n  this._processQueue = []\n  this.paused = false\n\n  if (this.noprocess)\n    return this\n\n  if (n === 0)\n    return done()\n\n  var sync = true\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false, done)\n  }\n  sync = false\n\n  function done () {\n    --self._processing\n    if (self._processing <= 0) {\n      if (sync) {\n        process.nextTick(function () {\n          self._finish()\n        })\n      } else {\n        self._finish()\n      }\n    }\n  }\n}\n\nGlob.prototype._finish = function () {\n  assert(this instanceof Glob)\n  if (this.aborted)\n    return\n\n  if (this.realpath && !this._didRealpath)\n    return this._realpath()\n\n  common.finish(this)\n  this.emit('end', this.found)\n}\n\nGlob.prototype._realpath = function () {\n  if (this._didRealpath)\n    return\n\n  this._didRealpath = true\n\n  var n = this.matches.length\n  if (n === 0)\n    return this._finish()\n\n  var self = this\n  for (var i = 0; i < this.matches.length; i++)\n    this._realpathSet(i, next)\n\n  function next () {\n    if (--n === 0)\n      self._finish()\n  }\n}\n\nGlob.prototype._realpathSet = function (index, cb) {\n  var matchset = this.matches[index]\n  if (!matchset)\n    return cb()\n\n  var found = Object.keys(matchset)\n  var self = this\n  var n = found.length\n\n  if (n === 0)\n    return cb()\n\n  var set = this.matches[index] = Object.create(null)\n  found.forEach(function (p, i) {\n    // If there's a problem with the stat, then it means that\n    // one or more of the links in the realpath couldn't be\n    // resolved.  just return the abs value in that case.\n    p = self._makeAbs(p)\n    rp.realpath(p, self.realpathCache, function (er, real) {\n      if (!er)\n        set[real] = true\n      else if (er.syscall === 'stat')\n        set[p] = true\n      else\n        self.emit('error', er) // srsly wtf right here\n\n      if (--n === 0) {\n        self.matches[index] = set\n        cb()\n      }\n    })\n  })\n}\n\nGlob.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlob.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\nGlob.prototype.abort = function () {\n  this.aborted = true\n  this.emit('abort')\n}\n\nGlob.prototype.pause = function () {\n  if (!this.paused) {\n    this.paused = true\n    this.emit('pause')\n  }\n}\n\nGlob.prototype.resume = function () {\n  if (this.paused) {\n    this.emit('resume')\n    this.paused = false\n    if (this._emitQueue.length) {\n      var eq = this._emitQueue.slice(0)\n      this._emitQueue.length = 0\n      for (var i = 0; i < eq.length; i ++) {\n        var e = eq[i]\n        this._emitMatch(e[0], e[1])\n      }\n    }\n    if (this._processQueue.length) {\n      var pq = this._processQueue.slice(0)\n      this._processQueue.length = 0\n      for (var i = 0; i < pq.length; i ++) {\n        var p = pq[i]\n        this._processing--\n        this._process(p[0], p[1], p[2], p[3])\n      }\n    }\n  }\n}\n\nGlob.prototype._process = function (pattern, index, inGlobStar, cb) {\n  assert(this instanceof Glob)\n  assert(typeof cb === 'function')\n\n  if (this.aborted)\n    return\n\n  this._processing++\n  if (this.paused) {\n    this._processQueue.push([pattern, index, inGlobStar, cb])\n    return\n  }\n\n  //console.error('PROCESS %d', this._processing, pattern)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // see if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index, cb)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) ||\n      isAbsolute(pattern.map(function (p) {\n        return typeof p === 'string' ? p : '[*]'\n      }).join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip _processing\n  if (childrenIgnored(this, read))\n    return cb()\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)\n}\n\nGlob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\nGlob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return cb()\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return cb()\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return cb()\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix) {\n      if (prefix !== '/')\n        e = prefix + '/' + e\n      else\n        e = prefix + e\n    }\n    this._process([e].concat(remain), index, inGlobStar, cb)\n  }\n  cb()\n}\n\nGlob.prototype._emitMatch = function (index, e) {\n  if (this.aborted)\n    return\n\n  if (isIgnored(this, e))\n    return\n\n  if (this.paused) {\n    this._emitQueue.push([index, e])\n    return\n  }\n\n  var abs = isAbsolute(e) ? e : this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute)\n    e = abs\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  var st = this.statCache[abs]\n  if (st)\n    this.emit('stat', e, st)\n\n  this.emit('match', e)\n}\n\nGlob.prototype._readdirInGlobStar = function (abs, cb) {\n  if (this.aborted)\n    return\n\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false, cb)\n\n  var lstatkey = 'lstat\\0' + abs\n  var self = this\n  var lstatcb = inflight(lstatkey, lstatcb_)\n\n  if (lstatcb)\n    self.fs.lstat(abs, lstatcb)\n\n  function lstatcb_ (er, lstat) {\n    if (er && er.code === 'ENOENT')\n      return cb()\n\n    var isSym = lstat && lstat.isSymbolicLink()\n    self.symlinks[abs] = isSym\n\n    // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n    if (!isSym && lstat && !lstat.isDirectory()) {\n      self.cache[abs] = 'FILE'\n      cb()\n    } else\n      self._readdir(abs, false, cb)\n  }\n}\n\nGlob.prototype._readdir = function (abs, inGlobStar, cb) {\n  if (this.aborted)\n    return\n\n  cb = inflight('readdir\\0'+abs+'\\0'+inGlobStar, cb)\n  if (!cb)\n    return\n\n  //console.error('RD %j %j', +inGlobStar, abs)\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs, cb)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return cb()\n\n    if (Array.isArray(c))\n      return cb(null, c)\n  }\n\n  var self = this\n  self.fs.readdir(abs, readdirCb(this, abs, cb))\n}\n\nfunction readdirCb (self, abs, cb) {\n  return function (er, entries) {\n    if (er)\n      self._readdirError(abs, er, cb)\n    else\n      self._readdirEntries(abs, entries, cb)\n  }\n}\n\nGlob.prototype._readdirEntries = function (abs, entries, cb) {\n  if (this.aborted)\n    return\n\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n  return cb(null, entries)\n}\n\nGlob.prototype._readdirError = function (f, er, cb) {\n  if (this.aborted)\n    return\n\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        this.emit('error', error)\n        this.abort()\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict) {\n        this.emit('error', er)\n        // If the error is handled, then we abort\n        // if not, we threw out of here\n        this.abort()\n      }\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n\n  return cb()\n}\n\nGlob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\n\nGlob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n  //console.error('pgs2', prefix, remain[0], entries)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return cb()\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false, cb)\n\n  var isSym = this.symlinks[abs]\n  var len = entries.length\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return cb()\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true, cb)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true, cb)\n  }\n\n  cb()\n}\n\nGlob.prototype._processSimple = function (prefix, index, cb) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var self = this\n  this._stat(prefix, function (er, exists) {\n    self._processSimple2(prefix, index, er, exists, cb)\n  })\n}\nGlob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {\n\n  //console.error('ps2', prefix, exists)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return cb()\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n  cb()\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlob.prototype._stat = function (f, cb) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return cb()\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return cb(null, c)\n\n    if (needDir && c === 'FILE')\n      return cb()\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (stat !== undefined) {\n    if (stat === false)\n      return cb(null, stat)\n    else {\n      var type = stat.isDirectory() ? 'DIR' : 'FILE'\n      if (needDir && type === 'FILE')\n        return cb()\n      else\n        return cb(null, type, stat)\n    }\n  }\n\n  var self = this\n  var statcb = inflight('stat\\0' + abs, lstatcb_)\n  if (statcb)\n    self.fs.lstat(abs, statcb)\n\n  function lstatcb_ (er, lstat) {\n    if (lstat && lstat.isSymbolicLink()) {\n      // If it's a symlink, then treat it as the target, unless\n      // the target does not exist, then treat it as a file.\n      return self.fs.stat(abs, function (er, stat) {\n        if (er)\n          self._stat2(f, abs, null, lstat, cb)\n        else\n          self._stat2(f, abs, er, stat, cb)\n      })\n    } else {\n      self._stat2(f, abs, er, lstat, cb)\n    }\n  }\n}\n\nGlob.prototype._stat2 = function (f, abs, er, stat, cb) {\n  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n    this.statCache[abs] = false\n    return cb()\n  }\n\n  var needDir = f.slice(-1) === '/'\n  this.statCache[abs] = stat\n\n  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())\n    return cb(null, false, stat)\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return cb()\n\n  return cb(null, c, stat)\n}\n","const assert = require(\"assert\")\nconst path = require(\"path\")\nconst fs = require(\"fs\")\nlet glob = undefined\ntry {\n  glob = require(\"glob\")\n} catch (_err) {\n  // treat glob as optional.\n}\n\nconst defaultGlobOpts = {\n  nosort: true,\n  silent: true\n}\n\n// for EMFILE handling\nlet timeout = 0\n\nconst isWindows = (process.platform === \"win32\")\n\nconst defaults = options => {\n  const methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(m => {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n  options.emfileWait = options.emfileWait || 1000\n  if (options.glob === false) {\n    options.disableGlob = true\n  }\n  if (options.disableGlob !== true && glob === undefined) {\n    throw Error('glob dependency not found, set `options.disableGlob = true` if intentional')\n  }\n  options.disableGlob = options.disableGlob || false\n  options.glob = options.glob || defaultGlobOpts\n}\n\nconst rimraf = (p, options, cb) => {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string')\n  assert.equal(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.equal(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  let busyTries = 0\n  let errState = null\n  let n = 0\n\n  const next = (er) => {\n    errState = errState || er\n    if (--n === 0)\n      cb(errState)\n  }\n\n  const afterGlob = (er, results) => {\n    if (er)\n      return cb(er)\n\n    n = results.length\n    if (n === 0)\n      return cb()\n\n    results.forEach(p => {\n      const CB = (er) => {\n        if (er) {\n          if ((er.code === \"EBUSY\" || er.code === \"ENOTEMPTY\" || er.code === \"EPERM\") &&\n              busyTries < options.maxBusyTries) {\n            busyTries ++\n            // try again, with the same exact callback as this one.\n            return setTimeout(() => rimraf_(p, options, CB), busyTries * 100)\n          }\n\n          // this one won't happen if graceful-fs is used.\n          if (er.code === \"EMFILE\" && timeout < options.emfileWait) {\n            return setTimeout(() => rimraf_(p, options, CB), timeout ++)\n          }\n\n          // already gone\n          if (er.code === \"ENOENT\") er = null\n        }\n\n        timeout = 0\n        next(er)\n      }\n      rimraf_(p, options, CB)\n    })\n  }\n\n  if (options.disableGlob || !glob.hasMagic(p))\n    return afterGlob(null, [p])\n\n  options.lstat(p, (er, stat) => {\n    if (!er)\n      return afterGlob(null, [p])\n\n    glob(p, options.glob, afterGlob)\n  })\n\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nconst rimraf_ = (p, options, cb) => {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, (er, st) => {\n    if (er && er.code === \"ENOENT\")\n      return cb(null)\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === \"EPERM\" && isWindows)\n      fixWinEPERM(p, options, er, cb)\n\n    if (st && st.isDirectory())\n      return rmdir(p, options, er, cb)\n\n    options.unlink(p, er => {\n      if (er) {\n        if (er.code === \"ENOENT\")\n          return cb(null)\n        if (er.code === \"EPERM\")\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        if (er.code === \"EISDIR\")\n          return rmdir(p, options, er, cb)\n      }\n      return cb(er)\n    })\n  })\n}\n\nconst fixWinEPERM = (p, options, er, cb) => {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.chmod(p, 0o666, er2 => {\n    if (er2)\n      cb(er2.code === \"ENOENT\" ? null : er)\n    else\n      options.stat(p, (er3, stats) => {\n        if (er3)\n          cb(er3.code === \"ENOENT\" ? null : er)\n        else if (stats.isDirectory())\n          rmdir(p, options, er, cb)\n        else\n          options.unlink(p, cb)\n      })\n  })\n}\n\nconst fixWinEPERMSync = (p, options, er) => {\n  assert(p)\n  assert(options)\n\n  try {\n    options.chmodSync(p, 0o666)\n  } catch (er2) {\n    if (er2.code === \"ENOENT\")\n      return\n    else\n      throw er\n  }\n\n  let stats\n  try {\n    stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === \"ENOENT\")\n      return\n    else\n      throw er\n  }\n\n  if (stats.isDirectory())\n    rmdirSync(p, options, er)\n  else\n    options.unlinkSync(p)\n}\n\nconst rmdir = (p, options, originalEr, cb) => {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, er => {\n    if (er && (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\"))\n      rmkids(p, options, cb)\n    else if (er && er.code === \"ENOTDIR\")\n      cb(originalEr)\n    else\n      cb(er)\n  })\n}\n\nconst rmkids = (p, options, cb) => {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, (er, files) => {\n    if (er)\n      return cb(er)\n    let n = files.length\n    if (n === 0)\n      return options.rmdir(p, cb)\n    let errState\n    files.forEach(f => {\n      rimraf(path.join(p, f), options, er => {\n        if (errState)\n          return\n        if (er)\n          return cb(errState = er)\n        if (--n === 0)\n          options.rmdir(p, cb)\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nconst rimrafSync = (p, options) => {\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.equal(typeof options, 'object', 'rimraf: options should be object')\n\n  let results\n\n  if (options.disableGlob || !glob.hasMagic(p)) {\n    results = [p]\n  } else {\n    try {\n      options.lstatSync(p)\n      results = [p]\n    } catch (er) {\n      results = glob.sync(p, options.glob)\n    }\n  }\n\n  if (!results.length)\n    return\n\n  for (let i = 0; i < results.length; i++) {\n    const p = results[i]\n\n    let st\n    try {\n      st = options.lstatSync(p)\n    } catch (er) {\n      if (er.code === \"ENOENT\")\n        return\n\n      // Windows can EPERM on stat.  Life is suffering.\n      if (er.code === \"EPERM\" && isWindows)\n        fixWinEPERMSync(p, options, er)\n    }\n\n    try {\n      // sunos lets the root user unlink directories, which is... weird.\n      if (st && st.isDirectory())\n        rmdirSync(p, options, null)\n      else\n        options.unlinkSync(p)\n    } catch (er) {\n      if (er.code === \"ENOENT\")\n        return\n      if (er.code === \"EPERM\")\n        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n      if (er.code !== \"EISDIR\")\n        throw er\n\n      rmdirSync(p, options, er)\n    }\n  }\n}\n\nconst rmdirSync = (p, options, originalEr) => {\n  assert(p)\n  assert(options)\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === \"ENOENT\")\n      return\n    if (er.code === \"ENOTDIR\")\n      throw originalEr\n    if (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\")\n      rmkidsSync(p, options)\n  }\n}\n\nconst rmkidsSync = (p, options) => {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))\n\n  // We only end up here once we got ENOTEMPTY at least once, and\n  // at this point, we are guaranteed to have removed all the kids.\n  // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n  // try really hard to delete stuff on windows, because it has a\n  // PROFOUNDLY annoying habit of not closing handles promptly when\n  // files are deleted, resulting in spurious ENOTEMPTY errors.\n  const retries = isWindows ? 100 : 1\n  let i = 0\n  do {\n    let threw = true\n    try {\n      const ret = options.rmdirSync(p, options)\n      threw = false\n      return ret\n    } finally {\n      if (++i < retries && threw)\n        continue\n    }\n  } while (true)\n}\n\nmodule.exports = rimraf\nrimraf.sync = rimrafSync\n","/*!\n * Tmp\n *\n * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */\n\n/*\n * Module dependencies.\n */\nconst fs = require('fs');\nconst os = require('os');\nconst path = require('path');\nconst crypto = require('crypto');\nconst _c = { fs: fs.constants, os: os.constants };\nconst rimraf = require('rimraf');\n\n/*\n * The working inner variables.\n */\nconst\n  // the random characters to choose from\n  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n\n  TEMPLATE_PATTERN = /XXXXXX/,\n\n  DEFAULT_TRIES = 3,\n\n  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),\n\n  // constants are off on the windows platform and will not match the actual errno codes\n  IS_WIN32 = os.platform() === 'win32',\n  EBADF = _c.EBADF || _c.os.errno.EBADF,\n  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,\n\n  DIR_MODE = 0o700 /* 448 */,\n  FILE_MODE = 0o600 /* 384 */,\n\n  EXIT = 'exit',\n\n  // this will hold the objects need to be removed on exit\n  _removeObjects = [],\n\n  // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback\n  FN_RMDIR_SYNC = fs.rmdirSync.bind(fs),\n  FN_RIMRAF_SYNC = rimraf.sync;\n\nlet\n  _gracefulCleanup = false;\n\n/**\n * Gets a temporary file name.\n *\n * @param {(Options|tmpNameCallback)} options options or callback\n * @param {?tmpNameCallback} callback the callback function\n */\nfunction tmpName(options, callback) {\n  const\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  try {\n    _assertAndSanitizeOptions(opts);\n  } catch (err) {\n    return cb(err);\n  }\n\n  let tries = opts.tries;\n  (function _getUniqueName() {\n    try {\n      const name = _generateTmpName(opts);\n\n      // check whether the path exists then retry if needed\n      fs.stat(name, function (err) {\n        /* istanbul ignore else */\n        if (!err) {\n          /* istanbul ignore else */\n          if (tries-- > 0) return _getUniqueName();\n\n          return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));\n        }\n\n        cb(null, name);\n      });\n    } catch (err) {\n      cb(err);\n    }\n  }());\n}\n\n/**\n * Synchronous version of tmpName.\n *\n * @param {Object} options\n * @returns {string} the generated random name\n * @throws {Error} if the options are invalid or could not generate a filename\n */\nfunction tmpNameSync(options) {\n  const\n    args = _parseArguments(options),\n    opts = args[0];\n\n  _assertAndSanitizeOptions(opts);\n\n  let tries = opts.tries;\n  do {\n    const name = _generateTmpName(opts);\n    try {\n      fs.statSync(name);\n    } catch (e) {\n      return name;\n    }\n  } while (tries-- > 0);\n\n  throw new Error('Could not get a unique tmp filename, max tries reached');\n}\n\n/**\n * Creates and opens a temporary file.\n *\n * @param {(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined\n * @param {?fileCallback} callback\n */\nfunction file(options, callback) {\n  const\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create and open the file\n    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n      /* istanbu ignore else */\n      if (err) return cb(err);\n\n      if (opts.discardDescriptor) {\n        return fs.close(fd, function _discardCallback(possibleErr) {\n          // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only\n          return cb(possibleErr, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts, false));\n        });\n      } else {\n        // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care\n        // about the descriptor\n        const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n        cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));\n      }\n    });\n  });\n}\n\n/**\n * Synchronous version of file.\n *\n * @param {Options} options\n * @returns {FileSyncObject} object consists of name, fd and removeCallback\n * @throws {Error} if cannot create a file\n */\nfunction fileSync(options) {\n  const\n    args = _parseArguments(options),\n    opts = args[0];\n\n  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n  const name = tmpNameSync(opts);\n  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n  /* istanbul ignore else */\n  if (opts.discardDescriptor) {\n    fs.closeSync(fd);\n    fd = undefined;\n  }\n\n  return {\n    name: name,\n    fd: fd,\n    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)\n  };\n}\n\n/**\n * Creates a temporary directory.\n *\n * @param {(Options|dirCallback)} options the options or the callback function\n * @param {?dirCallback} callback\n */\nfunction dir(options, callback) {\n  const\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  tmpName(opts, function _tmpNameCreated(err, name) {\n    /* istanbul ignore else */\n    if (err) return cb(err);\n\n    // create the directory\n    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n      /* istanbul ignore else */\n      if (err) return cb(err);\n\n      cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));\n    });\n  });\n}\n\n/**\n * Synchronous version of dir.\n *\n * @param {Options} options\n * @returns {DirSyncObject} object consists of name and removeCallback\n * @throws {Error} if it cannot create a directory\n */\nfunction dirSync(options) {\n  const\n    args = _parseArguments(options),\n    opts = args[0];\n\n  const name = tmpNameSync(opts);\n  fs.mkdirSync(name, opts.mode || DIR_MODE);\n\n  return {\n    name: name,\n    removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)\n  };\n}\n\n/**\n * Removes files asynchronously.\n *\n * @param {Object} fdPath\n * @param {Function} next\n * @private\n */\nfunction _removeFileAsync(fdPath, next) {\n  const _handler = function (err) {\n    if (err && !_isENOENT(err)) {\n      // reraise any unanticipated error\n      return next(err);\n    }\n    next();\n  };\n\n  if (0 <= fdPath[0])\n    fs.close(fdPath[0], function () {\n      fs.unlink(fdPath[1], _handler);\n    });\n  else fs.unlink(fdPath[1], _handler);\n}\n\n/**\n * Removes files synchronously.\n *\n * @param {Object} fdPath\n * @private\n */\nfunction _removeFileSync(fdPath) {\n  let rethrownException = null;\n  try {\n    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);\n  } catch (e) {\n    // reraise any unanticipated error\n    if (!_isEBADF(e) && !_isENOENT(e)) throw e;\n  } finally {\n    try {\n      fs.unlinkSync(fdPath[1]);\n    }\n    catch (e) {\n      // reraise any unanticipated error\n      if (!_isENOENT(e)) rethrownException = e;\n    }\n  }\n  if (rethrownException !== null) {\n    throw rethrownException;\n  }\n}\n\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * Returns either a sync callback or a async callback depending on whether\n * fileSync or file was called, which is expressed by the sync parameter.\n *\n * @param {string} name the path of the file\n * @param {number} fd file descriptor\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {fileCallback | fileCallbackSync}\n * @private\n */\nfunction _prepareTmpFileRemoveCallback(name, fd, opts, sync) {\n  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync);\n  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync, removeCallbackSync);\n\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n\n  return sync ? removeCallbackSync : removeCallback;\n}\n\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * Returns either a sync callback or a async callback depending on whether\n * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.\n *\n * @param {string} name\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {Function} the callback\n * @private\n */\nfunction _prepareTmpDirRemoveCallback(name, opts, sync) {\n  const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);\n  const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;\n  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);\n  const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);\n  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n\n  return sync ? removeCallbackSync : removeCallback;\n}\n\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * The cleanup callback is save to be called multiple times.\n * Subsequent invocations will be ignored.\n *\n * @param {Function} removeFunction\n * @param {string} fileOrDirName\n * @param {boolean} sync\n * @param {cleanupCallbackSync?} cleanupCallbackSync\n * @returns {cleanupCallback | cleanupCallbackSync}\n * @private\n */\nfunction _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {\n  let called = false;\n\n  // if sync is true, the next parameter will be ignored\n  return function _cleanupCallback(next) {\n\n    /* istanbul ignore else */\n    if (!called) {\n      // remove cleanupCallback from cache\n      const toRemove = cleanupCallbackSync || _cleanupCallback;\n      const index = _removeObjects.indexOf(toRemove);\n      /* istanbul ignore else */\n      if (index >= 0) _removeObjects.splice(index, 1);\n\n      called = true;\n      if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {\n        return removeFunction(fileOrDirName);\n      } else {\n        return removeFunction(fileOrDirName, next || function() {});\n      }\n    }\n  };\n}\n\n/**\n * The garbage collector.\n *\n * @private\n */\nfunction _garbageCollector() {\n  /* istanbul ignore else */\n  if (!_gracefulCleanup) return;\n\n  // the function being called removes itself from _removeObjects,\n  // loop until _removeObjects is empty\n  while (_removeObjects.length) {\n    try {\n      _removeObjects[0]();\n    } catch (e) {\n      // already removed?\n    }\n  }\n}\n\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {number} howMany\n * @returns {string} the generated random name\n * @private\n */\nfunction _randomChars(howMany) {\n  let\n    value = [],\n    rnd = null;\n\n  // make sure that we do not fail because we ran out of entropy\n  try {\n    rnd = crypto.randomBytes(howMany);\n  } catch (e) {\n    rnd = crypto.pseudoRandomBytes(howMany);\n  }\n\n  for (var i = 0; i < howMany; i++) {\n    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n  }\n\n  return value.join('');\n}\n\n/**\n * Helper which determines whether a string s is blank, that is undefined, or empty or null.\n *\n * @private\n * @param {string} s\n * @returns {Boolean} true whether the string s is blank, false otherwise\n */\nfunction _isBlank(s) {\n  return s === null || _isUndefined(s) || !s.trim();\n}\n\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @returns {boolean} true if the object is undefined\n * @private\n */\nfunction _isUndefined(obj) {\n  return typeof obj === 'undefined';\n}\n\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {(Options|null|undefined|Function)} options\n * @param {?Function} callback\n * @returns {Array} parsed arguments\n * @private\n */\nfunction _parseArguments(options, callback) {\n  /* istanbul ignore else */\n  if (typeof options === 'function') {\n    return [{}, options];\n  }\n\n  /* istanbul ignore else */\n  if (_isUndefined(options)) {\n    return [{}, callback];\n  }\n\n  // copy options so we do not leak the changes we make internally\n  const actualOptions = {};\n  for (const key of Object.getOwnPropertyNames(options)) {\n    actualOptions[key] = options[key];\n  }\n\n  return [actualOptions, callback];\n}\n\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {string} the new random name according to opts\n * @private\n */\nfunction _generateTmpName(opts) {\n\n  const tmpDir = opts.tmpdir;\n\n  /* istanbul ignore else */\n  if (!_isUndefined(opts.name))\n    return path.join(tmpDir, opts.dir, opts.name);\n\n  /* istanbul ignore else */\n  if (!_isUndefined(opts.template))\n    return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));\n\n  // prefix and postfix\n  const name = [\n    opts.prefix ? opts.prefix : 'tmp',\n    '-',\n    process.pid,\n    '-',\n    _randomChars(12),\n    opts.postfix ? '-' + opts.postfix : ''\n  ].join('');\n\n  return path.join(tmpDir, opts.dir, name);\n}\n\n/**\n * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing\n * options.\n *\n * @param {Options} options\n * @private\n */\nfunction _assertAndSanitizeOptions(options) {\n\n  options.tmpdir = _getTmpDir(options);\n\n  const tmpDir = options.tmpdir;\n\n  /* istanbul ignore else */\n  if (!_isUndefined(options.name))\n    _assertIsRelative(options.name, 'name', tmpDir);\n  /* istanbul ignore else */\n  if (!_isUndefined(options.dir))\n    _assertIsRelative(options.dir, 'dir', tmpDir);\n  /* istanbul ignore else */\n  if (!_isUndefined(options.template)) {\n    _assertIsRelative(options.template, 'template', tmpDir);\n    if (!options.template.match(TEMPLATE_PATTERN))\n      throw new Error(`Invalid template, found \"${options.template}\".`);\n  }\n  /* istanbul ignore else */\n  if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0)\n    throw new Error(`Invalid tries, found \"${options.tries}\".`);\n\n  // if a name was specified we will try once\n  options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;\n  options.keep = !!options.keep;\n  options.detachDescriptor = !!options.detachDescriptor;\n  options.discardDescriptor = !!options.discardDescriptor;\n  options.unsafeCleanup = !!options.unsafeCleanup;\n\n  // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to\n  options.dir = _isUndefined(options.dir) ? '' : path.relative(tmpDir, _resolvePath(options.dir, tmpDir));\n  options.template = _isUndefined(options.template) ? undefined : path.relative(tmpDir, _resolvePath(options.template, tmpDir));\n  // sanitize further if template is relative to options.dir\n  options.template = _isBlank(options.template) ? undefined : path.relative(options.dir, options.template);\n\n  // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to\n  options.name = _isUndefined(options.name) ? undefined : _sanitizeName(options.name);\n  options.prefix = _isUndefined(options.prefix) ? '' : options.prefix;\n  options.postfix = _isUndefined(options.postfix) ? '' : options.postfix;\n}\n\n/**\n * Resolve the specified path name in respect to tmpDir.\n *\n * The specified name might include relative path components, e.g. ../\n * so we need to resolve in order to be sure that is is located inside tmpDir\n *\n * @param name\n * @param tmpDir\n * @returns {string}\n * @private\n */\nfunction _resolvePath(name, tmpDir) {\n  const sanitizedName = _sanitizeName(name);\n  if (sanitizedName.startsWith(tmpDir)) {\n    return path.resolve(sanitizedName);\n  } else {\n    return path.resolve(path.join(tmpDir, sanitizedName));\n  }\n}\n\n/**\n * Sanitize the specified path name by removing all quote characters.\n *\n * @param name\n * @returns {string}\n * @private\n */\nfunction _sanitizeName(name) {\n  if (_isBlank(name)) {\n    return name;\n  }\n  return name.replace(/[\"']/g, '');\n}\n\n/**\n * Asserts whether specified name is relative to the specified tmpDir.\n *\n * @param {string} name\n * @param {string} option\n * @param {string} tmpDir\n * @throws {Error}\n * @private\n */\nfunction _assertIsRelative(name, option, tmpDir) {\n  if (option === 'name') {\n    // assert that name is not absolute and does not contain a path\n    if (path.isAbsolute(name))\n      throw new Error(`${option} option must not contain an absolute path, found \"${name}\".`);\n    // must not fail on valid .<name> or ..<name> or similar such constructs\n    let basename = path.basename(name);\n    if (basename === '..' || basename === '.' || basename !== name)\n      throw new Error(`${option} option must not contain a path, found \"${name}\".`);\n  }\n  else { // if (option === 'dir' || option === 'template') {\n    // assert that dir or template are relative to tmpDir\n    if (path.isAbsolute(name) && !name.startsWith(tmpDir)) {\n      throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${name}\".`);\n    }\n    let resolvedPath = _resolvePath(name, tmpDir);\n    if (!resolvedPath.startsWith(tmpDir))\n      throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${resolvedPath}\".`);\n  }\n}\n\n/**\n * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */\nfunction _isEBADF(error) {\n  return _isExpectedError(error, -EBADF, 'EBADF');\n}\n\n/**\n * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */\nfunction _isENOENT(error) {\n  return _isExpectedError(error, -ENOENT, 'ENOENT');\n}\n\n/**\n * Helper to determine whether the expected error code matches the actual code and errno,\n * which will differ between the supported node versions.\n *\n * - Node >= 7.0:\n *   error.code {string}\n *   error.errno {number} any numerical value will be negated\n *\n * CAVEAT\n *\n * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT\n * is no different here.\n *\n * @param {SystemError} error\n * @param {number} errno\n * @param {string} code\n * @private\n */\nfunction _isExpectedError(error, errno, code) {\n  return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;\n}\n\n/**\n * Sets the graceful cleanup.\n *\n * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the\n * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary\n * object removals.\n */\nfunction setGracefulCleanup() {\n  _gracefulCleanup = true;\n}\n\n/**\n * Returns the currently configured tmp dir from os.tmpdir().\n *\n * @private\n * @param {?Options} options\n * @returns {string} the currently configured tmp dir\n */\nfunction _getTmpDir(options) {\n  return path.resolve(_sanitizeName(options && options.tmpdir || os.tmpdir()));\n}\n\n// Install process exit listener\nprocess.addListener(EXIT, _garbageCollector);\n\n/**\n * Configuration options.\n *\n * @typedef {Object} Options\n * @property {?boolean} keep the temporary object (file or dir) will not be garbage collected\n * @property {?number} tries the number of tries before give up the name generation\n * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files\n * @property {?string} template the \"mkstemp\" like filename template\n * @property {?string} name fixed name relative to tmpdir or the specified dir option\n * @property {?string} dir tmp directory relative to the root tmp directory in use\n * @property {?string} prefix prefix for the generated name\n * @property {?string} postfix postfix for the generated name\n * @property {?string} tmpdir the root tmp directory which overrides the os tmpdir\n * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty\n * @property {?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection\n * @property {?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection\n */\n\n/**\n * @typedef {Object} FileSyncObject\n * @property {string} name the name of the file\n * @property {string} fd the file descriptor or -1 if the fd has been discarded\n * @property {fileCallback} removeCallback the callback function to remove the file\n */\n\n/**\n * @typedef {Object} DirSyncObject\n * @property {string} name the name of the directory\n * @property {fileCallback} removeCallback the callback function to remove the directory\n */\n\n/**\n * @callback tmpNameCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n */\n\n/**\n * @callback fileCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback fileCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallback} fn the cleanup callback function\n */\n\n/**\n * @callback dirCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallback\n * @param {simpleCallback} [next] function to call whenever the tmp object needs to be removed\n */\n\n/**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallbackSync\n */\n\n/**\n * Callback function for function composition.\n * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}\n *\n * @callback simpleCallback\n */\n\n// exporting all the needed methods\n\n// evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will\n// allow users to reconfigure the temporary directory\nObject.defineProperty(module.exports, 'tmpdir', {\n  enumerable: true,\n  configurable: false,\n  get: function () {\n    return _getTmpDir();\n  }\n});\n\nmodule.exports.dir = dir;\nmodule.exports.dirSync = dirSync;\n\nmodule.exports.file = file;\nmodule.exports.fileSync = fileSync;\n\nmodule.exports.tmpName = tmpName;\nmodule.exports.tmpNameSync = tmpNameSync;\n\nmodule.exports.setGracefulCleanup = setGracefulCleanup;\n","import { spawn } from \"child_process\";\nimport fs from \"fs\";\nimport readline from \"readline\";\nimport tmp from \"tmp\";\nimport { promiseHandle } from \"../../promises\";\n\nconst VERBOSE = false;\n\n// This cleans up the temporary files, beware.\ntmp.setGracefulCleanup();\n\nexport interface TajServer {\n  stop: () => void;\n  port: number;\n  url: string;\n  username: string;\n  password: string;\n  srtoken: string;\n}\n\nconst config = (\n  username = \"username\",\n  password = \"password\",\n  srtoken = \"0123456789123456\"\n) =>\n  `[tajriba.auth]\nsrtoken = \"` +\n  srtoken +\n  `\"\n\n[[tajriba.auth.users]]\nname = \"Nicolas\"\nusername = \"` +\n  username +\n  `\"\npassword = \"` +\n  password +\n  `\"\n`;\n\nfunction createTajribaConfigFile(config: string): string {\n  const { name } = tmp.fileSync({ discardDescriptor: true, postfix: \".toml\" });\n  fs.writeFileSync(name, config);\n  return name;\n}\n\nexport interface StartTajribaOptions {\n  configFile?: string;\n  tajFile?: string;\n  logLevel?: string;\n  printLogs?: boolean;\n  srtoken?: string;\n  username?: string;\n  password?: string;\n}\n\nexport async function startTajriba(\n  options: StartTajribaOptions = {}\n): Promise<TajServer> {\n  let port: number;\n  const logLevel = options.logLevel ?? \"trace\";\n\n  let configFile =\n    options.configFile ??\n    createTajribaConfigFile(\n      config(options.username, options.password, options.srtoken)\n    );\n\n  const args = [\n    \"tajriba\",\n    \"--config\",\n    configFile,\n    \"--log.level\",\n    logLevel,\n    \"--log.json\",\n    \"--tajriba.log.level\",\n    logLevel,\n    \"--tajriba.log.json\",\n    \"--tajriba.server.addr\",\n    \":0\",\n  ];\n\n  if (options.tajFile) {\n    args.push(\"--tajriba.store.file\", options.tajFile);\n  } else {\n    args.push(\"--tajriba.store.mem\");\n  }\n\n  // console.log(args);\n\n  const taj = spawn(\"empirica\", args);\n\n  readline.createInterface({ input: taj.stdout! }).on(\"line\", (data) => {\n    console.log(`stdout: ${data}`);\n  });\n\n  const portProm = promiseHandle<number>();\n\n  readline.createInterface({ input: taj.stderr! }).on(\"line\", (data) => {\n    try {\n      const dat = JSON.parse(data);\n      if (dat[\"message\"] && dat[\"message\"] === \"Started Tajriba server\") {\n        portProm.result(dat[\"port\"] as number);\n      }\n\n      if (\n        VERBOSE ||\n        options.printLogs ||\n        (dat[\"level\"] && dat[\"level\"] === \"error\")\n      ) {\n        console.log(`stderr: ${data}`);\n      }\n    } catch (e) {\n      console.error(data.toString());\n    }\n  });\n\n  taj.on(\"error\", (error) => {\n    console.error(`error: ${error.message}`);\n  });\n\n  taj.on(\"close\", (code) => {\n    if (code) {\n      console.log(`child process exited with code ${code}`);\n    }\n  });\n\n  port = await portProm.promise;\n\n  // Wait to make sure HTTP server is ready with all endpoints.\n  await sleep(200);\n\n  let stopped = false;\n  return {\n    port,\n    get url() {\n      return `http://localhost:${port}/query`;\n    },\n    get username() {\n      return options.username || \"username\";\n    },\n    get password() {\n      return options.password || \"password\";\n    },\n    get srtoken() {\n      return options.srtoken || \"0123456789123456\";\n    },\n    stop: function stopTajriba() {\n      if (!stopped) {\n        // console.log(\"kill\", port);\n        taj.kill(\"SIGKILL\");\n        stopped = true;\n      }\n    },\n  };\n}\n\nexport async function withTajriba(\n  fn: (tajServer: TajServer) => void,\n  options: StartTajribaOptions = {}\n) {\n  const srv = await startTajriba(options);\n  try {\n    await fn(srv);\n  } catch (err) {\n    console.error(err);\n    process.exit(1);\n  } finally {\n    srv.stop();\n  }\n}\n\nexport function sleep(ms: number): Promise<void> {\n  return new Promise((r) => setTimeout(r, ms));\n}\n","import { State } from \"@empirica/tajriba\";\nimport { z } from \"zod\";\nimport { Attribute } from \"../../shared/attributes\";\nimport { debug, error, trace, warn } from \"../../utils/console\";\nimport { deepEqual } from \"../../utils/object\";\nimport { pickRandom, selectRandom } from \"../../utils/random\";\nimport { EventContext, ListenersCollector, TajribaEvent } from \"../events\";\nimport { Participant } from \"../participants\";\nimport { Step, Transition } from \"../transitions\";\nimport { attrs } from \"./helpers\";\nimport {\n  Batch,\n  ClassicKinds,\n  Context,\n  evt,\n  Game,\n  Player,\n  PlayerStage,\n  Round,\n  Stage,\n} from \"./models\";\nimport { batchConfigSchema, treatmentSchema } from \"./schemas\";\n\n// const isBatch = z.instanceof(Batch).parse;\nconst isGame = z.instanceof(Game).parse;\nconst isRound = z.instanceof(Round).parse;\nconst isStage = z.instanceof(Stage).parse;\nconst isString = z.string().parse;\n\nexport type ClassicConfig = {\n  // Disables automatic assignment of players on the connection of a new player.\n  // It is up to the developer to call `game.assignPlayer` when they want to\n  // assign a player to a game.\n  disableAssignment?: boolean;\n\n  // Disable the introDone check (when the players are done with intro steps),\n  // which normally will check if enough players are ready (done with intro\n  // steps) to start a game. This means that the game will not start on its own\n  // after intro steps. It is up to the developer to start the game manually\n  // with `game.start()`.\n  // This also disables playerCount checks and overflow from one game to the\n  // next available game with the same treatment.\n  disableIntroCheck?: boolean;\n\n  // Disable game creation on new batch.\n  disableGameCreation?: boolean;\n\n  // By default if all existing games are complete, the batch ends.\n  // This option disables this pattern so that we can leave a batch open indefinitely.\n  // It enables to spawn new games for people who arrive later, even if all previous games had already finished.\n  disableBatchAutoend?: boolean;\n};\n\nexport function Classic({\n  disableAssignment,\n  disableIntroCheck,\n  disableGameCreation,\n  disableBatchAutoend = false,\n}: ClassicConfig = {}) {\n  return function (_: ListenersCollector<Context, ClassicKinds>) {\n    const online = new Map<string, Participant>();\n    const playersForParticipant = new Map<string, Player>();\n    const stageForStepID = new Map<string, Stage>();\n\n    async function assignplayer(\n      ctx: EventContext<Context, ClassicKinds>,\n      player: Player,\n      skipGameIDs?: string[]\n    ) {\n      if (disableAssignment) {\n        return;\n      }\n\n      if (player.get(\"gameID\")) {\n        return;\n      }\n\n      for (const batch of evt(ctx).batches) {\n        if (!batch.isRunning) {\n          continue;\n        }\n\n        let availableGames = [];\n\n        for (const game of batch.games) {\n          if (\n            !game.hasStarted &&\n            (!skipGameIDs || !skipGameIDs?.includes(game.id))\n          ) {\n            availableGames.push(game);\n          }\n        }\n\n        if (availableGames.length === 0) {\n          continue;\n        }\n\n        if (player.get(\"treatment\")) {\n          availableGames = availableGames.filter((g) =>\n            deepEqual(g.get(\"treatment\"), player.get(\"treatment\"))\n          );\n        }\n\n        if (availableGames.length === 0) {\n          continue;\n        }\n\n        const game = pickRandom(availableGames);\n\n        await game.assignPlayer(player);\n\n        return;\n      }\n\n      if (player.get(\"gameID\") !== undefined) {\n        player.set(\"ended\", \"no more games\");\n      }\n    }\n\n    function checkShouldOpenExperiment(\n      ctx: EventContext<Context, ClassicKinds>\n    ) {\n      let shouldOpenExperiment = false;\n\n      LOOP: for (const batch of evt(ctx).batches) {\n        if (!batch.isRunning) {\n          continue;\n        }\n\n        for (const game of batch.games) {\n          if (!game.hasStarted) {\n            shouldOpenExperiment = true;\n            break LOOP;\n          }\n        }\n      }\n\n      ctx.globals.set(\"experimentOpen\", shouldOpenExperiment);\n    }\n\n    function tryToStartGame(\n      ctx: EventContext<Context, ClassicKinds>,\n      game: Game\n    ) {\n      if (game.get(\"stageID\")) return;\n\n      if (game.stages.length === 0) {\n        return;\n      }\n\n      const groupID = isString(game.get(\"groupID\"));\n\n      const players = game.players.filter((p) => !p.get(\"ended\"));\n\n      const participantIDs: string[] = [];\n      const nodeIDs = [game.id, groupID];\n      for (const player of players) {\n        nodeIDs.push(player.id);\n        participantIDs.push(player.participantID!);\n        const playerGameID = player.get(`playerGameID-${game.id}`) as\n          | string\n          | undefined;\n\n        // NOTE: this is not right. This means we're aborting because we're not\n        // ready, but the trigger playerGameID-GAMEID is not a trigger to\n        // attempt starting the game again, so sometimes we might not start the\n        // game. I think. So far, it does not happen in the tests, but it seems\n        // like it could. TBD.\n        if (!playerGameID) {\n          return;\n        }\n        nodeIDs.push(playerGameID);\n      }\n\n      ctx.addLinks([{ link: true, participantIDs, nodeIDs }]);\n\n      const round = isRound(game.rounds[0]);\n\n      if (round.stages.length === 0) {\n        return;\n      }\n\n      const stage = isStage(round.stages[0]);\n\n      game.set(\"stageID\", stage.id);\n\n      round.set(\"start\", true);\n    }\n\n    _.on(TajribaEvent.ParticipantConnect, async (ctx, { participant }) => {\n      online.set(participant.id, participant);\n\n      const player = playersForParticipant.get(participant.id);\n\n      if (!player) {\n        // console.log(\"CREATE PLAYER\", participant.id);\n        await ctx.addScopes([\n          {\n            attributes: attrs([\n              {\n                key: \"participantID\",\n                value: participant.id,\n                immutable: true,\n              },\n              {\n                key: \"participantIdentifier\",\n                value: participant.identifier,\n                immutable: true,\n              },\n            ]),\n            kind: \"player\",\n          },\n        ]);\n      } else {\n        // console.log(\"ALREADY\", participant.id, player.id);\n        await assignplayer(ctx, player);\n      }\n    });\n\n    _.on(TajribaEvent.ParticipantDisconnect, (_, { participant }) => {\n      online.delete(participant.id);\n    });\n\n    _.on(\"player\", async (ctx, { player }: { player: Player }) => {\n      const participantID = isString(player.get(\"participantID\"));\n\n      player.participantID = participantID;\n      playersForParticipant.set(participantID, player);\n\n      ctx.addLinks([\n        {\n          link: true,\n          participantIDs: [player.participantID!],\n          nodeIDs: [player.id],\n        },\n      ]);\n\n      if (online.has(participantID)) {\n        await assignplayer(ctx, player);\n      }\n    });\n\n    _.on(\"batch\", (_, { batch }: { batch: Batch }) => {\n      if (disableGameCreation || batch.get(\"initialized\")) {\n        return;\n      }\n\n      batch.set(\"initialized\", true);\n\n      const config = batchConfigSchema.parse(batch.get(\"config\"));\n\n      switch (config.kind) {\n        case \"simple\":\n          for (let i = 0; i < config.config.count; i++) {\n            const treatment = pickRandom(config.config.treatments).factors;\n            batch.addGame([\n              {\n                key: \"treatment\",\n                value: treatment,\n                immutable: true,\n              },\n            ]);\n          }\n\n          break;\n        case \"complete\":\n          for (const t of config.config.treatments) {\n            for (let i = 0; i < t.count; i++) {\n              batch.addGame([\n                {\n                  key: \"treatment\",\n                  value: t.treatment.factors,\n                  immutable: true,\n                },\n              ]);\n            }\n          }\n\n          break;\n        default:\n          warn(\"callbacks: batch created without a config\");\n\n          return;\n      }\n    });\n\n    type BatchStatus = { batch: Batch; status: string };\n    _.unique.on(\n      \"batch\",\n      \"status\",\n      async (ctx, { batch, status }: BatchStatus) => {\n        switch (status) {\n          case \"running\": {\n            for (const [_, player] of playersForParticipant) {\n              if (player.participantID) {\n                await assignplayer(ctx, player);\n              }\n            }\n\n            checkShouldOpenExperiment(ctx);\n            break;\n          }\n          case \"terminated\":\n            for (const game of batch.games) {\n              game.end(status, \"batch ended\");\n            }\n\n            checkShouldOpenExperiment(ctx);\n\n            break;\n\n          case \"ended\":\n            checkShouldOpenExperiment(ctx);\n\n            break;\n          case \"created\":\n            // noop\n\n            break;\n          default:\n            warn(\"unknown batch status:\", status);\n\n            break;\n        }\n      }\n    );\n\n    type GameStatus = { game: Game; status: string };\n    _.unique.on(\"game\", \"status\", (ctx, { game, status }: GameStatus) => {\n      switch (status) {\n        case \"running\": {\n          tryToStartGame(ctx, game);\n          checkShouldOpenExperiment(ctx);\n\n          break;\n        }\n\n        case \"ended\":\n        case \"failed\":\n        case \"terminated\":\n          for (const player of game.players) {\n            player.set(\"ended\", `game ${status}`);\n          }\n\n          const finishedBatch =\n            !disableBatchAutoend && game.batch!.games.every((g) => g.hasEnded);\n\n          if (finishedBatch) {\n            game.batch!.end(\"all games finished\");\n          }\n\n          checkShouldOpenExperiment(ctx);\n\n          break;\n        default:\n          warn(`unkown game status: ${status}`);\n\n          break;\n      }\n    });\n\n    _.on(\"game\", async (ctx, { game }) => {\n      if (game.get(\"groupID\")) {\n        return;\n      }\n\n      // Create empty group for now, add players as assigned\n\n      let groups: { id: string }[];\n      try {\n        groups = await ctx.addGroups([{ participantIDs: [] }]);\n      } catch (err) {\n        error(`failed to create game group: ${err}`);\n\n        return;\n      }\n\n      if (groups.length < 1) {\n        error(`failed to create game groups`);\n\n        return;\n      }\n\n      const groupID = groups[0]!.id;\n\n      game.set(\"groupID\", groupID);\n    });\n\n    _.on(\"stage\", \"gameID\", async (ctx, { stage }: { stage: Stage }) => {\n      if (!stage.currentGame?.isRunning) {\n        return;\n      }\n\n      tryToStartGame(ctx, stage.currentGame);\n    });\n\n    type StageTimerID = { stage: Stage; timerID: string };\n    _.after(\"stage\", \"timerID\", (_, { stage, timerID }: StageTimerID) => {\n      stageForStepID.set(timerID, stage);\n    });\n\n    function getNextStage(\n      stage: Stage,\n      game: Game\n    ):\n      | { stop: true; nextStage: undefined; nextRound: undefined }\n      | { stop: false; nextStage: Stage; nextRound: Round } {\n      // Stop if we're at the end of the game\n      if (game.hasEnded) {\n        return { stop: true, nextStage: undefined, nextRound: undefined };\n      }\n\n      // Get the next stage in round\n      const currentRound = isRound(stage.round);\n      let nextRound: Round | undefined = currentRound;\n      const roundStages = currentRound.stages;\n      let nextStage: Stage | undefined =\n        roundStages[(stage.get(\"index\") as number) + 1];\n\n      // If no more stages in round, get next round\n      if (!nextStage) {\n        const gameRounds = game.rounds;\n        nextRound = gameRounds[(currentRound.get(\"index\") as number) + 1];\n\n        // If no more rounds in game, stop\n        if (!nextRound) {\n          return { stop: true, nextStage: undefined, nextRound: undefined };\n        }\n\n        // Get first stage in next round\n        nextStage = nextRound.stages[0];\n\n        // If next round is empty for whatever reason, stop\n        if (!nextStage) {\n          return { stop: true, nextStage: undefined, nextRound: undefined };\n        }\n      }\n\n      return { nextStage, nextRound, stop: false };\n    }\n\n    _.on(\"player\", \"introDone\", async (ctx, { player }: { player: Player }) => {\n      if (disableIntroCheck || !player.currentGame) {\n        return;\n      }\n\n      const game = isGame(player.currentGame);\n      const treatment = treatmentSchema.parse(game.get(\"treatment\"));\n      const playerCount = treatment[\"playerCount\"] as number;\n      const readyPlayers = game.players.filter(\n        (p) => p.get(\"introDone\") && !p.get(\"ended\")\n      );\n\n      if (readyPlayers.length < playerCount) {\n        trace(\"introDone: not enough players ready yet\");\n\n        return;\n      }\n\n      if (game.hasStarted) {\n        trace(\"introDone: game already started\");\n\n        return;\n      }\n\n      const players = selectRandom(readyPlayers, playerCount);\n      const playersIDS = players.map((p) => p.id);\n      for (const plyr of game.players) {\n        if (!playersIDS.includes(plyr.id)) {\n          plyr.set(\"gameID\", null);\n          await assignplayer(ctx, plyr, [game.id]);\n        }\n      }\n\n      trace(\"introDone: starting game\");\n      game.start();\n    });\n\n    type BeforeGameStart = { game: Game; start: boolean };\n    _.unique.before(\n      \"game\",\n      \"start\",\n      async (_, { game, start }: BeforeGameStart) => {\n        if (!start) {\n          return;\n        }\n\n        for (const player of game.players) {\n          await game.createPlayerGame(player);\n        }\n      }\n    );\n\n    type AfterGameStart = { game: Game; start: boolean };\n    _.unique.after(\"game\", \"start\", (_, { game, start }: AfterGameStart) => {\n      if (!start) {\n        return;\n      }\n\n      game.set(\"status\", \"running\");\n    });\n\n    type BeforeRoundStart = { round: Round; start: boolean };\n    _.unique.before(\n      \"round\",\n      \"start\",\n      async (_, { round, start }: BeforeRoundStart) => {\n        if (!start) {\n          return;\n        }\n\n        const game = isGame(round.currentGame);\n\n        for (const player of game.players) {\n          await round.createPlayerRound(player);\n        }\n      }\n    );\n\n    type AfterRoundStart = {\n      round: Round;\n      start: boolean;\n      attribute: Attribute;\n    };\n    _.unique.after(\n      \"round\",\n      \"start\",\n      (ctx, { round, start }: AfterRoundStart) => {\n        if (!start) return;\n\n        const game = isGame(round.currentGame);\n        const stageID = isString(game.get(\"stageID\"));\n\n        const stage = isStage(game.stages.find((s) => s.id === stageID));\n\n        if (stage.get(\"start\")) {\n          return;\n        }\n\n        const participantIDs: string[] = [];\n        const nodeIDs = [round.id];\n        for (const player of game.players) {\n          participantIDs.push(player.participantID!);\n          nodeIDs.push(isString(player.get(`playerRoundID-${round.id}`)));\n        }\n\n        ctx.addLinks([{ link: true, participantIDs, nodeIDs }]);\n\n        stage.set(\"start\", true);\n      }\n    );\n\n    type BeforeStageStart = { stage: Stage; start: boolean };\n    _.unique.before(\n      \"stage\",\n      \"start\",\n      async (_, { stage, start }: BeforeStageStart) => {\n        if (!start) return;\n\n        const game = isGame(stage.currentGame);\n\n        for (const player of game.players) {\n          await stage.createPlayerStage(player);\n        }\n      }\n    );\n\n    type AfterStageStart = {\n      stage: Stage;\n      start: boolean;\n      attribute: Attribute;\n    };\n    _.unique.after(\n      \"stage\",\n      \"start\",\n      (ctx, { stage, start }: AfterStageStart) => {\n        if (!start) return;\n\n        // NOTE: this is a hack to get the stage to start only once\n        // TODO ensure that this is only called once.\n        // Currently, it is can  be called multiple times wit the start == true\n        // value, despite the unique.before hook above. This is because the\n        // unique.before hook is not called when the attribute is set to true\n        // but meanwhile the value is becomes true.\n        if (stage.get(\"started\")) {\n          return;\n        }\n        stage.set(\"started\", true);\n\n        const game = isGame(stage.currentGame);\n\n        const timerID = isString(stage.get(\"timerID\"));\n\n        const participantIDs: string[] = [];\n        const nodeIDs = [stage.id, timerID];\n        for (const player of game.players) {\n          participantIDs.push(player.participantID!);\n          nodeIDs.push(isString(player.get(`playerStageID-${stage.id}`)));\n        }\n\n        ctx.addLinks([{ link: true, participantIDs, nodeIDs }]);\n\n        ctx.addTransitions([\n          {\n            from: State.Created,\n            to: State.Running,\n            nodeID: timerID,\n            cause: \"stage start\",\n          },\n        ]);\n      }\n    );\n\n    type PlayerStageSubmit = { playerStage: PlayerStage; submit: boolean };\n    _.after(\n      \"playerStage\",\n      \"submit\",\n      (ctx, { playerStage, submit }: PlayerStageSubmit) => {\n        if (!submit) return;\n\n        if (!playerStage.stage || !playerStage.stage.isCurrent()) {\n          return;\n        }\n\n        const players = playerStage.player!.currentGame!.players;\n        if (players.length === 0) {\n          warn(\"callbacks: no players onSubmit\");\n          return;\n        }\n\n        const haveAllPlayersSubmitted = players.every(\n          (p) =>\n            p.get(\"ended\") ||\n            !online.has(p.get(\"participantID\")?.toString() as string) ||\n            p.stage?.get(\"submit\")\n        );\n\n        if (haveAllPlayersSubmitted) {\n          ctx.addTransitions([\n            {\n              from: State.Running,\n              to: State.Ended,\n              nodeID: isString(playerStage.stage!.get(\"timerID\")),\n              cause: \"players submitted\",\n            },\n          ]);\n          trace(`all player submitted, transitioning`);\n        } else {\n          trace(`not all player submitted`);\n        }\n      }\n    );\n\n    type AfterStageEnded = { stage: Stage; ended: boolean };\n    _.unique.after(\n      \"stage\",\n      \"ended\",\n      (ctx, { stage, ended }: AfterStageEnded) => {\n        if (!ended) return;\n\n        const game = isGame(stage.currentGame);\n        const timerID = isString(stage.get(\"timerID\"));\n        const round = isRound(stage.round);\n\n        const participantIDs: string[] = [];\n        const nodeIDs: string[] = [stage.id, timerID!];\n        for (const player of game.players) {\n          participantIDs.push(player.participantID!);\n          nodeIDs.push(isString(player.get(`playerStageID-${stage.id}`)));\n        }\n\n        ctx.addLinks([{ link: false, participantIDs, nodeIDs }]);\n\n        const { stop, nextRound, nextStage } = getNextStage(stage, game);\n\n        if (stop) {\n          round.set(\"ended\", true);\n\n          return;\n        }\n\n        if (round.id !== nextRound.id) {\n          round.set(\"ended\", true);\n        } else {\n          game.set(\"stageID\", nextStage.id);\n          nextStage.set(\"start\", true);\n        }\n      }\n    );\n\n    type AfterRoundEnded = { round: Round; ended: boolean };\n    _.unique.after(\n      \"round\",\n      \"ended\",\n      (ctx, { round, ended }: AfterRoundEnded) => {\n        if (!ended) return;\n\n        const game = isGame(round.currentGame);\n        const stage = isStage(game.currentStage);\n\n        const participantIDs: string[] = [];\n        const nodeIDs: string[] = [round.id];\n        for (const player of game.players) {\n          participantIDs.push(player.participantID!);\n          nodeIDs.push(isString(player.get(`playerRoundID-${round.id}`)));\n        }\n\n        ctx.addLinks([{ link: false, participantIDs, nodeIDs }]);\n\n        const { stop, nextRound, nextStage } = getNextStage(stage, game);\n\n        if (stop) {\n          game.set(\"stageID\", null);\n          game.set(\"ended\", true);\n\n          return;\n        }\n\n        game.set(\"stageID\", nextStage.id);\n        nextRound.set(\"start\", true);\n      }\n    );\n\n    type AfterGameEnded = { game: Game; ended: boolean };\n    _.unique.after(\"game\", \"ended\", (_, { game, ended }: AfterGameEnded) => {\n      if (!ended) return;\n\n      game.end(\"ended\", \"end of game\");\n    });\n\n    type TransitionAdd = { step: Step; transition: Transition };\n    _.on(\n      TajribaEvent.TransitionAdd,\n      (_, { step, transition: { from, to } }: TransitionAdd) => {\n        const stage = stageForStepID.get(step.id);\n        if (!stage) {\n          return;\n        }\n\n        debug(`transition stage: ${from} => ${to}`);\n\n        if (from === State.Running && to === State.Ended) {\n          const stage = isStage(stageForStepID.get(step.id));\n\n          if (!stage.get(\"ended\")) {\n            stage.set(\"ended\", true);\n          }\n        }\n      }\n    );\n  };\n}\n","export function pickRandom<T>(items: T[]): T {\n  const random = Math.floor(Math.random() * items.length);\n  return items[random] as T;\n}\n\nexport function shuffle(a: Array<any>) {\n  for (let i = a.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [a[i], a[j]] = [a[j], a[i]];\n  }\n  return a;\n}\n\nexport function selectRandom(arr: Array<any>, num: number) {\n  return shuffle(arr.slice()).slice(0, num);\n}\n","import { AddScopeInput, SetAttributeInput } from \"@empirica/tajriba\";\nimport { AttributeOptions } from \"../../shared/attributes\";\nimport { JsonValue } from \"../../utils/json\";\n\nexport function attribs(scopeID: string) {\n  const result: SetAttributeInput[] = [];\n\n  return {\n    set: (key: string, value: JsonValue, ao?: Partial<AttributeOptions>) => {\n      const props: SetAttributeInput = {\n        key: key,\n        nodeID: scopeID,\n        val: JSON.stringify(value),\n        ...ao,\n      };\n\n      result.push(props);\n    },\n    result,\n  };\n}\n\nexport function scopeConstructor(input: AddScopeInput) {\n  return [\n    input,\n    {\n      get(key: string) {\n        const attr = input.attributes?.find((a) => a.key === key);\n        if (!attr) {\n          return;\n        }\n\n        return attr.val ? JSON.parse(attr.val) : undefined;\n      },\n      set: (key: string, value: JsonValue, ao?: Partial<AttributeOptions>) => {\n        const attr = input.attributes?.find((a) => a.key === key);\n        if (attr) {\n          attr.val = JSON.stringify(value);\n\n          return;\n        }\n\n        const props: SetAttributeInput = {\n          key: key,\n          val: JSON.stringify(value),\n          ...ao,\n        };\n\n        if (!input.attributes) {\n          input.attributes = [];\n        }\n\n        input.attributes.push(props);\n      },\n    },\n  ] as const;\n}\n\nexport type AttrInput = {\n  append?: boolean;\n  immutable?: boolean;\n  index?: number;\n  key: string;\n  nodeID?: string;\n  private?: boolean;\n  protected?: boolean;\n  value: JsonValue;\n  vector?: boolean;\n};\n\nexport function attrs(attrs: AttrInput[]) {\n  const result: SetAttributeInput[] = [];\n\n  for (const attr of attrs) {\n    const {\n      append,\n      immutable,\n      index,\n      key,\n      nodeID,\n      private: privat,\n      protected: protecte,\n      value,\n    } = attr;\n\n    result.push({\n      append,\n      immutable,\n      index,\n      key,\n      nodeID,\n      private: privat,\n      protected: protecte,\n      val: JSON.stringify(value),\n    });\n  }\n\n  return result;\n}\n","import { AddScopeInput, State } from \"@empirica/tajriba\";\nimport { z } from \"zod\";\nimport { Constructor } from \"../../shared/helpers\";\nimport { Attributable } from \"../../shared/scopes\";\nimport { error, warn } from \"../../utils/console\";\nimport { JsonValue } from \"../../utils/json\";\nimport { AddScopePayload, StepPayload } from \"../context\";\nimport { EventContext } from \"../events\";\nimport { Scope } from \"../scopes\";\nimport { AttrInput, attrs, scopeConstructor } from \"./helpers\";\n\nconst isString = z.string().parse;\nconst isOptionalNumber = z.number().optional().parse;\n\nexport const endedStatuses = [\"ended\", \"terminated\", \"failed\"];\nexport type EndedStatuses = (typeof endedStatuses)[number];\n\nconst reservedKeys = [\n  \"batchID\",\n  \"gameID\",\n  \"stageID\",\n  \"roundID\",\n  \"start\",\n  \"ended\",\n  \"timerID\",\n];\n\nexport const lobbyConfigSchema = z.object({\n  kind: z.union([z.literal(\"shared\"), z.literal(\"individual\")]),\n  duration: z.number().min(1),\n  strategy: z.union([z.literal(\"fail\"), z.literal(\"ignore\")]),\n  extensions: z.number().min(1).optional(),\n});\n\nconst indexSortable = (a: Attributable, b: Attributable) =>\n  (a.get(\"index\") as number) - (b.get(\"index\") as number);\n\nexport class Batch extends Scope<Context, ClassicKinds> {\n  get isRunning() {\n    return this.get(\"status\") === \"running\";\n  }\n\n  get games() {\n    return this.scopesByKindMatching<Game>(\"game\", \"batchID\", this.id);\n  }\n\n  addGame(attributes: { [key: string]: JsonValue } | AttrInput[]) {\n    if (!Array.isArray(attributes)) {\n      const newAttr: AttrInput[] = [];\n      for (const key in attributes) {\n        newAttr.push({\n          key,\n          value: attributes[key]!,\n        });\n      }\n\n      attributes = newAttr;\n    }\n\n    const [scope, accessors] = scopeConstructor({\n      kind: \"game\",\n      attributes: attrs([\n        ...attributes.filter((a) => !reservedKeys.includes(a.key)),\n        {\n          key: \"batchID\",\n          value: this.id,\n          immutable: true,\n        },\n        {\n          key: \"start\",\n          value: false,\n          protected: true,\n        },\n        {\n          key: \"ended\",\n          value: false,\n          protected: true,\n        },\n      ]),\n    });\n\n    this.addScopes([scope]);\n\n    return accessors;\n  }\n\n  end(reason: string) {\n    if (this.hasEnded) {\n      return;\n    }\n\n    this.set(\"status\", \"ended\");\n    this.set(\"endedReason\", reason);\n  }\n\n  get hasEnded() {\n    return endedStatuses.includes(this.get(\"status\") as EndedStatuses);\n  }\n\n  get lobbyConfig() {\n    return lobbyConfigSchema.parse(this.get(\"lobbyConfig\"));\n  }\n}\n\nexport class BatchOwned extends Scope<Context, ClassicKinds> {\n  get batch() {\n    return this.scopeByKey<Batch>(\"batchID\");\n  }\n}\n\nexport class Game extends BatchOwned {\n  // this._tmpRoundIndex is used to keep track of the round index when adding\n  // multiple rounds to a game within a callback, during which the game's\n  // roundIndex attribute is not saved yet.\n  // this._tmpRoundIndex is reset to undefined after the callback is called in\n  // the finalizer.\n  // This is ugly...\n  private _tmpRoundIndex: number | undefined;\n\n  get rounds() {\n    const rounds = this.scopesByKindMatching<Round>(\"round\", \"gameID\", this.id);\n    rounds.sort(indexSortable);\n    return rounds;\n  }\n\n  get stages() {\n    const stages = this.scopesByKindMatching<Stage>(\"stage\", \"gameID\", this.id);\n    stages.sort(indexSortable);\n    return stages;\n  }\n\n  get players() {\n    return this.scopesByKindMatching<Player>(\"player\", \"gameID\", this.id);\n  }\n\n  get currentStage() {\n    return this.scopeByKey<Stage>(\"stageID\");\n  }\n\n  get currentRound() {\n    return this.currentStage?.round;\n  }\n\n  get hasEnded() {\n    return endedStatuses.includes(this.get(\"status\") as EndedStatuses);\n  }\n\n  // The game has started, but it might not be running yet, it might still be in\n  // the gameStart callbacks.\n  // This will always be true once the game has started (even after the game\n  // ends).\n  get hasStarted() {\n    return Boolean(this.get(\"start\"));\n  }\n\n  get hasNotStarted() {\n    return !this.hasStarted;\n  }\n\n  // Game has passed the gameStart callbacks and is currently running. This will\n  // be true until the game ends.\n  get isRunning() {\n    return this.get(\"status\") === \"running\";\n  }\n\n  get lobbyConfig() {\n    return this.batch!.lobbyConfig;\n  }\n\n  // Starts the game if it is not already started.\n  start() {\n    if (!this.get(\"start\")) {\n      this.set(\"start\", true);\n    }\n  }\n\n  async assignPlayer(player: Player) {\n    if (this.hasEnded) {\n      throw new Error(\"cannot assign player to ended Game\");\n    }\n\n    const previousGameID = player.get(\"gameID\");\n    const previousGameTreatment = player.get(\"treatment\");\n\n    const treatment = this.get(\"treatment\");\n    if (!treatment) {\n      warn(`game without treatment: ${this.id}`);\n    }\n\n    player.set(\"gameID\", this.id);\n    if (treatment) {\n      player.set(\"treatment\", treatment);\n    }\n\n    if (\n      previousGameTreatment &&\n      JSON.stringify(previousGameTreatment) !== JSON.stringify(treatment)\n    ) {\n      if (previousGameID) {\n        warn(\n          `reassigning player from ${previousGameID} to ${this.id} with different treatments`\n        );\n      } else {\n        warn(`reassigning player to ${this.id} with different treatment`);\n      }\n    }\n\n    // Remove player from previous Game.\n    // We do this after setting the new gameID on the player so we don't\n    // conflict with the other game concurrently starting. If the game is just\n    // starting and we change the gameID too late, we might allow that previous\n    // Game to start with this player.\n    if (previousGameID) {\n      await this.scopeByID<Game>(<string>previousGameID)?.removePlayer(player);\n    }\n\n    // Add player to running game.\n    await this.addPlayer(player);\n  }\n\n  // Add player to running game\n  private async addPlayer(player: Player) {\n    if (!this.isRunning) {\n      await this.addLinks([\n        {\n          link: true,\n          participantIDs: [player.participantID!],\n          nodeIDs: [this.id],\n        },\n      ]);\n\n      return;\n    }\n\n    const otherParticipantIDs = [];\n    const groupID = isString(this.get(\"groupID\"));\n    const newPlayerNodeIDs = [this.id, groupID];\n    const otherNodeIDs = [];\n\n    const stage = this.currentStage;\n    if (!stage) {\n      return;\n    }\n\n    const timerID = stage.get(\"timerID\") as string;\n    if (timerID) {\n      newPlayerNodeIDs.push(timerID);\n    }\n\n    newPlayerNodeIDs.push(stage.id);\n\n    const round = stage.round;\n    if (!round) {\n      return;\n    }\n\n    newPlayerNodeIDs.push(round.id);\n    const playerGameID = await this.createPlayerGame(player);\n    const playerRoundID = await round.createPlayerRound(player);\n    const playerStageID = await stage.createPlayerStage(player);\n\n    if (!playerGameID || !playerRoundID || !playerStageID) {\n      return;\n    }\n\n    newPlayerNodeIDs.push(player.id);\n    newPlayerNodeIDs.push(playerGameID!);\n    newPlayerNodeIDs.push(playerRoundID!);\n    newPlayerNodeIDs.push(playerStageID!);\n    otherNodeIDs.push(player.id);\n    otherNodeIDs.push(playerGameID!);\n    otherNodeIDs.push(playerRoundID!);\n    otherNodeIDs.push(playerStageID!);\n\n    // We assume the player has already added the gameID.\n    for (const plyr of this.players) {\n      if (player !== plyr) {\n        newPlayerNodeIDs.push(plyr.id);\n        newPlayerNodeIDs.push(isString(plyr.get(`playerGameID-${this.id}`)));\n        newPlayerNodeIDs.push(isString(plyr.get(`playerRoundID-${round.id}`)));\n        newPlayerNodeIDs.push(isString(plyr.get(`playerStageID-${stage.id}`)));\n        otherParticipantIDs.push(plyr.participantID!);\n      }\n    }\n\n    await this.addLinks([\n      // Add links for new player with games and other players.\n      {\n        link: true,\n        participantIDs: [player.participantID!],\n        nodeIDs: newPlayerNodeIDs,\n      },\n      // Add links for other players with new player.\n      {\n        link: true,\n        participantIDs: otherParticipantIDs,\n        nodeIDs: otherNodeIDs,\n      },\n    ]);\n  }\n\n  // Remove player from running game\n  private async removePlayer(player: Player) {\n    if (!this.isRunning) {\n      await this.addLinks([\n        {\n          link: false,\n          participantIDs: [player.participantID!],\n          nodeIDs: [this.id],\n        },\n      ]);\n\n      return;\n    }\n\n    const participantIDs = [player.participantID!];\n    const otherParticipantIDs = [];\n    const groupID = isString(this.get(\"groupID\"));\n    const nodeIDs = [this.id, groupID, player.id];\n    const otherNodeIDs = [player.id];\n\n    const stage = this.currentStage;\n    if (!stage) {\n      return;\n    }\n\n    const timerID = stage.get(\"timerID\") as string;\n    if (timerID) {\n      nodeIDs.push(timerID);\n    }\n\n    nodeIDs.push(stage.id);\n\n    const round = stage.round;\n    if (!round) {\n      return;\n    }\n\n    // Gotta inject player since it might have lost its gameID.\n    const players = [...this.players, player];\n    for (const plyr of players) {\n      nodeIDs.push(isString(plyr.get(`playerRoundID-${round.id}`)));\n      nodeIDs.push(isString(plyr.get(`playerStageID-${stage.id}`)));\n      nodeIDs.push(isString(plyr.get(`playerGameID-${this.id}`)));\n\n      if (player.id !== plyr.id) {\n        nodeIDs.push(plyr.id);\n        otherParticipantIDs.push(plyr.participantID!);\n      } else {\n        otherNodeIDs.push(isString(plyr.get(`playerRoundID-${round.id}`)));\n        otherNodeIDs.push(isString(plyr.get(`playerStageID-${stage.id}`)));\n        otherNodeIDs.push(isString(plyr.get(`playerGameID-${this.id}`)));\n      }\n    }\n\n    await this.addLinks([\n      { link: false, participantIDs, nodeIDs },\n      {\n        link: false,\n        participantIDs: otherParticipantIDs,\n        nodeIDs: otherNodeIDs,\n      },\n    ]);\n  }\n\n  addRound(attributes: { [key: string]: JsonValue } | AttrInput[]) {\n    if (!Array.isArray(attributes)) {\n      const newAttr: AttrInput[] = [];\n      for (const key in attributes) {\n        newAttr.push({\n          key,\n          value: attributes[key]!,\n        });\n      }\n\n      attributes = newAttr;\n    }\n\n    const batchID = this.get(\"batchID\") as string;\n    if (!batchID) {\n      throw new Error(\"missing batch ID on game\");\n    }\n\n    const game = this;\n    const gameID = game.id;\n\n    let roundIndex = isOptionalNumber(this._tmpRoundIndex);\n    if (roundIndex === undefined) {\n      roundIndex = isOptionalNumber(game.get(\"roundIndex\"));\n    }\n    if (roundIndex === undefined) {\n      roundIndex = -1;\n    }\n\n    // New round index\n    roundIndex += 1;\n\n    this._tmpRoundIndex = roundIndex;\n    game.set(\"roundIndex\", this._tmpRoundIndex);\n\n    const [scope, accessors] = scopeConstructor({\n      kind: \"round\",\n      attributes: attrs([\n        ...attributes.filter((a) => !reservedKeys.includes(a.key)),\n        {\n          key: \"index\",\n          value: roundIndex,\n          immutable: true,\n        },\n        {\n          key: \"gameID\",\n          value: gameID,\n          immutable: true,\n        },\n        {\n          key: \"batchID\",\n          value: batchID,\n          immutable: true,\n        },\n        {\n          key: \"start\",\n          value: false,\n          protected: true,\n        },\n        {\n          key: \"ended\",\n          value: false,\n          protected: true,\n        },\n      ]),\n    });\n\n    const roundProm = this.addScopes([scope]);\n\n    const stageAdds: AddScopeInput[] = [];\n\n    const addStage = (\n      attributes: { [key: string]: JsonValue } | AttrInput[]\n    ) => {\n      if (!Array.isArray(attributes)) {\n        const newAttr: AttrInput[] = [];\n        for (const key in attributes) {\n          newAttr.push({\n            key,\n            value: attributes[key]!,\n          });\n        }\n\n        attributes = newAttr;\n      }\n\n      // Check duration is valid\n      const durAttr = attributes.find((a) => a.key === \"duration\");\n      const res = z.number().int().gte(1).safeParse(durAttr?.value);\n      if (!res.success) {\n        throw new Error(`stage duration invalid: ${res.error}`);\n      }\n\n      const [scope, accessors] = scopeConstructor({\n        kind: \"stage\",\n        attributes: attrs([\n          ...attributes.filter((a) => !reservedKeys.includes(a.key)),\n          {\n            key: \"gameID\",\n            value: gameID,\n            immutable: true,\n          },\n          {\n            key: \"batchID\",\n            value: batchID,\n            immutable: true,\n          },\n          {\n            key: \"start\",\n            value: false,\n            protected: true,\n          },\n          {\n            key: \"ended\",\n            value: false,\n            protected: true,\n          },\n        ]),\n      });\n\n      stageAdds.push(scope);\n\n      return accessors;\n    };\n\n    this.addFinalizer(async () => {\n      this._tmpRoundIndex = undefined;\n\n      let rounds: AddScopePayload[];\n      try {\n        rounds = await roundProm;\n      } catch (err) {\n        error(`failed to create round: ${err}`);\n\n        return;\n      }\n\n      if (rounds.length < 1) {\n        error(`failed to create round`);\n\n        return;\n      }\n\n      // Forced because tested for length > 0\n      const roundID = rounds[0]!.id;\n\n      const round = this.scopeByID<Round>(roundID);\n      if (!round) {\n        throw \"round not found in round finalizer\";\n      }\n\n      let stageIndex = isOptionalNumber(round.get(\"stageIndex\")) || 0;\n\n      for (const scope of stageAdds) {\n        const durAttr = scope.attributes!.find((a) => a.key === \"duration\");\n        if (!durAttr || !durAttr!.val) {\n          error(`stage duration not found`);\n\n          continue;\n        }\n\n        const res = z.number().int().gte(1).safeParse(JSON.parse(durAttr.val));\n        if (!res.success) {\n          throw new Error(`stage duration invalid: ${res.error}`);\n        }\n\n        const duration = res.data;\n\n        scope.attributes!.push({\n          key: \"roundID\",\n          val: JSON.stringify(roundID),\n          immutable: true,\n        });\n\n        let steps: StepPayload[];\n        try {\n          steps = await this.addSteps([{ duration }]);\n        } catch (err) {\n          error(`failed to create steps: ${err}`);\n\n          return;\n        }\n\n        if (steps.length < 1) {\n          error(`failed to create steps`);\n\n          return;\n        }\n\n        // Forced because tested for length > 0\n        const stepID = steps[0]!.id;\n\n        scope.attributes!.push({\n          key: \"timerID\",\n          val: JSON.stringify(stepID),\n          immutable: true,\n        });\n\n        scope.attributes!.push({\n          key: \"index\",\n          val: `${stageIndex}`,\n          immutable: true,\n        });\n\n        stageIndex++;\n      }\n\n      round.set(\"stageIndex\", stageIndex);\n\n      await this.addScopes(stageAdds);\n    });\n\n    return {\n      ...accessors,\n      addStage,\n    };\n  }\n\n  end(status: EndedStatuses, reason: string) {\n    if (this.hasEnded) {\n      return;\n    }\n\n    if (!endedStatuses.includes(status)) {\n      warn(`game: attempting to end game with wrong status`);\n\n      return;\n    }\n\n    this.set(\"status\", status);\n    this.set(\"endedReason\", reason);\n\n    const stage = this.currentStage;\n    if (!stage) {\n      return;\n    }\n\n    stage.end(\"ended\", reason);\n  }\n\n  async createPlayerGame(player: Player) {\n    const key = `playerGameID-${this.id}`;\n    if (player.get(key)) {\n      return isString(player.get(key));\n    }\n\n    const batchID = isString(this.get(\"batchID\"));\n\n    const playerGames = await this.addScopes([\n      {\n        kind: \"playerGame\",\n        attributes: attrs([\n          {\n            key: \"batchID\",\n            value: batchID,\n            immutable: true,\n          },\n          {\n            key: \"gameID\",\n            value: this.id,\n            immutable: true,\n          },\n          {\n            key: \"playerID\",\n            value: player.id,\n            immutable: true,\n          },\n        ]),\n      },\n    ]);\n\n    if (playerGames.length < 1) {\n      error(`failed to create playerGame`);\n\n      return;\n    }\n\n    player.set(key, playerGames[0]!.id);\n\n    return playerGames[0]!.id;\n  }\n}\n\nexport class GameOwned extends BatchOwned {\n  get currentGame() {\n    return this.scopeByKey<Game>(\"gameID\");\n  }\n}\n\nexport class Player extends GameOwned {\n  participantID?: string;\n\n  get game() {\n    const game = this.currentGame;\n    if (!game) {\n      return;\n    }\n\n    const key = `playerGameID-${game.id}`;\n\n    return this.scopeByKey<PlayerGame>(key);\n  }\n\n  get currentRound() {\n    return this.currentStage?.round;\n  }\n\n  get round() {\n    const round = this.currentRound;\n    if (!round) {\n      return;\n    }\n\n    const key = `playerRoundID-${round.id}`;\n\n    return this.scopeByKey<PlayerRound>(key);\n  }\n\n  get currentStage() {\n    return this.currentGame?.currentStage;\n  }\n\n  get stage() {\n    const stage = this.currentStage;\n    if (!stage) {\n      return;\n    }\n\n    const key = `playerStageID-${stage.id}`;\n\n    return this.scopeByKey<PlayerStage>(key);\n  }\n\n  exit(reason: string) {\n    if (this.get(\"ended\")) {\n      return;\n    }\n\n    this.set(\"ended\", reason);\n  }\n\n  hasUpdated(): boolean {\n    if (super.hasUpdated()) {\n      return true;\n    }\n\n    return Boolean(\n      this.round?.hasUpdated() ||\n        this.stage?.hasUpdated() ||\n        this.game?.hasUpdated()\n    );\n  }\n}\n\nexport class PlayerGame extends GameOwned {}\n\nexport class PlayerRound extends GameOwned {}\n\nexport class PlayerStage extends GameOwned {\n  get stage() {\n    return this.scopeByKey<Stage>(\"stageID\");\n  }\n\n  get player() {\n    return this.scopeByKey<Player>(\"playerID\");\n  }\n}\n\n// We don't want stages that are too short since we're getting close to the\n// limits of the precision of loose distributed time synchronization.\nconst minStageDuration = 5;\n\n// This is about 31 years. I think that's enough. The main reason for this is to\n// prevent https://github.com/empiricaly/empirica/issues/319 where someone had\n// set the duration to 9999999999, which is >317 years, which is beyond what the\n// Go server time.Duration can handle, and it was exploding.\nconst maxStageDuration = 1_000_000_000;\n\nexport class Round extends GameOwned {\n  get stages() {\n    const stages = this.scopesByKindMatching<Stage>(\n      \"stage\",\n      \"roundID\",\n      this.id\n    );\n    stages.sort(indexSortable);\n    return stages;\n  }\n\n  addStage(attributes: { [key: string]: JsonValue } | AttrInput[]) {\n    if (!Array.isArray(attributes)) {\n      const newAttr: AttrInput[] = [];\n      for (const key in attributes) {\n        newAttr.push({\n          key,\n          value: attributes[key]!,\n        });\n      }\n\n      attributes = newAttr;\n    }\n\n    const durAttr = attributes.find((a) => a.key === \"duration\");\n    const res = z\n      .number()\n      .int()\n      .gte(minStageDuration)\n      .lte(maxStageDuration)\n      .safeParse(durAttr?.value);\n    if (!res.success) {\n      throw new Error(`stage duration invalid: ${res.error}`);\n    }\n\n    const duration = res.data;\n\n    const batchID = this.get(\"batchID\") as string;\n    if (!batchID) {\n      throw new Error(\"missing batch ID on round\");\n    }\n\n    const gameID = this.get(\"gameID\") as string;\n    if (!gameID) {\n      throw new Error(\"missing game ID on round\");\n    }\n\n    const stageIndex = z.number().parse(this.get(\"stageIndex\") || -1) + 1;\n    this.set(\"stageIndex\", stageIndex);\n\n    const [scope, accessors] = scopeConstructor({\n      kind: \"stage\",\n      attributes: attrs([\n        ...attributes.filter((a) => !reservedKeys.includes(a.key)),\n        {\n          key: \"index\",\n          value: stageIndex,\n          immutable: true,\n        },\n        {\n          key: \"roundID\",\n          value: this.id,\n          immutable: true,\n        },\n        {\n          key: \"gameID\",\n          value: gameID,\n          immutable: true,\n        },\n        {\n          key: \"batchID\",\n          value: batchID,\n          immutable: true,\n        },\n        {\n          key: \"start\",\n          value: false,\n          protected: true,\n        },\n        {\n          key: \"ended\",\n          value: false,\n          protected: true,\n        },\n      ]),\n    });\n\n    this.addFinalizer(async () => {\n      let steps: StepPayload[];\n      try {\n        steps = await this.addSteps([{ duration }]);\n      } catch (err) {\n        error(`failed to create steps: ${err}`);\n\n        return;\n      }\n\n      if (steps.length < 1) {\n        error(`failed to create steps`);\n\n        return;\n      }\n\n      // Forced because tested for length > 0\n      const stepID = steps[0]!.id;\n\n      scope.attributes!.push({\n        key: \"timerID\",\n        val: JSON.stringify(stepID),\n        immutable: true,\n      });\n\n      this.addScopes([scope]);\n    });\n\n    return accessors;\n  }\n\n  async createPlayerRound(player: Player) {\n    const key = `playerRoundID-${this.id}`;\n    if (player.get(key)) {\n      return isString(player.get(key));\n    }\n\n    const gameID = isString(this.get(\"gameID\"));\n    const batchID = isString(this.get(\"batchID\"));\n\n    const playerRounds = await this.addScopes([\n      {\n        kind: \"playerRound\",\n        attributes: attrs([\n          {\n            key: \"batchID\",\n            value: batchID,\n            immutable: true,\n          },\n          {\n            key: \"gameID\",\n            value: gameID,\n            immutable: true,\n          },\n          {\n            key: \"roundID\",\n            value: this.id,\n            immutable: true,\n          },\n          {\n            key: \"playerID\",\n            value: player.id,\n            immutable: true,\n          },\n        ]),\n      },\n    ]);\n\n    if (playerRounds.length < 1) {\n      error(`failed to create playerRound`);\n\n      return;\n    }\n\n    player.set(key, playerRounds[0]!.id);\n\n    return playerRounds[0]!.id;\n  }\n}\n\nexport class Stage extends GameOwned {\n  get round() {\n    return this.scopeByKey<Round>(\"roundID\");\n  }\n\n  isCurrent() {\n    return this.currentGame?.get(\"stageID\") === this.id;\n  }\n\n  end(status: EndedStatuses, reason: string) {\n    if (this.get(\"ended\")) {\n      return;\n    }\n\n    this.set(\"status\", status);\n    this.set(\"endedReason\", reason);\n\n    this.addTransitions([\n      {\n        from: State.Running,\n        to: State.Ended,\n        nodeID: this.get(\"timerID\") as string,\n        cause: reason,\n      },\n    ]);\n  }\n\n  async createPlayerStage(player: Player) {\n    const key = `playerStageID-${this.id}`;\n    if (player.get(key)) {\n      return isString(player.get(key));\n    }\n\n    const roundID = isString(this.get(\"roundID\"));\n    const gameID = isString(this.get(\"gameID\"));\n    const batchID = isString(this.get(\"batchID\"));\n\n    const playerStages = await this.addScopes([\n      {\n        kind: \"playerStage\",\n        attributes: attrs([\n          {\n            key: \"batchID\",\n            value: batchID,\n            immutable: true,\n          },\n          {\n            key: \"gameID\",\n            value: gameID,\n            immutable: true,\n          },\n          {\n            key: \"roundID\",\n            value: roundID,\n            immutable: true,\n          },\n          {\n            key: \"stageID\",\n            value: this.id,\n            immutable: true,\n          },\n          {\n            key: \"playerID\",\n            value: player.id,\n            immutable: true,\n          },\n        ]),\n      },\n    ]);\n\n    if (playerStages.length < 1) {\n      error(`failed to create playerStage`);\n\n      return;\n    }\n\n    player.set(key, playerStages[0]!.id);\n\n    return playerStages[0]!.id;\n  }\n}\n\nexport class Context {}\n\nexport type ClassicKinds = {\n  batch: Constructor<Batch>;\n  game: Constructor<Game>;\n  player: Constructor<Player>;\n  playerGame: Constructor<PlayerGame>;\n  playerRound: Constructor<PlayerRound>;\n  playerStage: Constructor<PlayerStage>;\n  round: Constructor<Round>;\n  stage: Constructor<Stage>;\n};\n\nexport const classicKinds = {\n  batch: Batch,\n  game: Game,\n  player: Player,\n  playerGame: PlayerGame,\n  playerRound: PlayerRound,\n  playerStage: PlayerStage,\n  round: Round,\n  stage: Stage,\n};\n\nexport class EventProxy {\n  constructor(private ctx: EventContext<Context, ClassicKinds>) {}\n\n  // Returns all loaded Batches.\n  get batches() {\n    return Array.from(this.ctx.scopesByKind<Batch>(\"batch\").values());\n  }\n\n  // Returns all loaded Games accross Batches.\n  get games() {\n    return Array.from(this.ctx.scopesByKind<Game>(\"game\").values());\n  }\n\n  // Returns all loaded Players accross all Games.\n  get players() {\n    return Array.from(this.ctx.scopesByKind<Player>(\"player\").values());\n  }\n}\n\nexport function evt(ctx: EventContext<Context, ClassicKinds>) {\n  return new EventProxy(ctx);\n}\n","import { z } from \"zod\";\n// import { Game, Round, Stage } from \"./models\";\n\nexport const treatmentSchema = z.record(z.string().min(1), z.any());\nexport const batchConfigSchema = z.discriminatedUnion(\"kind\", [\n  z.object({\n    kind: z.literal(\"custom\"),\n    config: z.any(),\n  }),\n  z.object({\n    kind: z.literal(\"simple\"),\n    config: z.object({\n      count: z.number().int().positive(),\n      treatments: z\n        .object({\n          factors: treatmentSchema,\n        })\n        .array(),\n    }),\n  }),\n  z.object({\n    kind: z.literal(\"complete\"),\n    config: z.object({\n      treatments: z\n        .object({\n          count: z.number().int().positive(),\n          treatment: z.object({\n            factors: treatmentSchema,\n          }),\n        })\n        .array(),\n    }),\n  }),\n]);\n\n// // const isBatch = z.instanceof(Batch).parse;\n// export const isGame = z.instanceof(Game).parse;\n// export const isRound = z.instanceof(Round).parse;\n// export const isStage = z.instanceof(Stage).parse;\n// export const isString = z.string().parse;\n","import {\n  InputMaybe,\n  ScopedAttributesInput,\n  ScopesQueryVariables,\n  Tajriba,\n  TajribaAdmin,\n} from \"@empirica/tajriba\";\nimport { Constructor } from \"../../../shared/helpers\";\nimport { JsonValue } from \"../../../utils/json\";\n\nexport class Scope {\n  private _attributes = new Map<string, Attribute>();\n  constructor(protected conn: Conn, private edge: ScopeEdge) {\n    for (const edge of this.edge.attributes.edges) {\n      this._attributes.set(edge.node.key, new Attribute(edge.node));\n    }\n  }\n\n  get id() {\n    return this.edge.id;\n  }\n\n  get attributes() {\n    return Array.from(this._attributes.values()).filter(\n      (a) =>\n        !a.key.startsWith(\"ran-\") &&\n        !a.key.startsWith(\"playerGameID\") &&\n        !a.key.startsWith(\"playerRoundID\") &&\n        !a.key.startsWith(\"playerStageID\")\n    );\n  }\n\n  allAttributes() {\n    return this._attributes;\n  }\n}\n\nexport class Attribute {\n  private _value?: JsonValue;\n  constructor(private edge: AttributeEdge) {\n    if (edge.val) {\n      this._value = JSON.parse(edge.val);\n    }\n  }\n\n  get id() {\n    return this.edge.id;\n  }\n\n  get key() {\n    return this.edge.key;\n  }\n\n  get value() {\n    return this._value;\n  }\n}\n\nexport class Player extends Scope {}\nexport class Batch extends Scope {}\nexport class Game extends Scope {}\nexport class PlayerGame extends Scope {}\nexport class Round extends Scope {}\nexport class PlayerRound extends Scope {}\nexport class Stage extends Scope {}\nexport class PlayerStage extends Scope {}\n\nexport class Conn {\n  constructor(private tajriba: TajribaAdmin) {}\n\n  stop() {\n    this.tajriba.stop();\n  }\n\n  players() {\n    return this.scopesByKind<Player>(\"player\", Player);\n  }\n\n  batches() {\n    return this.scopesByKind<Batch>(\"batch\", Batch);\n  }\n\n  games() {\n    return this.scopesByKind<Game>(\"game\", Game);\n  }\n\n  rounds() {\n    return this.scopesByKind<Round>(\"round\", Round);\n  }\n\n  stages() {\n    return this.scopesByKind<Stage>(\"stage\", Stage);\n  }\n\n  playerGames() {\n    return this.scopesByKind<PlayerGame>(\"playerGame\", PlayerGame);\n  }\n\n  playerRounds() {\n    return this.scopesByKind<PlayerRound>(\"playerRound\", PlayerRound);\n  }\n\n  playerStages() {\n    return this.scopesByKind<PlayerStage>(\"playerStage\", PlayerStage);\n  }\n\n  private scopesByKind<T extends Scope>(\n    kind: string,\n    cnstrctr: Constructor<T>\n  ) {\n    return this.filteredScopes({ kinds: [kind] }, cnstrctr);\n  }\n\n  private async *filteredScopes<T extends Scope>(\n    filter: InputMaybe<Array<ScopedAttributesInput> | ScopedAttributesInput>,\n    cnstrctr: Constructor<T>\n  ) {\n    const args: ScopesQueryVariables = {\n      first: 100,\n      filter,\n    };\n\n    while (true) {\n      const scopes = await this.tajriba.scopes(args);\n      for (const edge of scopes?.edges ?? []) {\n        yield new cnstrctr(this, edge.node);\n      }\n\n      if (!scopes?.pageInfo.hasNextPage) {\n        break;\n      } else {\n        args.after = scopes.pageInfo.endCursor;\n      }\n    }\n  }\n}\n\nexport async function connect(\n  tajURL: string,\n  token: string | null,\n  srtoken: string,\n  clientName: string = \"api\"\n): Promise<Conn> {\n  const tajriba = await Tajriba.createAndAwait(tajURL);\n\n  if (!token) {\n    token = await tajriba.registerService(clientName, srtoken);\n  }\n\n  return new Conn(await tajriba.sessionAdmin(token));\n}\n\ninterface AttributeEdge {\n  __typename: \"Attribute\";\n  id: string;\n  createdAt: any;\n  private: boolean;\n  protected: boolean;\n  immutable: boolean;\n  deletedAt?: any;\n  key: string;\n  val?: string | null | undefined;\n  index?: number | null | undefined;\n  current: boolean;\n  version: number;\n  vector: boolean;\n  createdBy:\n    | {\n        __typename: \"Participant\";\n        id: string;\n        identifier: string;\n        createdAt: any;\n      }\n    | {\n        __typename: \"Service\";\n        id: string;\n        name: string;\n        createdAt: any;\n      }\n    | {\n        __typename: \"User\";\n        id: string;\n        username: string;\n        name: string;\n        createdAt: any;\n      };\n  node:\n    | {\n        __typename: \"Attribute\";\n        id: string;\n      }\n    | {\n        __typename: \"Group\";\n        id: string;\n      }\n    | {\n        __typename: \"Link\";\n        id: string;\n      }\n    | {\n        __typename: \"Participant\";\n        id: string;\n      }\n    | {\n        __typename: \"Scope\";\n        kind?: string | null | undefined;\n        name?: string | null | undefined;\n        id: string;\n      }\n    | {\n        __typename: \"Step\";\n        id: string;\n      }\n    | {\n        __typename: \"Transition\";\n        id: string;\n      }\n    | {\n        __typename: \"User\";\n        id: string;\n      };\n}\n\ninterface ScopeEdge {\n  id: string;\n  name?: string | null | undefined;\n  kind?: string | null | undefined;\n  createdBy:\n    | {\n        __typename: \"Participant\";\n        id: string;\n        identifier: string;\n        createdAt: any;\n      }\n    | {\n        __typename: \"Service\";\n        id: string;\n        name: string;\n        createdAt: any;\n      }\n    | {\n        __typename: \"User\";\n        id: string;\n        username: string;\n        name: string;\n        createdAt: any;\n      };\n  attributes: {\n    __typename: \"AttributeConnection\";\n    totalCount: number;\n    pageInfo: {\n      __typename: \"PageInfo\";\n      hasNextPage: boolean;\n      hasPreviousPage: boolean;\n      startCursor?: any;\n      endCursor?: any;\n    };\n    edges: {\n      __typename: \"AttributeEdge\";\n      cursor: any;\n      node: AttributeEdge;\n    }[];\n  };\n}\n","import archiver, { Archiver } from \"archiver\";\nimport fs from \"fs\";\nimport streams from \"stream-buffers\";\nimport { promiseHandle } from \"../../promises\";\nimport { Conn, Scope } from \"../api/api\";\n\nexport const BOM = \"\\uFEFF\";\n\nexport async function exportCSV(conn: Conn, output: string) {\n  const archive = archiver(\"zip\");\n  const stream = fs.createWriteStream(output);\n\n  const prom = promiseHandle();\n  stream.on(\"close\", function () {\n    console.log(\"Finalizing archive (\" + archive.pointer() + \" bytes)\");\n    prom.result();\n  });\n\n  archive.on(\"warning\", function (err) {\n    console.warn(err);\n  });\n\n  archive.on(\"error\", function (err) {\n    console.error(err);\n    throw err;\n  });\n\n  // pipe archive data to the file\n  archive.pipe(stream);\n\n  // file.put(encodeCells(keys.concat(dataKeys.map((k) => `data.${k}`))));\n\n  const a = archive;\n  await processType(a, \"batches\", conn.batches.bind(conn));\n  await processType(a, \"games\", conn.games.bind(conn));\n  await processType(a, \"playerGames\", conn.playerGames.bind(conn));\n  await processType(a, \"rounds\", conn.rounds.bind(conn));\n  await processType(a, \"playerRounds\", conn.playerRounds.bind(conn));\n  await processType(a, \"stages\", conn.stages.bind(conn));\n  await processType(a, \"playerStages\", conn.playerStages.bind(conn));\n  await processType(a, \"players\", conn.players.bind(conn));\n\n  archive.finalize();\n\n  await prom.promise;\n}\n\nasync function processType<T extends Scope>(\n  archive: Archiver,\n  fileName: string,\n  it: () => AsyncGenerator<T, void, unknown>\n) {\n  console.log(\"processing\", fileName);\n  const file = newFile(archive, fileName, \"csv\");\n\n  const keys = new Set<string>();\n  for await (const record of it()) {\n    for (const attr of record.attributes) {\n      keys.add(attr.key);\n    }\n  }\n\n  const keyArr = Array.from(keys.values());\n  file.put(encodeCells(keyArr));\n\n  for await (const record of it()) {\n    const attrs = record.attributes;\n\n    const line: (string | undefined)[] = [];\n    LOOP: for (const key of keyArr) {\n      for (const attr of attrs) {\n        if (attr.key === key) {\n          line.push(cast(attr.value));\n\n          continue LOOP;\n        }\n      }\n\n      line.push(undefined);\n    }\n\n    file.put(encodeCells(line));\n  }\n\n  file.stop();\n}\n\nfunction newFile(archive: Archiver, name: string, extension: string) {\n  const file = new streams.ReadableStreamBuffer();\n  archive.append(file, { name: `${name}.${extension}` });\n  file.put(BOM);\n  return file;\n}\n\nexport const quoteMark = '\"';\nexport const doubleQuoteMark = '\"\"';\nexport const quoteRegex = /\"/g;\n\nexport const encodeCells = (line: any[]) => {\n  const row = line.slice(0);\n\n  for (var i = 0, len = row.length; i < len; i++) {\n    if (row[i] === undefined) {\n      row[i] = \"\";\n      continue;\n    }\n\n    row[i] = JSON.stringify(row[i]); // was cast(row[i]);\n\n    if (row[i].indexOf(quoteMark) !== -1) {\n      row[i] = row[i].replace(quoteRegex, doubleQuoteMark);\n    }\n\n    if (row[i].indexOf(\",\") !== -1 || row[i].indexOf(\"\\\\n\") !== -1) {\n      row[i] = quoteMark + row[i] + quoteMark;\n    }\n  }\n\n  return row.join(\",\") + \"\\n\";\n};\n\nconst cast = (out: any): string => {\n  if (Array.isArray(out)) {\n    // The cast here will flatten arrays but will still catch dates correctly\n    return out.map((a) => cast(a)).join(\",\");\n  } else if (out instanceof Date) {\n    return out.toISOString();\n  } else if (typeof out === \"object\" && out !== null) {\n    return JSON.stringify(out);\n  } else if (typeof out === \"string\") {\n    return out.replace(/\\n/g, \"\\\\n\");\n  } else if (out === false || out === 0) {\n    return out.toString();\n  } else {\n    return (out || \"\").toString();\n  }\n};\n","import { Conn, connect } from \"../api/api\";\nimport { exportCSV } from \"./export_csv\";\n\nasync function exportJSON(_: Conn, __: string) {\n  throw new Error(\"JSON export not implemented\");\n}\n\nexport enum ExportFormat {\n  CSV = \"csv\",\n  JSON = \"json\",\n}\n\nexport async function runExport(\n  url: string,\n  token: string | null,\n  srtoken: string,\n  format: ExportFormat,\n  output: string\n) {\n  const taj = await connect(url, token, srtoken);\n\n  switch (format) {\n    case ExportFormat.CSV:\n      await exportCSV(taj, output);\n      break;\n    case ExportFormat.JSON:\n      await exportJSON(taj, output);\n      break;\n    default:\n      throw new Error(`Unknown format ${format}`);\n  }\n\n  taj.stop();\n\n  console.log(\"finished\");\n}\n","import { z } from \"zod\";\nimport { ListenersCollector } from \"../events\";\nimport { ClassicKinds, Context } from \"./models\";\n\nconst string = z.string();\n\n/** ClassicLoader loads. */\nexport function ClassicLoader(\n  /** This is the listener */\n  _: ListenersCollector<Context, ClassicKinds>\n) {\n  _.on(\"start\", function (ctx) {\n    ctx.participantsSub();\n    ctx.scopeSub({ kinds: [\"batch\", \"player\"] });\n  });\n\n  _.on(\"batch\", \"status\", function (ctx, { batch, status }) {\n    if ([\"running\", \"created\"].includes(status)) {\n      ctx.scopeSub({\n        kvs: [{ key: \"batchID\", val: JSON.stringify(batch.id) }],\n      });\n    }\n  });\n\n  _.on(\"stage\", \"timerID\", function (ctx, { timerID }) {\n    ctx.transitionsSub(string.parse(timerID));\n  });\n}\n","import { AddStepInput, State, Step, Transition } from \"@empirica/tajriba\";\nimport { z } from \"zod\";\nimport { debug, error, trace } from \"../../utils/console\";\nimport { StepPayload } from \"../context\";\nimport { EventContext, ListenersCollector, TajribaEvent } from \"../events\";\nimport { ClassicKinds, Context, Game, Player } from \"./models\";\n\nconst nanosecond = 1;\nconst microsecond = 1000 * nanosecond;\nconst millisecond = 1000 * microsecond;\nconst second = 1000 * millisecond;\n\nconst lobbyTimerKey = \"lobbyTimerID\";\nconst individualTimerGameKey = \"lobbyTimerGameID\";\n// const individualTimerExtensionsKey = \"lobbyTimerExtensionsForGameID\";\n\nexport type LobbyConfig = {};\n\nexport function Lobby(_: LobbyConfig = {}) {\n  return function (_: ListenersCollector<Context, ClassicKinds>) {\n    _.on(\"player\", \"introDone\", async (ctx, { player }: { player: Player }) => {\n      const game = player.currentGame;\n      if (!game) {\n        return;\n      }\n\n      switch (game.lobbyConfig.kind) {\n        case \"shared\":\n          await setupSharedLobbyTimeout(ctx, game);\n\n          break;\n        case \"individual\":\n          await setupIndividualLobbyTimeout(ctx, game, player);\n\n          break;\n      }\n    });\n\n    const string = z.string();\n\n    _.on(\"game\", lobbyTimerKey, function (ctx, params) {\n      ctx.transitionsSub(string.parse(params[lobbyTimerKey]));\n    });\n\n    _.on(\"player\", lobbyTimerKey, function (ctx, params) {\n      ctx.transitionsSub(string.parse(params[lobbyTimerKey]));\n    });\n\n    type TransitionAdd = { step: Step; transition: Transition };\n    _.on(\n      TajribaEvent.TransitionAdd,\n      (ctx, { step, transition: { from, to } }: TransitionAdd) => {\n        debug(\"lobby: lobby transition check\");\n        if (from !== State.Running || to !== State.Ended) {\n          return;\n        }\n\n        expiredSharedLobbyTimeout(ctx, step);\n        expiredIndividualLobbyTimeout(ctx, step);\n      }\n    );\n  };\n}\n\n//\n// Individual lobby timer\n//\n\nasync function setupIndividualLobbyTimeout(\n  ctx: EventContext<Context, ClassicKinds>,\n  game: Game,\n  player: Player\n) {\n  // We check both whether there is a timer and if it was set for the current\n  // game. If the player switches games, the old timer should be ignored.\n  if (\n    player.get(lobbyTimerKey) &&\n    player.get(individualTimerGameKey) === game.id\n  ) {\n    trace(\"lobby: individual timer already set\", game.lobbyConfig);\n\n    return;\n  }\n\n  const stepID = await getTimer(ctx, game.lobbyConfig.duration);\n  if (!stepID) {\n    error(\"lobby: timer not created\");\n\n    return;\n  }\n\n  player.set(lobbyTimerKey, stepID);\n  player.set(individualTimerGameKey, game.id);\n\n  ctx.addTransitions([\n    {\n      from: State.Created,\n      to: State.Running,\n      nodeID: stepID,\n      cause: \"lobby timer start\",\n    },\n  ]);\n}\n\nasync function expiredIndividualLobbyTimeout(\n  ctx: EventContext<Context, ClassicKinds>,\n  step: Step\n) {\n  const players = ctx.scopesByKindMatching<Player>(\n    \"player\",\n    lobbyTimerKey,\n    step.id\n  );\n\n  if (!players.length) {\n    return;\n  }\n\n  const player = players[0]!;\n  const game = player.currentGame;\n\n  if (\n    !game ||\n    game.hasStarted ||\n    player.get(individualTimerGameKey) !== game.id\n  ) {\n    return;\n  }\n\n  // For now, no extensions, so always exit after player timeout.\n  player.exit(\"lobby timed out\");\n\n  // if (!game.lobbyConfig.extensions || game.lobbyConfig.extensions === 0) {\n  //   player.exit(\"lobby timed out\");\n\n  //   return;\n  // }\n\n  // const extensionsKey = `${individualTimerExtensionsKey}-${game.id}`;\n  // const extensions = (player.get(extensionsKey) as number) || 0;\n\n  // if (extensions >= game.lobbyConfig.extensions) {\n  //   player.set(\"ended\", \"individual lobby timeout\");\n\n  //   return;\n  // }\n\n  // // Clear previous timeout\n  // player.set(lobbyTimerKey, null);\n\n  // player.set(extensionsKey, extensions + 1);\n\n  // setupIndividualLobbyTimeout(ctx, game, player);\n}\n\n//\n// Shared lobby timer\n//\n\nasync function setupSharedLobbyTimeout(\n  ctx: EventContext<Context, ClassicKinds>,\n  game: Game\n) {\n  if (game.get(lobbyTimerKey)) {\n    trace(\"lobby: lobby already exists\", game.lobbyConfig);\n\n    return;\n  }\n\n  const stepID = await getTimer(ctx, game.lobbyConfig.duration);\n  if (!stepID) {\n    error(\"lobby: timer not created\");\n\n    return;\n  }\n\n  debug(\"lobby: lobby created\", stepID);\n  game.set(lobbyTimerKey, stepID);\n\n  try {\n    await ctx.addTransitions([\n      {\n        from: State.Created,\n        to: State.Running,\n        nodeID: stepID,\n        cause: \"lobby timer start\",\n      },\n    ]);\n  } catch (e) {\n    debug(\"lobby: failed to start lobby timeout\", e);\n  }\n}\n\nasync function expiredSharedLobbyTimeout(\n  ctx: EventContext<Context, ClassicKinds>,\n  step: Step\n) {\n  const games = ctx.scopesByKindMatching<Game>(\"game\", lobbyTimerKey, step.id);\n\n  if (!games.length) {\n    debug(\"lobby: game for lobby not found\");\n\n    return;\n  }\n\n  const game = games[0]!;\n  debug(\"lobby: lobby for game\", game.id);\n\n  if (game.hasStarted) {\n    debug(\"lobby: game for lobby started\");\n\n    return;\n  }\n\n  const readyPlayers = game.players.filter((p) => p.get(\"introDone\"));\n  if (readyPlayers.length === 0) {\n    game.set(lobbyTimerKey, null);\n\n    return;\n  }\n\n  switch (game.lobbyConfig.strategy) {\n    case \"fail\":\n      debug(\"lobby: failing game\");\n      game.end(\"failed\", \"shared lobby timeout\");\n\n      break;\n    case \"ignore\":\n      debug(\"lobby: starting game\");\n\n      for (const player of game.players) {\n        if (!player.get(\"introDone\")) {\n          player.exit(\"lobby timed out before reached intro\");\n        }\n      }\n\n      game.start();\n\n      break;\n  }\n}\n\ninterface stepper {\n  addSteps: (input: AddStepInput[]) => Promise<StepPayload[]>;\n}\n\nasync function getTimer(ctx: stepper, duration: number) {\n  try {\n    const dur = duration / second;\n    debug(\"lobby: creating lobby timeout for\", dur, \"seconds\");\n    const steps = await ctx.addSteps([{ duration: dur }]);\n    return steps[0]?.id;\n  } catch (err) {\n    return;\n  }\n}\n","import { EventContext, ListenersCollector } from \"../events\";\nimport { ClassicKinds, Context, Game, Round, Stage } from \"./models\";\n\n/** Collects event listeners. */\nexport class ClassicListenersCollector extends ListenersCollector<\n  Context,\n  ClassicKinds\n> {\n  /**\n   * onGameStart is triggered just before the game start. It is a great place to\n   * create rounds and stages and initialize values on the game, the players,\n   * the rounds, and the stages.\n   *\n   * Players are accessible on the game, `game.players`.\n   * You can add Rounds to a Game with `game.addRound({ some: \"attribute\" })`.\n   * `game.AddRound` returns a Round object. On the Round object, you can create\n   * Stages: `round.addStage({ some: \"value\" })`.\n   *\n   * @example\n   * ```js\n   * const round = game.addRound({\n   *   name: \"Round 1 - Jelly Beans\",\n   *   task: \"jellybeans\",\n   * });\n   * round.addStage({ name: \"Answer\", duration: 300 });\n   * round.addStage({ name: \"Result\", duration: 120 });\n   *\n   * game.players.forEach((player) => player.set(\"score\", 0));\n   * ```\n   * */\n  onGameStart(cb: (props: { game: Game }) => void) {\n    this.unique.on(\n      \"game\",\n      \"start\",\n      (\n        _: EventContext<Context, ClassicKinds>,\n        { game, start }: { game: Game; start: boolean }\n      ) => {\n        if (!start) return;\n        cb({ game });\n      }\n    );\n  }\n\n  onRoundStart(cb: (props: { round: Round }) => void) {\n    this.unique.on(\n      \"round\",\n      \"start\",\n      (\n        _: EventContext<Context, ClassicKinds>,\n        { round, start }: { round: Round; start: boolean }\n      ) => {\n        if (!start) return;\n        cb({ round });\n      }\n    );\n  }\n\n  onStageStart(cb: (props: { stage: Stage }) => void) {\n    this.unique.on(\n      \"stage\",\n      \"start\",\n      (\n        _: EventContext<Context, ClassicKinds>,\n        { stage, start }: { stage: Stage; start: boolean }\n      ) => {\n        if (!start) return;\n        cb({ stage });\n      }\n    );\n  }\n\n  onStageEnded(cb: (props: { stage: Stage }) => void) {\n    this.unique.on(\n      \"stage\",\n      \"ended\",\n      (\n        _: EventContext<Context, ClassicKinds>,\n        { stage, ended }: { stage: Stage; ended: boolean }\n      ) => {\n        if (!ended) return;\n        cb({ stage });\n      }\n    );\n  }\n\n  onRoundEnded(cb: (props: { round: Round }) => void) {\n    this.unique.on(\n      \"round\",\n      \"ended\",\n      (\n        _: EventContext<Context, ClassicKinds>,\n        { round, ended }: { round: Round; ended: boolean }\n      ) => {\n        if (!ended) return;\n        cb({ round });\n      }\n    );\n  }\n\n  onGameEnded(cb: (props: { game: Game }) => void) {\n    this.unique.on(\n      \"game\",\n      \"ended\",\n      (\n        _: EventContext<Context, ClassicKinds>,\n        { game, ended }: { game: Game; ended: boolean }\n      ) => {\n        if (!ended) return;\n        cb({ game });\n      }\n    );\n  }\n}\n"],"mappings":"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","names":["fs","err","base","fs","z","minimatch","Minimatch","filter","makeRe","braceExpand","debug","set","fs","m","path","error","cb","error","er","stat","fs","p","er","fs","err","error","tmp","config","error","State","z","attrs","attributes","scope","accessors","z","z","isString","game","_","config","State","stage","Scope","edge","Player","Batch","Game","PlayerGame","Round","PlayerRound","Stage","PlayerStage","fs","fs","attrs","ExportFormat","z","State","z","_","string","z","State"]}