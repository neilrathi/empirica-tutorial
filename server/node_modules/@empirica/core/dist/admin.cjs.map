{"version":3,"sources":["../src/admin/index.ts","../src/shared/globals.ts","../src/shared/tajriba_connection.ts","../src/utils/object.ts","../src/admin/attributes.ts","../src/shared/attributes.ts","../src/utils/console.ts","../src/admin/connection.ts","../src/admin/observables.ts","../src/admin/context.ts","../src/admin/runloop.ts","../src/admin/events.ts","../src/admin/promises.ts","../src/admin/cake.ts","../src/admin/globals.ts","../src/admin/participants.ts","../src/admin/scopes.ts","../src/shared/scopes.ts","../src/admin/subscriptions.ts","../src/admin/transitions.ts","../src/admin/token_file.ts"],"sourcesContent":["export type {\n  AttributeChange,\n  AttributeOptions,\n  AttributeUpdate,\n  Attribute as SharedAttribute,\n  Attributes as SharedAttributes,\n} from \"../shared/attributes\";\nexport { Globals as SharedGlobals } from \"../shared/globals\";\nexport type { Constructor } from \"../shared/helpers\";\nexport type {\n  Attributable,\n  AttributeInput,\n  ScopeConstructor,\n  ScopeIdent,\n  ScopeUpdate,\n  Scope as SharedScope,\n} from \"../shared/scopes\";\nexport { TajribaConnection } from \"../shared/tajriba_connection\";\nexport type { Json, JsonArray, JsonValue } from \"../utils/json\";\nexport { AttributeMsg, Attributes } from \"./attributes\";\nexport { AdminConnection } from \"./connection\";\nexport { AdminContext, TajribaAdminAccess } from \"./context\";\nexport type {\n  AddLinkPayload,\n  AddScopePayload,\n  AddTransitionPayload,\n  Finalizer,\n  StepPayload,\n} from \"./context\";\nexport {\n  EventContext,\n  EvtCtxCallback,\n  ListenersCollector,\n  ListenersCollectorProxy,\n  TajribaEvent,\n} from \"./events\";\nexport type { Subscriber } from \"./events\";\nexport { Globals } from \"./globals\";\nexport { participantsSub } from \"./participants\";\nexport type { Connection, ConnectionMsg, Participant } from \"./participants\";\nexport { Scope, Scopes } from \"./scopes\";\nexport type { KV, ScopeSubscriptionInput, Subs } from \"./subscriptions\";\nexport type { Step } from \"./transitions\";\n","import { SubAttributesPayload } from \"@empirica/tajriba\";\nimport { BehaviorSubject, Observable } from \"rxjs\";\nimport { JsonValue } from \"../utils/json\";\n\nexport class Globals {\n  protected attrs = new Map<string, BehaviorSubject<JsonValue | undefined>>();\n  private updates = new Map<string, JsonValue | undefined>();\n  public self: BehaviorSubject<Globals | undefined>;\n\n  constructor(globals: Observable<SubAttributesPayload>) {\n    this.self = new BehaviorSubject<Globals | undefined>(undefined);\n\n    globals.subscribe({\n      next: ({ attribute, done }) => {\n        if (attribute) {\n          let val = undefined;\n          if (attribute.val) {\n            val = JSON.parse(attribute.val);\n          }\n\n          this.updates.set(attribute.key, val);\n        }\n\n        if (done) {\n          for (const [key, val] of this.updates) {\n            this.obs(key).next(val);\n          }\n\n          this.updates.clear();\n\n          if (this.self) {\n            this.self.next(this);\n          }\n        }\n      },\n    });\n  }\n\n  get(key: string): JsonValue | undefined {\n    const o = this.attrs.get(key);\n    if (o) {\n      return o.getValue();\n    }\n\n    return undefined;\n  }\n\n  obs(key: string) {\n    let o = this.attrs.get(key);\n    if (!o) {\n      o = new BehaviorSubject<JsonValue | undefined>(undefined);\n      this.attrs.set(key, o);\n    }\n\n    return o;\n  }\n}\n","import { ParticipantIdent, Tajriba } from \"@empirica/tajriba\";\nimport { bs } from \"../utils/object\";\n\nexport const ErrNotConnected = new Error(\"not connected\");\n\nexport class TajribaConnection {\n  readonly tajriba: Tajriba;\n  private _connected = bs(false);\n  private _connecting = bs(true);\n  private _stopped = bs(false);\n\n  constructor(private url: string) {\n    this.tajriba = Tajriba.connect(this.url);\n    this._connected.next(this.tajriba.connected);\n\n    this.tajriba.on(\"connected\", () => {\n      this._connected.next(true);\n      this._connecting.next(false);\n    });\n\n    this.tajriba.on(\"disconnected\", () => {\n      this._connected.next(false);\n      this._connecting.next(true);\n    });\n  }\n\n  get connecting() {\n    return this._connecting;\n  }\n\n  get connected() {\n    return this._connected;\n  }\n\n  get stopped() {\n    return this._stopped;\n  }\n\n  async sessionParticipant(token: string, pident: ParticipantIdent) {\n    if (!this._connected.getValue()) {\n      throw ErrNotConnected;\n    }\n\n    return await this.tajriba.sessionParticipant(token, pident);\n  }\n\n  async sessionAdmin(token: string) {\n    if (!this._connected.getValue()) {\n      throw ErrNotConnected;\n    }\n\n    return await this.tajriba.sessionAdmin(token);\n  }\n\n  stop() {\n    if (this._stopped.getValue()) {\n      return;\n    }\n\n    if (this.tajriba) {\n      this.tajriba.removeAllListeners(\"connected\");\n      this.tajriba.removeAllListeners(\"disconnected\");\n      this.tajriba.stop();\n    }\n\n    this._connecting.next(false);\n    this._connected.next(false);\n    this._stopped.next(true);\n  }\n}\n","/* c8 ignore start */\n\nimport { BehaviorSubject } from \"rxjs\";\n\nexport function bs<T>(init: T) {\n  return new BehaviorSubject<T>(init);\n}\n\nexport function bsu<T>(init: T | undefined = undefined) {\n  return new BehaviorSubject<T | undefined>(init);\n}\n\nexport function deepEqual(obj1: any, obj2: any) {\n  if (obj1 === obj2)\n    // it's just the same object. No need to compare.\n    return true;\n\n  if (isPrimitive(obj1) && isPrimitive(obj2))\n    // compare primitives\n    return obj1 === obj2;\n\n  if (Object.keys(obj1).length !== Object.keys(obj2).length) return false;\n\n  // compare objects with same number of keys\n  for (let key in obj1) {\n    if (!(key in obj2)) return false; //other object doesn't have this prop\n    if (!deepEqual(obj1[key], obj2[key])) return false;\n  }\n\n  return true;\n}\n\n//check if value is primitive\nfunction isPrimitive(obj: any) {\n  return obj !== Object(obj);\n}\n","import { Observable, ReplaySubject } from \"rxjs\";\nimport {\n  Attribute,\n  AttributeChange,\n  Attributes as SharedAttributes,\n} from \"../shared/attributes\";\nimport { warn } from \"../utils/console\";\n\nexport type AttributeMsg = {\n  attribute?: Attribute;\n  done: boolean;\n};\n\nexport class Attributes extends SharedAttributes {\n  protected attrsByKind = new Map<\n    string,\n    Map<string, Map<string, Attribute>>\n  >();\n  private attribSubs = new Map<\n    string,\n    Map<string, ReplaySubject<AttributeMsg>>\n  >();\n\n  subscribeAttribute(kind: string, key: string): Observable<AttributeMsg> {\n    if (!this.attribSubs.has(kind)) {\n      this.attribSubs.set(kind, new Map<string, ReplaySubject<AttributeMsg>>());\n    }\n\n    const keyMap = this.attribSubs.get(kind)!;\n    let sub = keyMap.get(key);\n    if (!sub) {\n      sub = new ReplaySubject<AttributeMsg>();\n      keyMap.set(key, sub);\n\n      const attrByScopeID = this.attrsByKind.get(kind);\n\n      setTimeout(() => {\n        if (!attrByScopeID) {\n          sub!.next({ done: true });\n          return;\n        }\n\n        let attrs = [];\n        for (const [_, attrByKey] of attrByScopeID?.entries()) {\n          for (const [_, attr] of attrByKey) {\n            if (attr.key === key) {\n              attrs.push(attr);\n            }\n          }\n        }\n\n        if (attrs.length > 0) {\n          let count = 0;\n          for (const attr of attrs) {\n            count++;\n            sub!.next({ attribute: attr, done: count == attrs.length });\n          }\n        } else {\n          sub!.next({ done: true });\n        }\n      }, 0);\n    }\n\n    return sub!;\n  }\n\n  protected next(scopeIDs: string[]) {\n    const byKind = new Map<string, AttributeChange[]>();\n\n    for (const [scopeID, attrs] of this.updates) {\n      if (!scopeIDs.includes(scopeID)) {\n        continue;\n      }\n\n      for (const [_, attr] of attrs) {\n        if (typeof attr === \"boolean\") {\n          continue;\n        }\n\n        const kind = attr.node?.kind;\n        if (kind) {\n          let kindAttrs = byKind.get(kind);\n          if (!kindAttrs) {\n            kindAttrs = [];\n            byKind.set(kind, kindAttrs);\n          }\n\n          kindAttrs.push(attr);\n        }\n      }\n    }\n\n    const updates: [string, string, AttributeChange][] = [];\n    for (const [kind, attrs] of byKind) {\n      for (const attr of attrs) {\n        // This is very difficult to reproduce in tests since this.updates\n        // cannot contain an AttributeChange that would satisfy this.\n        /* c8 ignore next 4 */\n        if (!attr.nodeID && !attr.node?.id) {\n          warn(`found attribute change without node ID`);\n          continue;\n        }\n\n        if (!scopeIDs.includes(attr.nodeID || attr.node!.id)) {\n          continue;\n        }\n\n        updates.push([kind, attr.key, attr]);\n      }\n    }\n\n    super.next(scopeIDs);\n\n    for (const [kind, key, attrChange] of updates) {\n      // Forcing nodeID because we already tested it above.\n      const nodeID = attrChange.nodeID || attrChange.node!.id;\n\n      if (!scopeIDs.includes(nodeID)) {\n        continue;\n      }\n\n      const attr = this.attrs.get(nodeID)!.get(key)!;\n      const sub = this.attribSubs.get(kind)?.get(key);\n      if (sub) {\n        sub.next({ attribute: attr, done: true });\n      } else {\n        let kAttrs = this.attrsByKind.get(kind);\n        if (!kAttrs) {\n          kAttrs = new Map<string, Map<string, Attribute>>();\n          this.attrsByKind.set(kind, kAttrs);\n        }\n\n        let kkAttrs = kAttrs!.get(nodeID);\n        if (!kkAttrs) {\n          kkAttrs = new Map<string, Attribute>();\n          kAttrs!.set(nodeID, kkAttrs);\n        }\n\n        kkAttrs.set(key, attr);\n      }\n    }\n  }\n}\n","import { SetAttributeInput } from \"@empirica/tajriba\";\nimport { BehaviorSubject, Observable } from \"rxjs\";\nimport { error, trace } from \"../utils/console\";\nimport { JsonValue } from \"../utils/json\";\n\nexport interface AttributeChange {\n  /** deleted is true with the attribute was deleted. */\n  deleted?: boolean;\n  /** deletedAt is the time when the Attribute was deleted. int64 Date + Time\n   * value given in Epoch with ns precision */\n  deletedAt?: number;\n  /** createdAt is the time the Attribute was created. int64 Date + Time\n   * value given in Epoch with ns precision */\n  createdAt?: string;\n  /** id is the identifier for the Attribute. */\n  id: string;\n  /** index is the index of the attribute if the value is a vector. */\n  index?: number | null;\n  /** isNew is true if the Attribute was just created. */\n  isNew?: boolean;\n  /** key is the attribute key being updated. */\n  key: string;\n  /** nodeID is the identifier for the Attribute's Node. */\n  nodeID?: string;\n  /** node is the Attribute's Node. */\n  node?: {\n    __typename: \"Scope\";\n    id: string;\n    kind?: string;\n    name?: string;\n  };\n  /** value is the value of the updated attribute. */\n  val?: string | null;\n  /** vector indicates whether the value is a vector. */\n  vector: boolean;\n  /** version is the version number of this Attribute, starting at 1. */\n  version: number;\n}\n\nexport interface AttributeUpdate {\n  attribute: AttributeChange;\n  removed: boolean;\n}\n\nexport class Attributes {\n  protected attrs = new Map<string, Map<string, Attribute>>();\n  protected updates = new Map<string, Map<string, AttributeChange | boolean>>();\n\n  constructor(\n    attributesObs: Observable<AttributeUpdate>,\n    donesObs: Observable<string[]>,\n    readonly setAttributes: (input: SetAttributeInput[]) => Promise<unknown>\n  ) {\n    attributesObs.subscribe({\n      next: ({ attribute, removed }) => {\n        this.update(attribute, removed);\n      },\n    });\n\n    donesObs.subscribe({\n      next: (scopeIDs) => {\n        this.next(scopeIDs);\n      },\n    });\n  }\n\n  attribute(scopeID: string, key: string): Attribute {\n    let scopeMap = this.attrs.get(scopeID);\n    if (!scopeMap) {\n      scopeMap = new Map();\n      this.attrs.set(scopeID, scopeMap);\n    }\n\n    let attr = scopeMap.get(key);\n    if (!attr) {\n      attr = new Attribute(this.setAttributes, scopeID, key);\n      scopeMap.set(key, attr);\n    }\n\n    return attr;\n  }\n\n  attributes(scopeID: string): Attribute[] {\n    let scopeMap = this.attrs.get(scopeID);\n    if (!scopeMap) {\n      scopeMap = new Map();\n      this.attrs.set(scopeID, scopeMap);\n    }\n\n    return Array.from(scopeMap.values());\n  }\n\n  attributePeek(scopeID: string, key: string): Attribute | undefined {\n    let scopeUpdateMap = this.updates.get(scopeID);\n    if (scopeUpdateMap) {\n      const updated = scopeUpdateMap.get(key);\n      if (updated) {\n        if (typeof updated === \"boolean\") {\n          return;\n        } else {\n          if (!updated.val) {\n            return;\n          } else {\n            const attr = new Attribute(this.setAttributes, scopeID, key);\n            attr._update(updated);\n            return attr;\n          }\n        }\n      }\n    }\n\n    let scopeMap = this.attrs.get(scopeID);\n    if (!scopeMap) {\n      return;\n    }\n\n    let attr = scopeMap.get(key);\n    if (!attr) {\n      return;\n    }\n\n    if (attr.value === undefined) {\n      return;\n    }\n\n    return attr;\n  }\n\n  nextAttributeValue(scopeID: string, key: string): JsonValue | undefined {\n    const attr = this.attributePeek(scopeID, key);\n    if (!attr) {\n      return;\n    }\n\n    return attr.value;\n  }\n\n  private update(attr: AttributeChange, removed: boolean) {\n    let nodeID = attr.nodeID;\n    if (!nodeID) {\n      if (!attr.node?.id) {\n        error(`new attribute without node ID`);\n        return;\n      }\n      nodeID = attr.node.id;\n    }\n\n    let scopeMap = this.updates.get(nodeID);\n    if (!scopeMap) {\n      scopeMap = new Map();\n      this.updates.set(nodeID, scopeMap);\n    }\n\n    if (removed) {\n      scopeMap.set(attr.key, true);\n    } else {\n      let key = attr.key;\n      if (attr.index !== undefined && attr.index !== null) {\n        key = `${key}[${attr.index}]`;\n      }\n      scopeMap.set(key, attr);\n    }\n  }\n\n  scopeWasUpdated(scopeID?: string): boolean {\n    if (!scopeID) {\n      return false;\n    }\n\n    return this.updates.has(scopeID);\n  }\n\n  protected next(scopeIDs: string[]) {\n    for (const [scopeID, attrs] of this.updates) {\n      if (!scopeIDs.includes(scopeID)) {\n        continue;\n      }\n\n      let scopeMap = this.attrs.get(scopeID);\n\n      if (!scopeMap) {\n        scopeMap = new Map();\n        this.attrs.set(scopeID, scopeMap);\n      }\n\n      for (const [key, attrOrDel] of attrs) {\n        if (typeof attrOrDel === \"boolean\") {\n          let attr = scopeMap.get(key);\n          if (attr) {\n            attr._update(undefined);\n          }\n        } else {\n          let attr = scopeMap.get(attrOrDel.key);\n          if (!attr) {\n            attr = new Attribute(this.setAttributes, scopeID, attrOrDel.key);\n            scopeMap.set(attrOrDel.key, attr);\n          }\n\n          attr._update(attrOrDel);\n        }\n      }\n    }\n\n    for (const scopeID of scopeIDs) {\n      this.updates.delete(scopeID);\n    }\n  }\n}\n\nexport interface AttributeOptions {\n  /**\n   * Private indicates the attribute will not be visible to other Participants.\n   */\n  private: boolean;\n  /**\n   * Protected indicates the attribute will not be updatable by other\n   * Participants.\n   */\n  protected: boolean;\n  /** Immutable creates an Attribute that cannot be updated. */\n  immutable: boolean;\n  /**\n   * Index, only used if the Attribute is a vector, indicates which index to\n   * update the value at.\n   */\n  index: number | null;\n  /**\n   * Append, only used if the Attribute is a vector, indicates to append the\n   * attribute to the vector.\n   */\n  append: boolean | null;\n}\n\nexport class Attribute {\n  private attr?: AttributeChange;\n  private attrs?: Attribute[];\n\n  private val = new BehaviorSubject<JsonValue | undefined>(undefined);\n\n  constructor(\n    private setAttributes: (input: SetAttributeInput[]) => Promise<unknown>,\n    readonly scopeID: string,\n    readonly key: string\n  ) {}\n\n  get id() {\n    return this.attr?.id;\n  }\n\n  get createdAt() {\n    return this.attr ? new Date(this.attr!.createdAt!) : null;\n  }\n\n  get obs(): Observable<JsonValue | undefined> {\n    return this.val;\n  }\n\n  get value() {\n    return this.val.getValue();\n  }\n\n  get nodeID() {\n    return this.attr?.nodeID || this.attr?.node?.id;\n  }\n\n  // items returns the attribute changes for the current attribute, if it is a\n  // vector. Otherwise it returns null;\n  get items() {\n    if (!this.attrs) {\n      return null;\n    }\n\n    return this.attrs;\n  }\n\n  set(value: JsonValue, ao?: Partial<AttributeOptions>) {\n    const attrProps = this._prepSet(value, ao);\n    this.setAttributes([attrProps]);\n    trace(`SET ${this.key} = ${value} (${this.scopeID})`);\n  }\n\n  _prepSet(\n    value: JsonValue,\n    ao?: Partial<AttributeOptions>,\n    item?: boolean\n  ): SetAttributeInput {\n    if (!item && ao?.index !== undefined) {\n      const index = ao!.index!;\n\n      if (!this.attrs) {\n        this.attrs = [];\n      }\n\n      if (index + 1 > (this.attrs?.length || 0)) {\n        this.attrs.length = index! + 1;\n      }\n\n      if (!this.attrs[index]) {\n        this.attrs[index] = new Attribute(\n          this.setAttributes,\n          this.scopeID,\n          this.key\n        );\n      }\n\n      this.attrs![index]!._prepSet(value, ao, true);\n      const v = this._recalcVectorVal();\n      this.val.next(v);\n    } else {\n      this.val.next(value);\n    }\n\n    const attrProps: SetAttributeInput = {\n      key: this.key,\n      nodeID: this.scopeID,\n      val: JSON.stringify(value),\n    };\n\n    if (ao) {\n      // TODO Fix this. Should check if compatible with existing attribute and\n      // only set fields set on ao.\n      attrProps.private = ao.private;\n      attrProps.protected = ao.protected;\n      attrProps.immutable = ao.immutable;\n      attrProps.append = ao.append;\n      attrProps.index = ao.index;\n    }\n\n    return attrProps;\n  }\n\n  private _recalcVectorVal(): JsonValue {\n    return this.attrs!.map((a) =>\n      !a || a.val == undefined ? null : a.value || null\n    );\n  }\n\n  // internal only\n  _update(attr?: AttributeChange, item?: boolean) {\n    if (attr && this.attr && this.attr.id === attr.id) {\n      return;\n    }\n\n    if (attr && attr.vector && !item) {\n      // TODO check if is vector\n\n      if (attr.index === undefined) {\n        error(`vector attribute missing index`);\n        return;\n      }\n\n      if (this.attrs == undefined) {\n        this.attrs = [];\n      }\n\n      while (this.attrs.length < attr.index! + 1) {\n        const newAttr = new Attribute(\n          this.setAttributes,\n          this.scopeID,\n          this.key\n        );\n        this.attrs.push(newAttr);\n      }\n\n      const newAttr = new Attribute(this.setAttributes, this.scopeID, this.key);\n      newAttr._update(attr, true);\n      this.attrs[attr.index!] = newAttr;\n      const value = this._recalcVectorVal();\n      this.val.next(value);\n\n      return;\n    }\n\n    this.attr = attr;\n    let value: JsonValue | undefined = undefined;\n    if (this.attr?.val) {\n      value = JSON.parse(this.attr.val);\n    }\n    this.val.next(value);\n  }\n}\n","/* c8 ignore start */\n\nconst isBrowser =\n  typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\n\nenum Color {\n  Bold = 1,\n\n  Black = 30,\n  Red,\n  Green,\n  Yellow,\n  Blue,\n  Magenta,\n  Cyan,\n  White,\n\n  DarkGray = 90,\n}\n\nexport type LogLine = { level: string; args: any[] };\nexport class LogsMock {\n  public logs: LogLine[] = [];\n\n  log(line: LogLine) {\n    this.logs.push(line);\n  }\n\n  clear() {\n    this.logs = [];\n  }\n}\n\nlet logsMock: LogsMock | undefined;\nexport function captureLogs(cb: () => void): LogLine[] {\n  const lm = mockLogging();\n  cb();\n  const ret = lm.logs;\n  stopMockLogging();\n\n  return ret;\n}\n\nexport async function captureLogsAsync(\n  cb: () => Promise<void>\n): Promise<LogLine[]> {\n  const lm = mockLogging();\n  await cb();\n  const ret = lm.logs;\n  stopMockLogging();\n\n  return ret;\n}\n\nexport function mockLogging() {\n  if (!logsMock) {\n    logsMock = new LogsMock();\n  }\n\n  return logsMock;\n}\n\nexport function stopMockLogging() {\n  logsMock = undefined;\n}\n\nconst colorHex = {\n  [Color.Bold]: \"font-weight: bold\",\n  [Color.Black]: \"color: #000000\",\n  [Color.Red]: \"color: #cc0000\",\n  [Color.Green]: \"color: #4e9a06\",\n  [Color.Yellow]: \"color: #c4a000\",\n  [Color.Blue]: \"color: #729fcf\",\n  [Color.Magenta]: \"color: #75507b\",\n  [Color.Cyan]: \"color: #06989a\",\n  [Color.White]: \"color: #d3d7cf\",\n  [Color.DarkGray]: \"color: #555753\",\n};\n\nexport const levels: { [key: string]: number } = {\n  trace: 0,\n  debug: 1,\n  log: 2,\n  info: 2,\n  warn: 3,\n  error: 4,\n};\n\nconst reversLevels: { [key: number]: string } = {};\nfor (const key in levels) {\n  reversLevels[levels[key]!] = key;\n}\n\nlet currentLevel = 2;\n\nexport function setLogLevel(level: keyof typeof levels) {\n  const lvl = levels[level];\n  if (lvl === undefined) {\n    return;\n  }\n\n  currentLevel = lvl;\n}\n\nfunction formatConsoleDate(date: Date, level: string[]) {\n  var hour = date.getHours();\n  var minutes = date.getMinutes();\n  var seconds = date.getSeconds();\n  var milliseconds = date.getMilliseconds();\n\n  const str =\n    (hour < 10 ? \"0\" + hour : hour) +\n    \":\" +\n    (minutes < 10 ? \"0\" + minutes : minutes) +\n    \":\" +\n    (seconds < 10 ? \"0\" + seconds : seconds) +\n    \".\" +\n    (\"00\" + milliseconds).slice(-3);\n\n  if (isBrowser) {\n    const ts = colorize(str, Color.DarkGray).concat(level);\n    return [ts[0] + \" \" + level[0], ts[1], level[1]];\n  }\n\n  return colorize(str, Color.DarkGray).concat(level);\n}\n\nconst createLogger = (lvl: number, level: string[]) => {\n  return (...args: any[]) => {\n    if (lvl < currentLevel) {\n      return;\n    }\n\n    if (logsMock) {\n      logsMock.log({ level: reversLevels[lvl]!, args: args });\n\n      return;\n    }\n\n    if (args.length === 1) {\n      switch (typeof args[0]) {\n        case \"string\":\n          for (const line of args[0].split(\"\\n\")) {\n            console.log(...formatConsoleDate(new Date(), level).concat(line));\n          }\n          return;\n\n        case \"object\":\n          if (args[0] instanceof Error) {\n            const error = args[0] as Error;\n            const prettyErr =\n              error.name +\n              \": \" +\n              error.message.replace(new RegExp(`^${error.name}[: ]*`), \"\") +\n              \"\\n\" +\n              (error.stack || \"\")\n                .split(\"\\n\")\n                .map((line) => line.trim())\n                .map((line) => {\n                  if (line.startsWith(error.name + \": \" + error.message))\n                    return null;\n\n                  if (line.startsWith(\"at\")) {\n                    return \"  \" + line;\n                  }\n\n                  return line;\n                })\n                .filter(Boolean)\n                .join(\"\\n\");\n\n            for (const line of prettyErr.split(\"\\n\")) {\n              console.log(...formatConsoleDate(new Date(), level).concat(line));\n            }\n\n            return;\n          }\n      }\n    }\n\n    console.log(...formatConsoleDate(new Date(), level).concat(args));\n  };\n};\n\nfunction colorize(s: string, ...cc: Color[]): string[] {\n  if (isBrowser) {\n    const attr = [];\n    for (const c of cc) {\n      attr.push(colorHex[c]);\n    }\n\n    return [`%c${s}`, attr.join(\"; \")];\n  }\n\n  let out = \"\";\n  for (const c of cc) {\n    out += `\\x1b[${c}m`;\n  }\n  out += `${s}\\x1b[0m`;\n\n  return [out];\n}\n\nexport const trace = createLogger(0, colorize(\"TRC\", Color.Magenta));\nexport const debug = createLogger(1, colorize(\"DBG\", Color.Yellow));\nexport const log = createLogger(2, colorize(\"LOG\", Color.Yellow));\nexport const info = createLogger(2, colorize(\"INF\", Color.Green));\nexport const warn = createLogger(3, colorize(\"WRN\", Color.Cyan));\nexport const error = createLogger(4, colorize(\"ERR\", Color.Red, Color.Bold));\n\n// export {\n//   trace,\n//   debug,\n//   log,\n//   info,\n//   warn,\n//   error,\n// };\n\n// export function warn(...args: string[]) {}\n","import { TajribaAdmin } from \"@empirica/tajriba\";\nimport { BehaviorSubject, merge, SubscriptionLike } from \"rxjs\";\nimport {\n  ErrNotConnected,\n  TajribaConnection,\n} from \"../shared/tajriba_connection\";\nimport { bs, bsu } from \"../utils/object\";\nimport { subscribeAsync } from \"./observables\";\n\nexport class AdminConnection {\n  private _tajriba = bsu<TajribaAdmin>();\n  private _connected = bs(false);\n  private _connecting = bs(false);\n  private _stopped = bs(false);\n  private sub: SubscriptionLike;\n\n  constructor(\n    taj: TajribaConnection,\n    tokens: BehaviorSubject<string | null | undefined>,\n    private resetToken: () => void\n  ) {\n    let token: string | null | undefined;\n    let connected = false;\n\n    this.sub = subscribeAsync(\n      merge(taj.connected, tokens),\n      async (tokenOrConnected) => {\n        if (typeof tokenOrConnected === \"boolean\") {\n          connected = tokenOrConnected;\n        } else {\n          token = tokenOrConnected;\n        }\n\n        if (!token || !connected) {\n          return;\n        }\n\n        if (this._connected.getValue()) {\n          return;\n        }\n\n        this._connecting.next(true);\n\n        try {\n          const tajAdmin = await taj.sessionAdmin(token);\n\n          this._tajriba.next(tajAdmin);\n          this._connected.next(true);\n\n          tajAdmin.on(\"connected\", () => {\n            if (!this._connected.getValue()) {\n              this._connected.next(true);\n            }\n          });\n          tajAdmin.on(\"disconnected\", () => {\n            if (this._connected.getValue()) {\n              this._connected.next(false);\n            }\n          });\n          tajAdmin.on(\"accessDenied\", () => {\n            if (this._connected.getValue()) {\n              this._connected.next(false);\n            }\n            this.resetToken();\n          });\n        } catch (error) {\n          if (error !== ErrNotConnected) {\n            this.resetToken();\n          }\n        }\n\n        this._connecting.next(false);\n      }\n    );\n  }\n\n  stop() {\n    if (this._stopped.getValue()) {\n      return;\n    }\n\n    const taj = this._tajriba.getValue();\n    if (taj) {\n      taj.removeAllListeners(\"connected\");\n      taj.removeAllListeners(\"disconnected\");\n      taj.stop();\n      this._tajriba.next(undefined);\n    }\n\n    this.sub.unsubscribe();\n\n    this._connecting.next(false);\n    this._connected.next(false);\n    this._stopped.next(true);\n  }\n\n  get connecting() {\n    return this._connecting;\n  }\n\n  get connected() {\n    return this._connected;\n  }\n\n  get stopped() {\n    return this._stopped;\n  }\n\n  get admin() {\n    return this._tajriba;\n  }\n}\n","import { Observable, Subject, concatMap, takeUntil } from \"rxjs\";\nimport { warn } from \"../utils/console\";\n\nexport async function awaitObsValue<T>(\n  obs: Observable<T>,\n  value: T\n): Promise<T> {\n  let res: (value: T) => void;\n  const prom = new Promise<T>((r) => {\n    res = r;\n  });\n\n  const unsub = obs.subscribe((val) => {\n    if (val === value) {\n      res(val);\n    }\n  });\n\n  const val = await prom;\n  unsub.unsubscribe();\n\n  return val;\n}\n\nexport async function awaitObsValueExist<T>(obs: Observable<T>): Promise<T> {\n  let res: (value: T) => void;\n  const prom = new Promise<T>((r) => {\n    res = r;\n  });\n\n  const unsub = obs.subscribe((val) => {\n    if (val) {\n      res(val);\n    }\n  });\n\n  const val = await prom;\n  unsub.unsubscribe();\n\n  return val;\n}\n\nexport async function awaitObsValueChange<T>(obs: Observable<T>): Promise<T> {\n  let res: (value: T) => void;\n  const prom = new Promise<T>((r) => {\n    res = r;\n  });\n\n  let once = false;\n  let v: T;\n  const unsub = obs.subscribe((val) => {\n    if (once && val !== v) {\n      res(val);\n    }\n    once = true;\n    v = val;\n  });\n\n  const val = await prom;\n  unsub.unsubscribe();\n\n  return val;\n}\n\n// This does not behave correctly with a ReplaySubject\nexport function subscribeAsync<T>(\n  obs: Observable<T>,\n  fn: (val: T) => Promise<any>\n) {\n  const cancel = new Subject<void>();\n  obs.pipe(concatMap(fn), takeUntil(cancel)).subscribe();\n  return {\n    closed: false,\n    unsubscribe() {\n      if (this.closed) {\n        warn(\"closing a closed async observable subscription\");\n        return;\n      }\n      this.closed = true;\n      cancel.next();\n      cancel.unsubscribe();\n    },\n  };\n}\n\nexport interface AsyncObserver<T> {\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\nexport interface Unsubscribable {\n  unsubscribe(): void;\n}\n\nexport interface AsyncSubscribable<T> {\n  subscribe(observer: Partial<AsyncObserver<T>>): Promise<Unsubscribable>;\n}\n\n// A ReplaySubject that supports async subscribers\nexport class AsyncReplaySubject<T> {\n  private values: T[] = [];\n  private subscribers: ((val: T) => Promise<void>)[] = [];\n\n  async next(value: T) {\n    this.values.push(value);\n    for (const sub of this.subscribers) {\n      await sub(value);\n    }\n  }\n\n  async subscribe({ next }: { next: (val: T) => Promise<void> }) {\n    this.subscribers.push(next);\n    for (const v of this.values) {\n      await next(v);\n    }\n\n    let closed = false;\n    return {\n      get closed() {\n        return closed;\n      },\n      unsubscribe: () => {\n        if (closed) {\n          warn(\"closing a closed async observable subscription\");\n          return;\n        }\n\n        closed = true;\n        this.subscribers = this.subscribers.filter((s) => s !== next);\n      },\n    };\n  }\n}\n\n// A Subject that supports async subscribers\nexport class AsyncSubject<T> {\n  private subscribers: ((val: T) => Promise<void>)[] = [];\n\n  constructor(private value: T) {}\n\n  async next(value: T) {\n    for (const sub of this.subscribers) {\n      await sub(value);\n    }\n  }\n\n  async subscribe({ next }: { next: (val: T) => Promise<void> }) {\n    this.subscribers.push(next);\n    await next(this.value);\n\n    let closed = false;\n    return {\n      get closed() {\n        return closed;\n      },\n      unsubscribe: () => {\n        if (closed) {\n          warn(\"closing a closed async observable subscription\");\n          return;\n        }\n\n        closed = true;\n        this.subscribers = this.subscribers.filter((s) => s !== next);\n      },\n    };\n  }\n}\n","import {\n  AddGroupInput,\n  AddScopeInput,\n  AddStepInput,\n  LinkInput,\n  State,\n  TransitionInput,\n} from \"@empirica/tajriba\";\nimport { merge, Subject, SubscriptionLike } from \"rxjs\";\nimport { ScopeConstructor } from \"../shared/scopes\";\nimport { TajribaConnection } from \"../shared/tajriba_connection\";\nimport { error, warn } from \"../utils/console\";\nimport { AdminConnection } from \"./connection\";\nimport { ListenersCollector, Subscriber } from \"./events\";\nimport { Globals } from \"./globals\";\nimport { subscribeAsync } from \"./observables\";\nimport { Runloop } from \"./runloop\";\nimport {\n  FileTokenStorage,\n  MemTokenStorage,\n  SavedTokenStorage,\n  TokenProvider,\n} from \"./token_file\";\n\nexport class AdminContext<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> {\n  readonly tajriba: TajribaConnection;\n  public adminConn: AdminConnection | undefined;\n  private sub?: SubscriptionLike;\n  private runloop: Runloop<Context, Kinds> | undefined;\n  private adminSubs = new Subject<\n    Subscriber<Context, Kinds> | ListenersCollector<Context, Kinds>\n  >();\n  private adminStop = new Subject<void>();\n  private subs: (\n    | Subscriber<Context, Kinds>\n    | ListenersCollector<Context, Kinds>\n  )[] = [];\n\n  private constructor(url: string, private ctx: Context, private kinds: Kinds) {\n    this.tajriba = new TajribaConnection(url);\n  }\n\n  /**\n   * @internal\n   *\n   * NOTE: For testing purposes only.\n   */\n  get _runloop() {\n    return this.runloop;\n  }\n\n  static async init<\n    Context,\n    Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n  >(\n    url: string,\n    tokenFile: string,\n    serviceName: string,\n    serviceRegistrationToken: string,\n    ctx: Context,\n    kinds: Kinds\n  ) {\n    const adminContext = new this(url, ctx, kinds);\n    const reset = new Subject<void>();\n    let strg: SavedTokenStorage;\n    if (tokenFile === \":mem:\") {\n      strg = new MemTokenStorage();\n    } else {\n      strg = await FileTokenStorage.init(tokenFile, reset);\n    }\n\n    const tp = new TokenProvider(\n      adminContext.tajriba,\n      strg,\n      serviceName,\n      serviceRegistrationToken\n    );\n    adminContext.adminConn = new AdminConnection(\n      adminContext.tajriba,\n      tp.tokens,\n      reset.next.bind(reset)\n    );\n\n    adminContext.sub = subscribeAsync(\n      merge(adminContext.tajriba.connected, adminContext.adminConn.connected),\n      async () => {\n        await adminContext.initOrStop();\n      }\n    );\n\n    return adminContext;\n  }\n\n  async stop() {\n    this.sub?.unsubscribe();\n    delete this.sub;\n    await this.stopSubs();\n    this.tajriba.stop();\n    this.adminConn?.stop();\n  }\n\n  register(\n    subscriber: Subscriber<Context, Kinds> | ListenersCollector<Context, Kinds>\n  ) {\n    this.subs.push(subscriber);\n    if (this.runloop) {\n      this.adminSubs.next(subscriber);\n    }\n  }\n\n  private async initOrStop() {\n    // Forcing this.adminConn since adminConn is always created by init().\n    if (\n      this.tajriba.connected.getValue() &&\n      this.adminConn!.connected.getValue()\n    ) {\n      await this.initSubs();\n    } else {\n      await this.stopSubs();\n    }\n  }\n\n  private async initSubs() {\n    if (this.runloop) {\n      return;\n    }\n\n    /* c8 ignore next 5 */\n    if (!this.adminConn) {\n      // This condition is nearly impossible to create\n      warn(\"context: admin not connected\");\n      return;\n    }\n\n    /* c8 ignore next 6 */\n    const tajAdmin = this.adminConn.admin.getValue();\n    if (!tajAdmin) {\n      // This condition is nearly impossible to create\n      warn(\"context: admin not connected\");\n      return;\n    }\n\n    let globalScopeID: string | undefined;\n    try {\n      const scopes = await tajAdmin.scopes({\n        filter: { kinds: [\"global\"] },\n        first: 100,\n      });\n      globalScopeID = scopes!.edges[0]?.node.id;\n      if (!globalScopeID) {\n        warn(\"context: global scopeID not found\");\n\n        return;\n      }\n    } catch (err) {\n      error(`context: global scopeID not fetched: ${err}`);\n\n      return;\n    }\n\n    this.runloop = new Runloop(\n      this.adminConn,\n      this.ctx,\n      this.kinds,\n      globalScopeID,\n      this.adminSubs,\n      this.adminStop\n    );\n\n    for (const sub of this.subs) {\n      this.adminSubs.next(sub);\n    }\n  }\n\n  private async stopSubs() {\n    this.adminStop.next();\n    if (this.runloop) {\n      await this.runloop.stop();\n      this.runloop = undefined;\n    }\n  }\n}\n\nexport interface StepPayload {\n  id: string;\n  duration: number;\n}\n\nexport interface AddLinkPayload {\n  nodes: { id: string }[];\n  participants: { id: string }[];\n}\n\nexport interface AddTransitionPayload {\n  id: string;\n  from: State;\n  to: State;\n}\n\nexport interface AddScopePayload {\n  id: string;\n  name?: string | null | undefined;\n  kind?: string | null | undefined;\n  attributes: {\n    edges: {\n      node: {\n        id: string;\n        private: boolean;\n        protected: boolean;\n        immutable: boolean;\n        key: string;\n        val?: string | null | undefined;\n        index?: number | null | undefined;\n      };\n    }[];\n  };\n}\n\nexport type Finalizer = () => Promise<void>;\n\nexport class TajribaAdminAccess {\n  constructor(\n    readonly addFinalizer: (cb: Finalizer) => void,\n    readonly addScopes: (input: AddScopeInput[]) => Promise<AddScopePayload[]>,\n    readonly addGroups: (input: AddGroupInput[]) => Promise<{ id: string }[]>,\n    readonly addLinks: (input: LinkInput[]) => Promise<AddLinkPayload[]>,\n    readonly addSteps: (input: AddStepInput[]) => Promise<StepPayload[]>,\n    readonly addTransitions: (\n      input: TransitionInput[]\n    ) => Promise<AddTransitionPayload[]>,\n    readonly globals: Globals\n  ) {}\n}\n","import {\n  AddGroupInput,\n  AddScopeInput,\n  AddStepInput,\n  LinkInput,\n  ScopedAttributesInput,\n  SetAttributeInput,\n  TransitionInput,\n} from \"@empirica/tajriba\";\nimport {\n  BehaviorSubject,\n  Observable,\n  ReplaySubject,\n  Subject,\n  Subscription,\n} from \"rxjs\";\nimport { AttributeChange, AttributeUpdate } from \"../shared/attributes\";\nimport { ScopeConstructor, ScopeIdent, ScopeUpdate } from \"../shared/scopes\";\nimport { error, warn } from \"../utils/console\";\nimport { Attributes } from \"./attributes\";\nimport { Cake } from \"./cake\";\nimport { AdminConnection } from \"./connection\";\nimport {\n  AddLinkPayload,\n  AddScopePayload,\n  AddTransitionPayload,\n  Finalizer,\n  StepPayload,\n  TajribaAdminAccess,\n} from \"./context\";\nimport { EventContext, ListenersCollector, Subscriber } from \"./events\";\nimport { Globals } from \"./globals\";\nimport { awaitObsValue, subscribeAsync } from \"./observables\";\nimport { ConnectionMsg, Participant, participantsSub } from \"./participants\";\nimport { Scopes } from \"./scopes\";\nimport { Subs, Subscriptions } from \"./subscriptions\";\nimport { Transition, transitionsSub } from \"./transitions\";\n\nexport class Runloop<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> {\n  private subs = new Subscriptions<Context, Kinds>();\n  private evtctx: EventContext<Context, Kinds>;\n  private participants = new Map<string, Participant>();\n  private connections = new ReplaySubject<ConnectionMsg>();\n  private transitions = new Subject<Transition>();\n  private scopesSub = new Subject<ScopeUpdate>();\n  private attributesSub = new Subject<AttributeUpdate>();\n  private donesSub = new Subject<string[]>();\n  private attributes: Attributes;\n  private finalizers: Finalizer[] = [];\n  private groupPromises: Promise<{ id: string }[]>[] = [];\n  private stepPromises: Promise<StepPayload[]>[] = [];\n  private scopePromises: Promise<AddScopePayload[]>[] = [];\n  private linkPromises: Promise<AddLinkPayload>[] = [];\n  private transitionPromises: Promise<AddTransitionPayload>[] = [];\n  private attributeInputs: SetAttributeInput[] = [];\n  private scopes: Scopes<Context, Kinds>;\n  private cake: Cake<Context, Kinds>;\n  private running = new BehaviorSubject<boolean>(false);\n  private stopped = false;\n\n  constructor(\n    private conn: AdminConnection,\n    private ctx: Context,\n    private kinds: Kinds,\n    globalScopeID: string,\n    subs: Observable<\n      Subscriber<Context, Kinds> | ListenersCollector<Context, Kinds>\n    >,\n    stop: Observable<void>\n  ) {\n    this.attributes = new Attributes(\n      this.attributesSub,\n      this.donesSub,\n      this.setAttributes.bind(this)\n    );\n\n    const mut = new TajribaAdminAccess(\n      this.addFinalizer.bind(this),\n      this.addScopes.bind(this),\n      this.addGroups.bind(this),\n      this.addLinks.bind(this),\n      this.addSteps.bind(this),\n      this.addTransitions.bind(this),\n      new Globals(\n        this.taj.globalAttributes(),\n        globalScopeID,\n        this.setAttributes.bind(this)\n      )\n    );\n\n    this.scopes = new Scopes<Context, Kinds>(\n      this.scopesSub,\n      this.donesSub,\n      this.ctx,\n      this.kinds,\n      this.attributes,\n      mut\n    );\n\n    this.evtctx = new EventContext(this.subs, mut, this.scopes);\n    this.cake = new Cake(\n      this.evtctx,\n      this.scopes.scope.bind(this.scopes),\n      this.scopes.subscribeKind.bind(this.scopes),\n      (kind: keyof Kinds, key: string) =>\n        this.attributes.subscribeAttribute(<string>kind, key),\n      this.connections,\n      this.transitions\n    );\n    this.cake.postCallback = this.postCallback.bind(this, true);\n\n    const subsSub = subscribeAsync(subs, async (subscriber) => {\n      let listeners: ListenersCollector<Context, Kinds>;\n      if (typeof subscriber === \"function\") {\n        listeners = new ListenersCollector<Context, Kinds>();\n        subscriber(listeners);\n      } else {\n        listeners = subscriber;\n      }\n\n      await this.cake.add(listeners);\n    });\n\n    let stopSub: Subscription;\n    stopSub = stop.subscribe({\n      next: () => {\n        subsSub.unsubscribe();\n        stopSub.unsubscribe();\n      },\n    });\n  }\n\n  /**\n   * @internal\n   *\n   * NOTE: For testing purposes only.\n   */\n  get _attributes() {\n    return this.attributes;\n  }\n\n  /**\n   * @internal\n   *\n   * NOTE: For testing purposes only.\n   */\n  get _scopes() {\n    return this.scopes;\n  }\n\n  /**\n   * @internal\n   *\n   * NOTE: For testing purposes only.\n   */\n  async _postCallback() {\n    return await this.postCallback(true);\n  }\n\n  private async postCallback(final: boolean) {\n    if (this.stopped) {\n      return;\n    }\n\n    this.running.next(true);\n\n    const promises: Promise<any>[] = [];\n\n    const subs = this.subs.newSubs();\n    if (subs) {\n      promises.push(this.processNewSub(subs));\n    }\n\n    promises.push(...this.groupPromises);\n    this.groupPromises = [];\n    promises.push(...this.stepPromises);\n    this.stepPromises = [];\n    promises.push(...this.scopePromises);\n    this.scopePromises = [];\n    promises.push(...this.linkPromises);\n    this.linkPromises = [];\n    promises.push(...this.transitionPromises);\n    this.transitionPromises = [];\n\n    if (this.attributeInputs.length > 0) {\n      // If the same key is set twice within the same loop, only send 1\n      // setAttribute update.\n      const uniqueAttrs: { [key: string]: SetAttributeInput } = {};\n      for (const attr of this.attributeInputs) {\n        if (!attr.nodeID) {\n          error(`runloop: attribute without nodeID: ${JSON.stringify(attr)}`);\n          continue;\n        }\n\n        uniqueAttrs[`${attr.nodeID}-${attr.key}`] = attr;\n      }\n\n      const attrs = Object.values(uniqueAttrs);\n\n      promises.push(this.taj.setAttributes(attrs));\n      this.attributeInputs = [];\n    }\n\n    const res = await Promise.allSettled(promises);\n    for (const r of res) {\n      if (r.status === \"rejected\") {\n        warn(`failed load: ${r.reason}`);\n      }\n    }\n\n    const finalizer = this.finalizers.shift();\n    if (finalizer) {\n      await finalizer();\n      await this.postCallback(false);\n    }\n\n    if (final) {\n      this.running.next(false);\n    }\n  }\n\n  async stop() {\n    await this.cake.stop();\n    await awaitObsValue(this.running, false);\n    this.stopped = true;\n  }\n\n  addFinalizer(cb: Finalizer) {\n    this.finalizers.push(cb);\n  }\n\n  async addScopes(inputs: AddScopeInput[]) {\n    if (this.stopped) {\n      // warn(\"addScopes on stopped\", inputs);\n\n      return [];\n    }\n\n    const addScopes = this.taj.addScopes(inputs).catch((err) => {\n      warn(err.message);\n      return [];\n    });\n    this.scopePromises.push(\n      addScopes.then((scopes) => {\n        for (const scope of scopes) {\n          for (const attrEdge of scope.attributes.edges) {\n            this.attributesSub.next({\n              attribute: attrEdge.node as AttributeChange,\n              removed: false,\n            });\n          }\n\n          this.scopesSub.next({\n            scope: scope as ScopeIdent,\n            removed: false,\n          });\n        }\n\n        this.donesSub.next(scopes.map((s) => s.id));\n\n        return scopes;\n      })\n    );\n\n    return addScopes;\n  }\n\n  async addGroups(inputs: AddGroupInput[]) {\n    if (this.stopped) {\n      // warn(\"addGroups on stopped\", inputs);\n\n      return [];\n    }\n\n    const addGroups = this.taj.addGroups(inputs);\n    this.groupPromises.push(addGroups);\n    return addGroups;\n  }\n\n  async addLinks(inputs: LinkInput[]) {\n    if (this.stopped) {\n      // warn(\"addLinks on stopped\", inputs);\n\n      return [];\n    }\n\n    const proms: Promise<AddLinkPayload>[] = [];\n    for (const input of inputs) {\n      const linkPromise = this.taj.addLink(input);\n      this.linkPromises.push(linkPromise);\n      proms.push(linkPromise);\n    }\n\n    return Promise.all(proms);\n  }\n\n  async addSteps(inputs: AddStepInput[]) {\n    if (this.stopped) {\n      // warn(\"addSteps on stopped\", inputs);\n\n      return [];\n    }\n\n    const addSteps = this.taj.addSteps(inputs);\n    this.stepPromises.push(addSteps);\n    return addSteps;\n  }\n\n  async addTransitions(inputs: TransitionInput[]) {\n    if (this.stopped) {\n      // warn(\"addTransitions on stopped\", inputs);\n\n      return [];\n    }\n\n    const proms: Promise<AddTransitionPayload>[] = [];\n    for (const input of inputs) {\n      const transitionPromise = this.taj.transition(input);\n      this.transitionPromises.push(transitionPromise);\n      proms.push(transitionPromise);\n    }\n\n    return Promise.all(proms);\n  }\n\n  async setAttributes(inputs: SetAttributeInput[]) {\n    this.attributeInputs.push(...inputs);\n  }\n\n  // TODO ADD iteration attributes per scope, only first 100...\n  private loadAllScopes(filters: ScopedAttributesInput[], after?: any) {\n    this.taj.scopes({ filter: filters, first: 100, after }).then((conn) => {\n      const scopes: { [key: string]: ScopeIdent } = {};\n      for (const edge of conn?.edges || []) {\n        for (const attrEdge of edge.node.attributes.edges || []) {\n          this.attributesSub.next({\n            attribute: attrEdge.node as AttributeChange,\n            removed: false,\n          });\n        }\n\n        scopes[edge.node.id] = edge.node as ScopeIdent;\n      }\n\n      for (const scope of Object.values(scopes)) {\n        this.scopesSub.next({\n          scope,\n          removed: false,\n        });\n      }\n\n      if (conn?.pageInfo.hasNextPage && conn?.pageInfo.endCursor) {\n        return this.loadAllScopes(filters, conn?.pageInfo.endCursor);\n      }\n    });\n  }\n\n  private async processNewScopesSub(filters: ScopedAttributesInput[]) {\n    if (filters.length === 0) {\n      return;\n    }\n\n    let resolve: (value: void) => void;\n    const prom = new Promise((r) => (resolve = r));\n    this.taj.scopedAttributes(filters).subscribe({\n      next: ({ attribute, scopesUpdated, done }) => {\n        if (attribute) {\n          if (attribute.node.__typename !== \"Scope\") {\n            error(`scoped attribute with non-scope node`);\n            return;\n          }\n\n          this.attributesSub.next({\n            attribute: attribute as AttributeChange,\n            removed: false,\n          });\n\n          this.scopesSub.next({\n            scope: attribute.node as ScopeIdent,\n            removed: false,\n          });\n        }\n\n        if (done) {\n          resolve();\n          if (!scopesUpdated) {\n            error(`scopesUpdated is empty`);\n            return;\n          }\n\n          this.donesSub.next(scopesUpdated);\n        }\n      },\n    });\n\n    // await Promise.all([prom, initProm]);\n    await prom;\n  }\n\n  private async processNewSub(subs: Subs) {\n    const filters: ScopedAttributesInput[] = [];\n    if (subs.scopes.ids.length > 0) {\n      filters.push({ ids: subs.scopes.ids });\n    }\n\n    if (subs.scopes.kinds.length > 0) {\n      filters.push({ kinds: subs.scopes.kinds });\n    }\n\n    if (subs.scopes.names.length > 0) {\n      filters.push({ names: subs.scopes.names });\n    }\n\n    if (subs.scopes.keys.length > 0) {\n      filters.push({ keys: subs.scopes.keys });\n    }\n\n    if (subs.scopes.kvs.length > 0) {\n      filters.push({ kvs: subs.scopes.kvs });\n    }\n\n    if (subs.participants) {\n      await participantsSub(this.taj, this.connections, this.participants);\n    }\n\n    if (subs.transitions.length > 0) {\n      for (const id of subs.transitions) {\n        transitionsSub(this.taj, this.transitions, id);\n      }\n    }\n\n    await this.processNewScopesSub(filters);\n  }\n\n  private get taj() {\n    return this.conn.admin.getValue()!;\n  }\n}\n","import {\n  AddGroupInput,\n  AddScopeInput,\n  AddStepInput,\n  LinkInput,\n  TransitionInput,\n} from \"@empirica/tajriba\";\nimport { Attribute } from \"../shared/attributes\";\nimport { ScopeConstructor } from \"../shared/scopes\";\nimport { Finalizer, TajribaAdminAccess } from \"./context\";\nimport { Scope, Scopes } from \"./scopes\";\nimport { ScopeSubscriptionInput } from \"./subscriptions\";\n\nexport type Subscriber<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> = (subs: ListenersCollector<Context, Kinds>) => void;\n\nexport enum TajribaEvent {\n  TransitionAdd = \"TRANSITION_ADD\",\n  ParticipantConnect = \"PARTICIPANT_CONNECT\",\n  ParticipantDisconnect = \"PARTICIPANT_DISCONNECT\",\n}\n\nexport enum ListernerPlacement {\n  Before,\n  None, // Not before or after\n  After,\n}\n\nconst placementString = new Map<ListernerPlacement, string>();\nplacementString.set(ListernerPlacement.Before, \"before\");\nplacementString.set(ListernerPlacement.None, \"on\");\nplacementString.set(ListernerPlacement.After, \"after\");\n\nexport function PlacementString(placement: ListernerPlacement): string {\n  return placementString.get(placement)!;\n}\n\nexport type SimpleListener<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> = {\n  placement: ListernerPlacement;\n  callback: (ctx: EventContext<Context, Kinds>) => void;\n};\n\nexport type TajEventListener<Callback extends Function> = {\n  placement: ListernerPlacement;\n  event: TajribaEvent;\n  callback: Callback;\n};\n\nexport type KindEventListener<Callback extends Function> = {\n  placement: ListernerPlacement;\n  kind: string;\n  callback: Callback;\n};\n\nexport type AttributeEventListener<Callback extends Function> = {\n  placement: ListernerPlacement;\n  kind: string;\n  key: string;\n  callback: Callback;\n};\n\nexport type EvtCtxCallback<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> = (ctx: EventContext<Context, Kinds>, props: any) => void;\n\nfunction unique<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> },\n  K extends keyof Kinds\n>(\n  kind: K,\n  placement: ListernerPlacement,\n  callback: EvtCtxCallback<Context, Kinds>\n) {\n  return async (ctx: EventContext<Context, Kinds>, props: any) => {\n    const attr = props.attribute as Attribute;\n    const scope = props[kind] as Scope<Context, Kinds>;\n    if (!attr.id || scope.get(`ran-${PlacementString(placement)}-${attr.id}`)) {\n      return;\n    }\n\n    await callback(ctx, props);\n\n    scope.set(`ran-${PlacementString(placement)}-${attr.id}`, true);\n  };\n}\n\n// Collects event listeners.\nexport class ListenersCollector<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> {\n  /** @internal */\n  readonly starts: SimpleListener<Context, Kinds>[] = [];\n  /** @internal */\n  readonly readys: SimpleListener<Context, Kinds>[] = [];\n  /** @internal */\n  readonly tajEvents: TajEventListener<EvtCtxCallback<Context, Kinds>>[] = [];\n  /** @internal */\n  readonly kindListeners: KindEventListener<EvtCtxCallback<Context, Kinds>>[] =\n    [];\n  /** @internal */\n  readonly attributeListeners: AttributeEventListener<\n    EvtCtxCallback<Context, Kinds>\n  >[] = [];\n\n  get unique() {\n    return new ListenersCollectorProxy<Context, Kinds>(this);\n  }\n\n  // start: first callback called.\n  // ready: callback called when initial loading is finished.\n  on(\n    kind: \"start\" | \"ready\",\n    callback: (ctx: EventContext<Context, Kinds>) => void\n  ): void;\n\n  // Attach to Tajriba Hooks.\n  on(event: TajribaEvent, callback: EvtCtxCallback<Context, Kinds>): void;\n\n  // Receive Scopes by Kind as they are fetched.\n  on<Kind extends string>(\n    kind: Kind,\n    callback: EvtCtxCallback<Context, Kinds>\n  ): void;\n\n  // Receive Scope attributes as they are fetched.\n  on<Kind extends keyof Kinds>(\n    kind: Kind,\n    key: string,\n    callback: EvtCtxCallback<Context, Kinds>,\n    uniqueCall?: boolean\n  ): void;\n\n  on(\n    kindOrEvent: string,\n    keyOrNodeIDOrEventOrCallback?:\n      | string\n      | TajribaEvent\n      | EvtCtxCallback<Context, Kinds>\n      | ((ctx: EventContext<Context, Kinds>) => void),\n    callback?: EvtCtxCallback<Context, Kinds>\n  ): void {\n    this.registerListerner(\n      ListernerPlacement.None,\n      kindOrEvent,\n      keyOrNodeIDOrEventOrCallback,\n      callback\n    );\n  }\n\n  before(\n    kindOrEvent: string,\n    keyOrNodeIDOrEventOrCallback?:\n      | string\n      | TajribaEvent\n      | EvtCtxCallback<Context, Kinds>\n      | ((ctx: EventContext<Context, Kinds>) => void),\n    callback?: EvtCtxCallback<Context, Kinds>,\n    uniqueCall?: boolean\n  ): void {\n    this.registerListerner(\n      ListernerPlacement.Before,\n      kindOrEvent,\n      keyOrNodeIDOrEventOrCallback,\n      callback,\n      uniqueCall\n    );\n  }\n\n  after(\n    kindOrEvent: string,\n    keyOrNodeIDOrEventOrCallback?:\n      | string\n      | TajribaEvent\n      | EvtCtxCallback<Context, Kinds>\n      | ((ctx: EventContext<Context, Kinds>) => void),\n    callback?: EvtCtxCallback<Context, Kinds>,\n    uniqueCall?: boolean\n  ): void {\n    this.registerListerner(\n      ListernerPlacement.After,\n      kindOrEvent,\n      keyOrNodeIDOrEventOrCallback,\n      callback,\n      uniqueCall\n    );\n  }\n\n  protected registerListerner(\n    placement: ListernerPlacement,\n    kindOrEvent: string,\n    keyOrNodeIDOrEventOrCallback?:\n      | string\n      | TajribaEvent\n      | EvtCtxCallback<Context, Kinds>\n      | ((ctx: EventContext<Context, Kinds>) => void),\n    callback?: EvtCtxCallback<Context, Kinds>,\n    uniqueCall = false\n  ): void {\n    if (kindOrEvent === \"start\") {\n      if (callback) {\n        throw new Error(\"start event only accepts 2 arguments\");\n      }\n\n      if (typeof keyOrNodeIDOrEventOrCallback !== \"function\") {\n        throw new Error(\"second argument expected to be a callback\");\n      }\n\n      this.starts.push({\n        placement,\n        callback: keyOrNodeIDOrEventOrCallback as (\n          ctx: EventContext<Context, Kinds>\n        ) => void,\n      });\n\n      return;\n    }\n\n    if (kindOrEvent === \"ready\") {\n      if (callback) {\n        throw new Error(\"ready event only accepts 2 arguments\");\n      }\n\n      if (typeof keyOrNodeIDOrEventOrCallback !== \"function\") {\n        throw new Error(\"second argument expected to be a callback\");\n      }\n\n      this.readys.push({\n        placement,\n        callback: keyOrNodeIDOrEventOrCallback as (\n          ctx: EventContext<Context, Kinds>\n        ) => void,\n      });\n\n      return;\n    }\n\n    if (Object.values(TajribaEvent).includes(kindOrEvent as any)) {\n      if (typeof keyOrNodeIDOrEventOrCallback !== \"function\") {\n        throw new Error(\"second argument expected to be a callback\");\n      }\n\n      this.tajEvents.push({\n        placement,\n        event: <TajribaEvent>kindOrEvent,\n        callback: keyOrNodeIDOrEventOrCallback,\n      });\n\n      return;\n    }\n\n    if (typeof keyOrNodeIDOrEventOrCallback === \"function\") {\n      this.kindListeners.push({\n        placement,\n        kind: kindOrEvent,\n        callback: keyOrNodeIDOrEventOrCallback,\n      });\n    } else {\n      if (typeof keyOrNodeIDOrEventOrCallback !== \"string\") {\n        throw new Error(\"second argument expected to be an attribute key\");\n      }\n      if (typeof callback !== \"function\") {\n        throw new Error(\"third argument expected to be a callback\");\n      }\n\n      if (uniqueCall) {\n        callback = unique(kindOrEvent, placement, callback);\n      }\n\n      this.attributeListeners.push({\n        placement,\n        kind: kindOrEvent,\n        key: keyOrNodeIDOrEventOrCallback,\n        callback,\n      });\n    }\n  }\n}\n\n// Collects event listeners.\nexport class ListenersCollectorProxy<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> extends ListenersCollector<Context, Kinds> {\n  constructor(private coll: ListenersCollector<Context, Kinds>) {\n    super();\n  }\n\n  protected registerListerner(\n    placement: ListernerPlacement,\n    kindOrEvent: string,\n    keyOrNodeIDOrEventOrCallback?:\n      | string\n      | TajribaEvent\n      | EvtCtxCallback<Context, Kinds>\n      | ((ctx: EventContext<Context, Kinds>) => void),\n    callback?: EvtCtxCallback<Context, Kinds>\n  ): void {\n    if (\n      kindOrEvent === \"start\" ||\n      kindOrEvent === \"ready\" ||\n      Object.values(TajribaEvent).includes(kindOrEvent as any) ||\n      typeof keyOrNodeIDOrEventOrCallback === \"function\"\n    ) {\n      throw new Error(\"only attribute listeners can be unique\");\n    }\n\n    super.registerListerner(\n      placement,\n      kindOrEvent,\n      keyOrNodeIDOrEventOrCallback,\n      callback,\n      true\n    );\n\n    while (true) {\n      const listener = this.attributeListeners.pop();\n      if (!listener) {\n        break;\n      }\n\n      this.coll.attributeListeners.push(listener);\n    }\n  }\n}\n\n// Context passed to listerners on new event allowing to subscrive to more data\n// and access data.\nexport interface SubscriptionCollector {\n  scopeSub: (...inputs: Partial<ScopeSubscriptionInput>[]) => void;\n  participantsSub: () => void;\n  transitionsSub: (stepID: string) => void;\n}\n\n// Context passed to listerners on new event allowing to subscrive to more data\n// and access data.\nexport class EventContext<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> {\n  constructor(\n    /** @internal */\n    private subs: SubscriptionCollector,\n    /** @internal */\n    private taj: TajribaAdminAccess,\n    /** @internal */\n    private scopes: Scopes<Context, Kinds>\n  ) {}\n\n  scopesByKind<T extends Scope<Context, Kinds>>(kind: keyof Kinds) {\n    return this.scopes.byKind<T>(kind) as Map<string, T>;\n  }\n\n  scopesByKindID<T extends Scope<Context, Kinds>>(\n    kind: keyof Kinds,\n    id: string\n  ) {\n    return this.scopes.byKind<T>(kind).get(id);\n  }\n\n  scopesByKindMatching<T extends Scope<Context, Kinds>>(\n    kind: keyof Kinds,\n    key: string,\n    val: string\n  ): T[] {\n    const scopes = Array.from(this.scopes.byKind(kind).values());\n    return scopes.filter((s) => s.get(key) === val) as T[];\n  }\n\n  scopeSub(...inputs: Partial<ScopeSubscriptionInput>[]) {\n    for (const input of inputs) {\n      this.subs.scopeSub(input);\n    }\n  }\n\n  participantsSub() {\n    this.subs.participantsSub();\n  }\n\n  transitionsSub(stepID: string) {\n    this.subs.transitionsSub(stepID);\n  }\n\n  // c8 ignore: the TajribaAdminAccess proxy functions are tested elswhere\n  /* c8 ignore next 3 */\n  addScopes(input: AddScopeInput[]) {\n    return this.taj.addScopes(input);\n  }\n\n  /* c8 ignore next 3 */\n  addGroups(input: AddGroupInput[]) {\n    return this.taj.addGroups(input);\n  }\n\n  /* c8 ignore next 3 */\n  addLinks(input: LinkInput[]) {\n    return this.taj.addLinks(input);\n  }\n\n  /* c8 ignore next 3 */\n  addSteps(input: AddStepInput[]) {\n    return this.taj.addSteps(input);\n  }\n\n  /* c8 ignore next 3 */\n  addTransitions(input: TransitionInput[]) {\n    return this.taj.addTransitions(input);\n  }\n\n  protected addFinalizer(cb: Finalizer) {\n    this.taj.addFinalizer(cb);\n  }\n\n  /* c8 ignore next 3 */\n  get globals() {\n    return this.taj.globals;\n  }\n}\n","export interface PromiseHandle<T = void> {\n  promise: Promise<T>;\n  result: (value: T) => void;\n}\n\nexport function promiseHandle<T = void>(): PromiseHandle<T> {\n  let ret = {} as PromiseHandle<T>;\n  ret.promise = new Promise<T>((r) => {\n    ret.result = r;\n  });\n\n  return ret;\n}\n","import { Observable } from \"rxjs\";\nimport { Attribute } from \"../shared/attributes\";\nimport { ScopeConstructor } from \"../shared/scopes\";\nimport { debug, error, warn } from \"../utils/console\";\nimport { AttributeMsg } from \"./attributes\";\nimport {\n  AttributeEventListener,\n  EventContext,\n  EvtCtxCallback,\n  KindEventListener,\n  ListenersCollector,\n  ListernerPlacement,\n  TajEventListener,\n  TajribaEvent,\n} from \"./events\";\nimport { subscribeAsync } from \"./observables\";\nimport { Connection, ConnectionMsg } from \"./participants\";\nimport { promiseHandle, PromiseHandle } from \"./promises\";\nimport { Scope, ScopeMsg } from \"./scopes\";\nimport { Transition } from \"./transitions\";\n\n// Cake triggers callbacks, respecting listener placement\n\nexport interface unsuber {\n  unsubscribe(): void;\n}\n\nexport class Cake<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> {\n  postCallback: (() => Promise<void>) | undefined;\n  private stopped = false;\n  private unsubs: unsuber[] = [];\n\n  constructor(\n    private evtctx: EventContext<Context, Kinds>,\n    private scope: (id: string) => Scope<Context, Kinds> | undefined,\n    private kindSubscription: (\n      kind: keyof Kinds\n    ) => Observable<ScopeMsg<Context, Kinds>>,\n    private attributeSubscription: (\n      kind: keyof Kinds,\n      key: string\n    ) => Observable<AttributeMsg>,\n    private connections: Observable<ConnectionMsg>,\n    private transitions: Observable<Transition>\n  ) {}\n\n  async stop() {\n    this.stopped = true;\n    for (const unsub of this.unsubs) {\n      unsub.unsubscribe();\n    }\n  }\n\n  async add(listeners: ListenersCollector<Context, Kinds>) {\n    for (const start of listeners.starts) {\n      debug(\"start callback\");\n      try {\n        await start.callback(this.evtctx);\n      } catch (err) {\n        prettyPrintError(\"start\", err as Error);\n      }\n\n      if (this.postCallback) {\n        await this.postCallback();\n      }\n    }\n\n    if (listeners.kindListeners.length > 0) {\n      const kindListeners = new Map<\n        keyof Kinds,\n        KindEventListener<EvtCtxCallback<Context, Kinds>>[]\n      >();\n\n      for (const listener of listeners.kindListeners) {\n        const callbacks = kindListeners.get(listener.kind) || [];\n        callbacks.push(listener);\n        callbacks.sort(comparePlacement);\n        kindListeners.set(listener.kind, callbacks);\n      }\n\n      for (const [kind, listeners] of kindListeners) {\n        let kl = this.kindListeners.get(kind) || [];\n        if (this.kindListeners.has(kind)) {\n          const until = this.kindLast.get(kind);\n          if (until) {\n            await this.startKind(kind, () => listeners, until);\n          }\n          kl.push(...listeners);\n          kl.sort(comparePlacement);\n          this.kindListeners.set(kind, kl);\n        } else {\n          this.kindListeners.set(kind, listeners);\n          await this.startKind(kind, () => this.kindListeners.get(kind) || []);\n        }\n      }\n    }\n\n    if (listeners.attributeListeners.length > 0) {\n      const attributeListeners = new Map<\n        string,\n        AttributeEventListener<EvtCtxCallback<Context, Kinds>>[]\n      >();\n\n      for (const listener of listeners.attributeListeners) {\n        const key = listener.kind + \"-\" + listener.key;\n        const callbacks = attributeListeners.get(key) || [];\n        callbacks.push(listener);\n        callbacks.sort(comparePlacement);\n        attributeListeners.set(key, callbacks);\n      }\n\n      for (const [kkey, listeners] of attributeListeners) {\n        const kind = listeners[0]!.kind;\n        const key = listeners[0]!.key;\n        let kl = this.attributeListeners.get(kkey) || [];\n        if (this.attributeListeners.has(kkey)) {\n          const until = this.attributeLast.get(kkey);\n          if (until) {\n            await this.startAttribute(kind, key, () => listeners, until);\n          }\n          kl.push(...listeners);\n          kl.sort(comparePlacement);\n          this.attributeListeners.set(kkey, kl);\n        } else {\n          this.attributeListeners.set(kkey, listeners);\n          await this.startAttribute(\n            kind,\n            key,\n            () => this.attributeListeners.get(kkey) || []\n          );\n        }\n      }\n    }\n\n    for (const listener of listeners.tajEvents) {\n      switch (listener.event) {\n        case TajribaEvent.TransitionAdd: {\n          if (this.transitionEvents.length == 0) {\n            this.startTransitionAdd();\n          }\n\n          this.transitionEvents.push(listener);\n          this.transitionEvents.sort(comparePlacement);\n\n          break;\n        }\n        case TajribaEvent.ParticipantConnect: {\n          if (this.connectedEvents.length == 0) {\n            this.startConnected();\n          }\n\n          for (const [_, conn] of this.connectionsMap) {\n            try {\n              await listener.callback(this.evtctx, {\n                participant: conn.participant,\n              });\n            } catch (err) {\n              prettyPrintError(\"participant connect\", err as Error);\n            }\n\n            if (this.postCallback) {\n              await this.postCallback();\n            }\n          }\n\n          this.connectedEvents.push(listener);\n          this.connectedEvents.sort(comparePlacement);\n\n          break;\n        }\n        case TajribaEvent.ParticipantDisconnect: {\n          if (this.disconnectedEvents.length == 0) {\n            this.startDisconnected();\n          }\n\n          this.disconnectedEvents.push(listener);\n          this.disconnectedEvents.sort(comparePlacement);\n\n          break;\n        }\n        // This is difficult to simulate\n        /* c8 ignore next 3 */\n        default: {\n          error(`unsupported tajriba event listener: ${listener.event}`);\n        }\n      }\n    }\n\n    for (const ready of listeners.readys) {\n      debug(\"ready callback\");\n      try {\n        await ready.callback(this.evtctx);\n      } catch (err) {\n        prettyPrintError(\"ready\", err as Error);\n      }\n    }\n  }\n\n  kindListeners = new Map<\n    keyof Kinds,\n    KindEventListener<EvtCtxCallback<Context, Kinds>>[]\n  >();\n  kindLast = new Map<keyof Kinds, Scope<Context, Kinds>>();\n  async startKind(\n    kind: keyof Kinds,\n    callbacks: () => KindEventListener<EvtCtxCallback<Context, Kinds>>[],\n    until?: Scope<Context, Kinds>\n  ) {\n    let handle: PromiseHandle | undefined = promiseHandle();\n    const unsub = subscribeAsync(\n      this.kindSubscription(kind),\n      async ({ scope, done }) => {\n        if (this.stopped) {\n          if (handle) {\n            handle.result();\n          }\n\n          return;\n        }\n\n        if (scope) {\n          for (const callback of callbacks()) {\n            try {\n              await callback.callback(this.evtctx, { [kind]: scope });\n            } catch (err) {\n              prettyPrintError(kind as string, err as Error);\n            }\n            if (this.postCallback) {\n              await this.postCallback();\n            }\n          }\n\n          if (until) {\n            if (scope === until) {\n              if (handle) {\n                handle.result();\n                handle = undefined;\n              } else {\n                warn(`until kind without handle`);\n              }\n            }\n          } else {\n            this.kindLast.set(kind, scope);\n          }\n        }\n\n        if (!until && done && handle) {\n          handle.result();\n          handle = undefined;\n        }\n      }\n    );\n\n    if (handle) {\n      await handle.promise;\n    }\n\n    if (until) {\n      unsub.unsubscribe();\n    } else {\n      this.unsubs.push(unsub);\n    }\n  }\n\n  attributeListeners = new Map<\n    string,\n    AttributeEventListener<EvtCtxCallback<Context, Kinds>>[]\n  >();\n  attributeLast = new Map<string, Attribute>();\n  async startAttribute(\n    kind: keyof Kinds,\n    key: string,\n    callbacks: () => AttributeEventListener<EvtCtxCallback<Context, Kinds>>[],\n    until?: Attribute\n  ) {\n    let handle: PromiseHandle | undefined = promiseHandle();\n    const unsub = this.attributeSubscription(kind, key).subscribe(\n      async ({ attribute, done }) => {\n        if (this.stopped) {\n          if (handle) {\n            handle.result();\n          }\n\n          return;\n        }\n\n        if (attribute) {\n          const k = <string>kind + \"-\" + key;\n\n          const props: { [key: string]: any } = {\n            [key]: attribute.value,\n            attribute,\n          };\n\n          if (attribute.nodeID) {\n            const scope = this.scope(attribute.nodeID);\n            if (scope) {\n              props[<string>kind] = scope;\n            }\n          }\n\n          for (const callback of callbacks()) {\n            try {\n              await callback.callback(this.evtctx, props);\n            } catch (err) {\n              prettyPrintError(`${kind as string}.${key}`, err as Error);\n            }\n\n            if (this.stopped) {\n              return;\n            }\n\n            if (this.postCallback) {\n              await this.postCallback();\n            }\n\n            if (this.stopped) {\n              return;\n            }\n          }\n\n          if (until) {\n            if (attribute === until) {\n              if (handle) {\n                handle.result();\n                handle = undefined;\n              } else {\n                warn(`until attribute without handle`);\n              }\n            }\n          } else {\n            this.attributeLast.set(k, attribute);\n          }\n        }\n\n        if (!until && done && handle) {\n          handle.result();\n          handle = undefined;\n        }\n      }\n    );\n\n    if (handle) {\n      await handle.promise;\n    }\n\n    if (until) {\n      unsub.unsubscribe();\n    } else {\n      this.unsubs.push(unsub);\n    }\n  }\n\n  transitionEvents: TajEventListener<EvtCtxCallback<Context, Kinds>>[] = [];\n  startTransitionAdd() {\n    const unsub = subscribeAsync(this.transitions, async (transition) => {\n      for (const callback of this.transitionEvents) {\n        if (this.stopped) {\n          return;\n        }\n\n        debug(\n          `transition callback from '${transition.from}' to '${transition.to}'`\n        );\n\n        try {\n          await callback.callback(this.evtctx, {\n            transition,\n            step: transition.step,\n          });\n        } catch (err) {\n          prettyPrintError(\"transition\", err as Error);\n        }\n\n        if (this.postCallback) {\n          await this.postCallback();\n        }\n      }\n    });\n\n    this.unsubs.push(unsub);\n  }\n\n  connectedEvents: TajEventListener<EvtCtxCallback<Context, Kinds>>[] = [];\n  connectionsMap = new Map<string, Connection>();\n  async startConnected() {\n    let handle: PromiseHandle | undefined = promiseHandle();\n    const unsub = subscribeAsync(\n      this.connections,\n      async ({ connection, done }) => {\n        if (this.stopped) {\n          if (handle) {\n            handle.result();\n          }\n\n          return;\n        }\n\n        if (connection) {\n          if (!connection.connected) {\n            return;\n          }\n\n          this.connectionsMap.set(connection.participant.id, connection);\n\n          for (const callback of this.connectedEvents) {\n            debug(`connected callback`);\n\n            try {\n              await callback.callback(this.evtctx, {\n                participant: connection.participant,\n              });\n            } catch (err) {\n              prettyPrintError(\"participant connect\", err as Error);\n            }\n\n            if (this.postCallback) {\n              await this.postCallback();\n            }\n          }\n        }\n\n        if (done && handle) {\n          handle.result();\n          handle = undefined;\n        }\n      }\n    );\n\n    if (handle) {\n      await handle.promise;\n    }\n\n    this.unsubs.push(unsub);\n  }\n\n  disconnectedEvents: TajEventListener<EvtCtxCallback<Context, Kinds>>[] = [];\n  startDisconnected() {\n    const unsub = subscribeAsync(this.connections, async ({ connection }) => {\n      if (this.stopped) {\n        return;\n      }\n\n      if (!connection || connection.connected) {\n        return;\n      }\n\n      this.connectionsMap.delete(connection.participant.id);\n\n      for (const callback of this.disconnectedEvents) {\n        debug(`disconnected callback`);\n\n        try {\n          await callback.callback(this.evtctx, {\n            participant: connection.participant,\n          });\n        } catch (err) {\n          prettyPrintError(\"participant disconnect\", err as Error);\n        }\n\n        if (this.postCallback) {\n          await this.postCallback();\n        }\n      }\n    });\n\n    this.unsubs.push(unsub);\n  }\n}\n\ntype HasPlacement = { placement: ListernerPlacement };\nconst comparePlacement = (a: HasPlacement, b: HasPlacement) =>\n  a.placement - b.placement;\n\nfunction prettyPrintError(location: string, err: Error) {\n  error(`Error caught in \"${location}\" callback:`);\n  error(err);\n}\n","import { SetAttributeInput, SubAttributesPayload } from \"@empirica/tajriba\";\nimport { Observable } from \"rxjs\";\nimport { AttributeOptions } from \"../player\";\nimport { Globals as SharedGlobals } from \"../shared/globals\";\nimport { JsonValue } from \"../utils/json\";\nimport { bsu } from \"../utils/object\";\n\nexport class Globals extends SharedGlobals {\n  constructor(\n    globals: Observable<SubAttributesPayload>,\n    private globalScopeID: string,\n    private setAttributes: (input: SetAttributeInput[]) => Promise<unknown>\n  ) {\n    super(globals);\n  }\n\n  set(key: string, value: JsonValue, ao?: Partial<AttributeOptions>) {\n    let attr = this.attrs.get(key);\n    if (!attr) {\n      attr = bsu();\n      this.attrs.set(key, attr);\n    }\n    attr.next(value);\n\n    const attrProps: SetAttributeInput = {\n      key: key,\n      nodeID: this.globalScopeID,\n      val: JSON.stringify(value),\n    };\n\n    if (ao) {\n      // TODO Fix this. Should check if compatible with existing attribute and\n      // only set fields set on ao.\n      attrProps.private = ao.private;\n      attrProps.protected = ao.protected;\n      attrProps.immutable = ao.immutable;\n      attrProps.append = ao.append;\n      attrProps.index = ao.index;\n    }\n\n    this.setAttributes([attrProps]);\n  }\n}\n","import { EventType, TajribaAdmin } from \"@empirica/tajriba\";\nimport { Subject } from \"rxjs\";\nimport { error } from \"../utils/console\";\nimport { PromiseHandle, promiseHandle } from \"./promises\";\n\nexport interface Participant {\n  id: string;\n  identifier: string;\n}\n\nexport interface Connection {\n  participant: Participant;\n  connected: boolean;\n}\n\nexport interface ConnectionMsg {\n  connection?: Connection;\n  done: boolean;\n}\n\nexport async function participantsSub(\n  taj: TajribaAdmin,\n  connections: Subject<ConnectionMsg>,\n  participants: Map<string, Participant>\n) {\n  let handle: PromiseHandle | undefined = promiseHandle();\n  taj.onEvent({ eventTypes: [EventType.ParticipantConnected] }).subscribe({\n    next({ node, done }) {\n      if (!node) {\n        if (done) {\n          if (handle) {\n            handle?.result();\n\n            connections.next({ done: true });\n          }\n\n          return;\n        }\n        error(`received no participant on connected`);\n\n        return;\n      }\n\n      if (node.__typename !== \"Participant\") {\n        error(`received non-participant on connected`);\n\n        return;\n      }\n\n      const part = {\n        id: node.id,\n        identifier: node.identifier,\n      };\n\n      participants.set(node.id, part);\n\n      connections.next({\n        connection: {\n          participant: part,\n          connected: true,\n        },\n        done,\n      });\n\n      if (handle && done) {\n        handle.result();\n      }\n    },\n  });\n\n  taj.onEvent({ eventTypes: [EventType.ParticipantDisconnect] }).subscribe({\n    next({ node }) {\n      if (!node) {\n        error(`received no participant on disconnect`);\n\n        return;\n      }\n\n      if (node.__typename !== \"Participant\") {\n        error(`received non-participant on disconnect`);\n\n        return;\n      }\n\n      participants.delete(node.id);\n\n      connections.next({\n        connection: {\n          participant: {\n            id: node.id,\n            identifier: node.identifier,\n          },\n          connected: false,\n        },\n        done: true,\n      });\n    },\n  });\n\n  await handle.promise;\n  handle = undefined;\n}\n","import {\n  AddGroupInput,\n  AddScopeInput,\n  AddStepInput,\n  LinkInput,\n  TransitionInput,\n} from \"@empirica/tajriba\";\nimport { Observable, ReplaySubject } from \"rxjs\";\nimport {\n  Scope as SharedScope,\n  ScopeConstructor,\n  ScopeIdent,\n  Scopes as SharedScopes,\n  ScopeUpdate,\n} from \"../shared/scopes\";\nimport { Attributes } from \"./attributes\";\nimport { Finalizer, TajribaAdminAccess } from \"./context\";\n\nexport type ScopeMsg<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> = {\n  scope?: Scope<Context, Kinds>;\n  done: boolean;\n};\n\nexport class Scopes<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> extends SharedScopes<Context, Kinds, Scope<Context, Kinds>> {\n  private kindSubs = new Map<\n    keyof Kinds,\n    ReplaySubject<ScopeMsg<Context, Kinds>>\n  >();\n\n  constructor(\n    scopesObs: Observable<ScopeUpdate>,\n    donesObs: Observable<string[]>,\n    ctx: Context,\n    kinds: Kinds,\n    attributes: Attributes,\n    readonly taj: TajribaAdminAccess\n  ) {\n    super(scopesObs, donesObs, ctx, kinds, attributes);\n  }\n\n  /** @internal */\n  subscribeKind(kind: keyof Kinds): Observable<ScopeMsg<Context, Kinds>> {\n    let sub = this.kindSubs.get(kind);\n    if (!sub) {\n      sub = new ReplaySubject<ScopeMsg<Context, Kinds>>();\n      this.kindSubs.set(kind, sub);\n\n      const scopes = this.byKind(kind);\n\n      setTimeout(() => {\n        if (scopes.size === 0) {\n          sub!.next({ done: true });\n\n          return;\n        }\n\n        let count = 0;\n        for (const [_, scope] of scopes) {\n          count++;\n          sub!.next({ scope, done: scopes.size === count });\n        }\n      }, 0);\n    }\n\n    return sub!;\n  }\n\n  protected next(scopeIDs: string[]) {\n    for (const [_, scopeReplaySubject] of this.scopes) {\n      const scope = scopeReplaySubject.getValue();\n      if (this.newScopes.get(scope.id) && scopeIDs.includes(scope.id)) {\n        const kindSub = this.kindSubs.get(scope.kind);\n        if (kindSub) {\n          kindSub.next({ scope, done: true });\n        }\n        this.newScopes.set(scope.id, false);\n      }\n    }\n\n    super.next(scopeIDs);\n  }\n\n  protected create(\n    scopeClass: ScopeConstructor<Context, Kinds>,\n    scope: ScopeIdent\n  ) {\n    return new scopeClass!(this.ctx, scope, this, this.attributes) as Scope<\n      Context,\n      Kinds\n    >;\n  }\n}\n\nexport class Scope<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> extends SharedScope<Context, Kinds> {\n  /**\n   * @internal\n   */\n  readonly taj: TajribaAdminAccess;\n\n  constructor(\n    ctx: Context,\n    scope: ScopeIdent,\n    private scopes: Scopes<Context, Kinds>,\n    attributes: Attributes\n  ) {\n    super(ctx, scope, attributes);\n    this.taj = scopes.taj;\n  }\n\n  protected scopeByID<T extends Scope<Context, Kinds>>(\n    id: string\n  ): T | undefined {\n    return this.scopes.scope(id) as T | undefined;\n  }\n\n  protected scopeByKey<T extends Scope<Context, Kinds>>(\n    key: string\n  ): T | undefined {\n    const id = this.get(key);\n    if (!id || typeof id !== \"string\") {\n      return;\n    }\n\n    return this.scopes.scope(id) as T | undefined;\n  }\n\n  protected scopesByKind<T extends Scope<Context, Kinds>>(\n    kind: keyof Kinds\n  ): Map<string, T> {\n    return this.scopes.byKind<T>(kind) as Map<string, T>;\n  }\n\n  protected scopesByKindID<T extends Scope<Context, Kinds>>(\n    kind: keyof Kinds,\n    id: string\n  ): T | undefined {\n    return this.scopes.byKind<T>(kind).get(id);\n  }\n\n  protected scopesByKindMatching<T extends Scope<Context, Kinds>>(\n    kind: keyof Kinds,\n    key: string,\n    val: string\n  ): T[] {\n    const scopes = Array.from(this.scopes.byKind(kind).values());\n    return scopes.filter((s) => s.get(key) === val) as T[];\n  }\n\n  protected addScopes(input: AddScopeInput[]) {\n    return this.taj.addScopes(input);\n  }\n\n  protected addGroups(input: AddGroupInput[]) {\n    return this.taj.addGroups(input);\n  }\n\n  protected addLinks(input: LinkInput[]) {\n    return this.taj.addLinks(input);\n  }\n\n  protected addSteps(input: AddStepInput[]) {\n    return this.taj.addSteps(input);\n  }\n\n  protected addTransitions(input: TransitionInput[]) {\n    return this.taj.addTransitions(input);\n  }\n\n  protected addFinalizer(cb: Finalizer) {\n    this.taj.addFinalizer(cb);\n  }\n\n  /**\n   * @internal\n   */\n  get globals() {\n    return this.taj.globals;\n  }\n}\n","import { BehaviorSubject, Observable } from \"rxjs\";\nimport { Attribute, AttributeOptions, Attributes } from \"../shared/attributes\";\nimport { Constructor } from \"../shared/helpers\";\nimport { warn } from \"../utils/console\";\nimport { JsonValue } from \"../utils/json\";\n\nexport type Attributable = {\n  get: (key: string) => JsonValue | undefined;\n  getAttribute: (key: string) => Attribute | undefined;\n  set: (key: string, value: JsonValue, ao?: Partial<AttributeOptions>) => void;\n  append: (\n    key: string,\n    value: JsonValue,\n    ao?: Partial<AttributeOptions>\n  ) => void;\n};\n\nexport interface ScopeIdent {\n  id: string;\n  kind: string;\n}\n\nexport interface ScopeUpdate {\n  scope: ScopeIdent;\n  removed: boolean;\n}\n\nexport type ScopeConstructor<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> = Constructor<Scope<Context, Kinds>>;\n\nexport class Scopes<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> },\n  Skope extends Scope<Context, Kinds> = Scope<Context, Kinds>\n> {\n  protected scopes = new Map<string, BehaviorSubject<Skope>>();\n  // newScopes is used to track scopes that have appeared for the first time.\n  protected newScopes = new Map<string, boolean>();\n  protected scopesByKind = new Map<keyof Kinds, Map<string, Skope>>();\n  protected kindUpdated = new Set<keyof Kinds>();\n\n  constructor(\n    scopesObs: Observable<ScopeUpdate>,\n    donesObs: Observable<string[]>,\n    protected ctx: Context,\n    protected kinds: Kinds,\n    protected attributes: Attributes\n  ) {\n    scopesObs.subscribe({\n      next: ({ scope, removed }) => {\n        this.update(scope, removed);\n      },\n    });\n\n    donesObs.subscribe({\n      next: (scopeIDs) => {\n        this.next(scopeIDs);\n      },\n    });\n  }\n\n  scope(id: string): Skope | undefined {\n    return this.scopes.get(id)?.getValue();\n  }\n\n  scopeObs(id: string): Observable<Skope> | undefined {\n    return this.scopes.get(id);\n  }\n\n  byKind<T extends Skope>(kind: keyof Kinds) {\n    let map = this.scopesByKind.get(kind);\n    if (!map) {\n      map = new Map();\n      this.scopesByKind.set(kind, map);\n    }\n\n    return map! as Map<string, T>;\n  }\n\n  kindWasUpdated(kind: keyof Kinds): boolean {\n    return this.kindUpdated.has(kind);\n  }\n\n  protected next(scopeIDs: string[]) {\n    this.kindUpdated.clear();\n    for (const [_, scopeSubject] of this.scopes) {\n      const scope = scopeSubject.getValue();\n      if (\n        (scope._updated || this.attributes.scopeWasUpdated(scope.id)) &&\n        scopeIDs.includes(scope.id)\n      ) {\n        scope._updated = false;\n        scopeSubject.next(scope);\n      }\n    }\n  }\n\n  protected update(scope: ScopeIdent, removed: boolean) {\n    const existing = this.scopes.get(scope.id)?.getValue();\n\n    if (removed) {\n      if (!existing) {\n        warn(\"scopes: missing scope on removal\", scope.id, scope.kind);\n\n        return;\n      }\n\n      existing._deleted = true;\n      existing._updated = true;\n      this.scopes.delete(scope.id);\n\n      if (!scope.kind) {\n        warn(\"scopes: scope missing kind on scope on removal\");\n\n        return;\n      }\n\n      const kind = scope.kind as keyof Kinds;\n\n      // Using ! because scopes by kind must exist, since this scope was found.\n      this.scopesByKind.get(kind)!.delete(scope.id);\n\n      this.kindUpdated.add(kind);\n\n      return;\n    }\n\n    if (existing) {\n      existing._deleted = false;\n      return;\n    }\n\n    if (!scope.kind) {\n      warn(\"scopes: scope missing kind on scope\");\n\n      return;\n    }\n\n    const kind = scope.kind as keyof Kinds;\n    const scopeClass = this.kinds[kind];\n    if (!scopeClass) {\n      warn(`scopes: unknown scope kind: ${scope.kind}`);\n\n      return;\n    }\n\n    const obj = this.create(scopeClass, scope);\n    const subj = new BehaviorSubject(obj);\n    this.scopes.set(scope.id, subj);\n    this.newScopes.set(scope.id, true);\n\n    let skm = this.scopesByKind.get(kind);\n    if (!skm) {\n      skm = new Map();\n      this.scopesByKind.set(kind, skm);\n    }\n\n    skm.set(scope.id, obj);\n\n    obj._updated = true;\n    this.kindUpdated.add(kind);\n  }\n\n  protected create(\n    scopeClass: ScopeConstructor<Context, Kinds>,\n    scope: ScopeIdent\n  ) {\n    return new scopeClass!(this.ctx, scope, this.attributes) as Skope;\n  }\n}\n\nexport type AttributeInput = {\n  key: string;\n  value: JsonValue;\n  ao?: Partial<AttributeOptions>;\n};\n\nexport class Scope<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> {\n  /**\n   * @internal\n   */\n  _deleted = false;\n\n  /**\n   * @internal\n   */\n  _updated = false;\n\n  constructor(\n    /**\n     * @internal\n     */\n    readonly ctx: Context,\n    /**\n     * @internal\n     */\n    readonly scope: ScopeIdent,\n    /**\n     * @internal\n     */\n    protected attributes: Attributes\n  ) {}\n\n  get id() {\n    return this.scope.id;\n  }\n\n  /**\n   * @internal\n   */\n  get kind() {\n    // Using ! because we don't allow scopes without kind\n    return this.scope.kind!;\n  }\n\n  get(key: string): JsonValue | undefined {\n    return this.attributes.attribute(this.scope.id, key).value;\n  }\n\n  getAttribute(key: string): Attribute | undefined {\n    return this.attributes.attribute(this.scope.id, key);\n  }\n\n  obs(key: string): Observable<JsonValue | undefined> {\n    return this.attributes.attribute(this.scope.id, key).obs;\n  }\n\n  set(values: AttributeInput[]): void;\n  set(key: string, value: JsonValue, ao?: Partial<AttributeOptions>): void;\n  set(\n    keyOrAttributes: string | AttributeInput[],\n    value?: JsonValue,\n    ao?: Partial<AttributeOptions>\n  ) {\n    if (typeof keyOrAttributes === \"string\") {\n      if (value === undefined) {\n        value = null;\n      }\n\n      return this.attributes\n        .attribute(this.scope.id, keyOrAttributes)\n        .set(value, ao);\n    }\n\n    const nextProps = [];\n    for (const attr of keyOrAttributes) {\n      nextProps.push(\n        this.attributes\n          .attribute(this.scope.id, attr.key)\n          ._prepSet(attr.value, attr.ao)\n      );\n    }\n\n    this.attributes.setAttributes(nextProps);\n  }\n\n  append(key: string, value: JsonValue, ao?: Partial<AttributeOptions>) {\n    if (!ao) {\n      ao = {};\n    }\n    ao.append = true;\n\n    return this.attributes.attribute(this.scope.id, key).set(value, ao);\n  }\n\n  inspect() {\n    const attrs = this.attributes.attributes(this.scope.id);\n\n    const out: { [key: string]: JsonValue | undefined } = {};\n    for (const attr of attrs) {\n      out[attr.key] = attr.value;\n    }\n\n    return out;\n  }\n\n  /**\n   * @internal\n   */\n  hasUpdated() {\n    return this._updated || this.attributes.scopeWasUpdated(this.id);\n  }\n}\n","import { ScopeConstructor } from \"../shared/scopes\";\n\nexport type KV = {\n  key: string;\n  val: string;\n};\n\nfunction kvstr(kv: KV) {\n  return kv.key + \"-\" + kv.val;\n}\n\nexport interface ScopeSubscriptionInput {\n  /** ids of the matching Scopes. */\n  ids: string[];\n  /** kinds of the matching Scopes. */\n  kinds: string[];\n  /** keys to Attributes in matching Scope. */\n  keys: string[];\n  /** kvs to Attributes in matching Scope. */\n  kvs: KV[];\n  /** names of the matching Scopes. */\n  names: string[];\n}\n\nexport interface Subs {\n  participants: boolean;\n  scopes: {\n    ids: string[];\n    kinds: string[];\n    names: string[];\n    keys: string[];\n    kvs: KV[];\n  };\n  transitions: string[];\n}\n\n// Tracks what data should be subscribed to.\nexport class Subscriptions<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> {\n  private scopeKinds = new Set<string>();\n  private scopeIDs = new Set<string>();\n  private scopeNames = new Set<string>();\n  private scopeKeys = new Set<string>();\n  private scopeKVSet = new Set<string>();\n  private scopeKVs: KV[] = [];\n  private participantSub = false;\n  private transitionsSubs = new Set<string>();\n  private dirty = false;\n  public last: Subs = {\n    participants: false,\n    scopes: {\n      ids: [],\n      kinds: [],\n      names: [],\n      keys: [],\n      kvs: [],\n    },\n    transitions: [],\n  };\n\n  get subs(): Subs {\n    return {\n      participants: this.participantSub,\n      scopes: {\n        kinds: Array.from(this.scopeKinds.values()),\n        ids: Array.from(this.scopeIDs.values()),\n        names: Array.from(this.scopeNames.values()),\n        keys: Array.from(this.scopeKeys.values()),\n        kvs: [...this.scopeKVs],\n      },\n      transitions: Array.from(this.transitionsSubs.values()),\n    };\n  }\n\n  // newSubs will return only new subs since the last call.\n  newSubs(): Subs | undefined {\n    if (!this.dirty) {\n      return;\n    }\n\n    const current = this.subs;\n    const {\n      scopes: { ids, kinds, names, keys, kvs },\n      participants,\n      transitions,\n    } = this.last;\n\n    const kvsstrs = kvs.map((kv) => kvstr(kv));\n\n    const next = {\n      participants: this.participantSub && !participants,\n      scopes: {\n        ids: current.scopes.ids.filter((id) => !ids.includes(id)),\n        kinds: current.scopes.kinds.filter((kind) => !kinds.includes(kind)),\n        names: current.scopes.names.filter((name) => !names.includes(name)),\n        keys: current.scopes.keys.filter((key) => !keys.includes(key)),\n        kvs: current.scopes.kvs.filter((kv) => !kvsstrs.includes(kvstr(kv))),\n      },\n      transitions: current.transitions.filter(\n        (id) => !transitions.includes(id)\n      ),\n    };\n\n    this.last = current;\n    this.dirty = false;\n\n    return next;\n  }\n\n  scopeSub(input: Partial<ScopeSubscriptionInput>) {\n    if (input.ids) {\n      for (const id of input.ids) {\n        if (!this.scopeIDs.has(id)) {\n          this.scopeIDs.add(id);\n          this.dirty = true;\n        }\n      }\n    }\n\n    if (input.kinds) {\n      for (const id of input.kinds) {\n        if (!this.scopeKinds.has(id)) {\n          this.scopeKinds.add(id);\n          this.dirty = true;\n        }\n      }\n    }\n\n    if (input.names) {\n      for (const name of input.names) {\n        if (!this.scopeNames.has(name)) {\n          this.scopeNames.add(name);\n          this.dirty = true;\n        }\n      }\n    }\n\n    if (input.keys) {\n      for (const key of input.keys) {\n        if (!this.scopeKeys.has(key)) {\n          this.scopeKeys.add(key);\n          this.dirty = true;\n        }\n      }\n    }\n\n    if (input.kvs) {\n      for (const kv of input.kvs) {\n        const kvKey = kvstr(kv);\n        if (!this.scopeKVSet.has(kvKey)) {\n          this.scopeKVSet.add(kvKey);\n          this.scopeKVs.push(kv);\n          this.dirty = true;\n        }\n      }\n    }\n  }\n\n  participantsSub() {\n    if (!this.participantSub) {\n      this.dirty = true;\n      this.participantSub = true;\n    }\n  }\n\n  transitionsSub(nodeID: string) {\n    if (!this.transitionsSubs.has(nodeID)) {\n      this.transitionsSubs.add(nodeID);\n      this.dirty = true;\n    }\n  }\n}\n","import { EventType, State, TajribaAdmin } from \"@empirica/tajriba\";\nimport { Subject } from \"rxjs\";\nimport { error } from \"../utils/console\";\n\nexport interface Step {\n  id: string;\n  state: State;\n  duration: number;\n  startedAt?: number;\n  endedAt?: number;\n}\n\nexport interface Transition {\n  id: string;\n  from: State;\n  to: State;\n  step: Step;\n}\n\nexport function transitionsSub(\n  taj: TajribaAdmin,\n  transitions: Subject<Transition>,\n  nodeID: string\n) {\n  taj.onEvent({ eventTypes: [EventType.TransitionAdd], nodeID }).subscribe({\n    next({ node }) {\n      if (!node) {\n        return;\n      }\n\n      if (node.__typename !== \"Transition\") {\n        error(`received non-transition`);\n\n        return;\n      }\n\n      if (node.node.__typename !== \"Step\") {\n        error(`received non-step transition`, node.node);\n\n        return;\n      }\n\n      transitions.next({\n        id: node.id,\n        to: node.to,\n        from: node.from,\n        step: {\n          id: node.node.id,\n          duration: node.node.duration,\n          state: node.node.state,\n        },\n      });\n    },\n  });\n}\n","import fs from \"fs/promises\";\nimport path from \"path\";\nimport { BehaviorSubject, merge, Observable, SubscriptionLike } from \"rxjs\";\nimport { TajribaConnection } from \"../shared/tajriba_connection\";\nimport { error } from \"../utils/console\";\nimport { bsu } from \"../utils/object\";\nimport { subscribeAsync } from \"./observables\";\n\nexport class TokenProvider {\n  private sub: SubscriptionLike | undefined;\n  readonly tokens = bsu<string | null>(undefined);\n\n  constructor(\n    taj: TajribaConnection,\n    storage: SavedTokenStorage,\n    serviceName: string,\n    serviceRegistrationToken: string\n  ) {\n    let connected = false;\n    let token: string | null | undefined;\n    this.sub = subscribeAsync(\n      merge(taj.connected, storage.tokens),\n      async (tokenOrConnected) => {\n        if (typeof tokenOrConnected === \"boolean\") {\n          connected = tokenOrConnected;\n        } else {\n          token = tokenOrConnected;\n        }\n\n        if (token) {\n          this.tokens.next(token);\n          return;\n        }\n\n        if (!connected) {\n          return;\n        }\n\n        if (token === undefined) {\n          return;\n        }\n\n        try {\n          const t = await taj.tajriba.registerService(\n            serviceName,\n            serviceRegistrationToken\n          );\n\n          if (t) {\n            storage.updateToken(t);\n          }\n        } catch (err) {\n          error(`token: register service ${(err as Error).message}`);\n          return;\n        }\n      }\n    );\n  }\n\n  get token() {\n    return this.tokens.getValue();\n  }\n\n  // When stopped, cannot be restarted\n  stop() {\n    this.sub?.unsubscribe();\n    this.sub = undefined;\n  }\n}\n\nexport interface SavedTokenStorage {\n  tokens: BehaviorSubject<string | null | undefined>;\n  updateToken: (token: string) => Promise<void>;\n  clearToken: () => Promise<void>;\n}\n\nexport class MemTokenStorage {\n  tokens = new BehaviorSubject<string | null | undefined>(null);\n\n  async updateToken(token: string) {\n    this.tokens.next(token);\n  }\n\n  async clearToken() {\n    this.tokens.next(undefined);\n  }\n}\n\nexport class FileTokenStorage {\n  private _tokens = bsu<string | null>(null);\n\n  private constructor(\n    protected serviceTokenFile: string,\n    resetToken: Observable<void>\n  ) {\n    resetToken.subscribe({\n      next: () => {\n        this.clearToken();\n      },\n    });\n  }\n\n  static async init(serviceTokenFile: string, resetToken: Observable<void>) {\n    const p = new this(serviceTokenFile, resetToken);\n\n    const token = await p.readToken();\n    if (token) {\n      p._tokens.next(token);\n    }\n\n    return p;\n  }\n\n  private async readToken() {\n    try {\n      const data = await fs.readFile(this.serviceTokenFile, {\n        encoding: \"utf8\",\n      });\n\n      if (data.length > 0) {\n        return data;\n      }\n    } catch (err) {\n      const e = err as NodeJS.ErrnoException;\n      if (e.code !== \"ENOENT\") {\n        error(`token: read token file ${e.message}`);\n      }\n    }\n\n    return;\n  }\n\n  private async writeToken(token: string) {\n    try {\n      // Ensure directory exists\n      const dir = path.dirname(this.serviceTokenFile);\n      await fs.mkdir(dir, { recursive: true });\n      await fs.writeFile(this.serviceTokenFile, token);\n    } catch (err) {\n      error(`token: write token file ${(err as Error).message}`);\n    }\n  }\n\n  private async deleteTokenFile() {\n    try {\n      await fs.unlink(this.serviceTokenFile);\n    } catch (err) {\n      error(`token: delete token file ${(err as Error).message}`);\n    }\n  }\n\n  get tokens() {\n    return this._tokens;\n  }\n\n  get token() {\n    return this._tokens.getValue();\n  }\n\n  async updateToken(token: string) {\n    if (token === this._tokens.getValue()) {\n      return;\n    }\n\n    this._tokens.next(token);\n    await this.writeToken(token);\n  }\n\n  async clearToken() {\n    await this.deleteTokenFile();\n\n    if (this.token) {\n      this._tokens.next(undefined);\n    }\n  }\n}\n"],"mappings":"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","names":["Attributes","Globals","Scope","Scopes","import_rxjs","import_rxjs","import_rxjs","error","attr","newAttr","value","Attributes","_","import_rxjs","import_rxjs","val","error","import_rxjs","import_rxjs","TajribaEvent","listeners","Globals","import_tajriba","import_rxjs","import_rxjs","kind","Scopes","Scope","import_tajriba","Attributes","Globals","Scopes","import_promises","import_rxjs","fs","path"]}