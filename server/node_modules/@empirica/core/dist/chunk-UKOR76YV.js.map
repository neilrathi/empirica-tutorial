{"version":3,"sources":["../src/admin/globals.ts","../src/admin/context.ts","../src/admin/runloop.ts","../src/admin/cake.ts","../src/admin/token_file.ts"],"sourcesContent":["import { SetAttributeInput, SubAttributesPayload } from \"@empirica/tajriba\";\nimport { Observable } from \"rxjs\";\nimport { AttributeOptions } from \"../player\";\nimport { Globals as SharedGlobals } from \"../shared/globals\";\nimport { JsonValue } from \"../utils/json\";\nimport { bsu } from \"../utils/object\";\n\nexport class Globals extends SharedGlobals {\n  constructor(\n    globals: Observable<SubAttributesPayload>,\n    private globalScopeID: string,\n    private setAttributes: (input: SetAttributeInput[]) => Promise<unknown>\n  ) {\n    super(globals);\n  }\n\n  set(key: string, value: JsonValue, ao?: Partial<AttributeOptions>) {\n    let attr = this.attrs.get(key);\n    if (!attr) {\n      attr = bsu();\n      this.attrs.set(key, attr);\n    }\n    attr.next(value);\n\n    const attrProps: SetAttributeInput = {\n      key: key,\n      nodeID: this.globalScopeID,\n      val: JSON.stringify(value),\n    };\n\n    if (ao) {\n      // TODO Fix this. Should check if compatible with existing attribute and\n      // only set fields set on ao.\n      attrProps.private = ao.private;\n      attrProps.protected = ao.protected;\n      attrProps.immutable = ao.immutable;\n      attrProps.append = ao.append;\n      attrProps.index = ao.index;\n    }\n\n    this.setAttributes([attrProps]);\n  }\n}\n","import {\n  AddGroupInput,\n  AddScopeInput,\n  AddStepInput,\n  LinkInput,\n  State,\n  TransitionInput,\n} from \"@empirica/tajriba\";\nimport { merge, Subject, SubscriptionLike } from \"rxjs\";\nimport { ScopeConstructor } from \"../shared/scopes\";\nimport { TajribaConnection } from \"../shared/tajriba_connection\";\nimport { error, warn } from \"../utils/console\";\nimport { AdminConnection } from \"./connection\";\nimport { ListenersCollector, Subscriber } from \"./events\";\nimport { Globals } from \"./globals\";\nimport { subscribeAsync } from \"./observables\";\nimport { Runloop } from \"./runloop\";\nimport {\n  FileTokenStorage,\n  MemTokenStorage,\n  SavedTokenStorage,\n  TokenProvider,\n} from \"./token_file\";\n\nexport class AdminContext<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> {\n  readonly tajriba: TajribaConnection;\n  public adminConn: AdminConnection | undefined;\n  private sub?: SubscriptionLike;\n  private runloop: Runloop<Context, Kinds> | undefined;\n  private adminSubs = new Subject<\n    Subscriber<Context, Kinds> | ListenersCollector<Context, Kinds>\n  >();\n  private adminStop = new Subject<void>();\n  private subs: (\n    | Subscriber<Context, Kinds>\n    | ListenersCollector<Context, Kinds>\n  )[] = [];\n\n  private constructor(url: string, private ctx: Context, private kinds: Kinds) {\n    this.tajriba = new TajribaConnection(url);\n  }\n\n  /**\n   * @internal\n   *\n   * NOTE: For testing purposes only.\n   */\n  get _runloop() {\n    return this.runloop;\n  }\n\n  static async init<\n    Context,\n    Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n  >(\n    url: string,\n    tokenFile: string,\n    serviceName: string,\n    serviceRegistrationToken: string,\n    ctx: Context,\n    kinds: Kinds\n  ) {\n    const adminContext = new this(url, ctx, kinds);\n    const reset = new Subject<void>();\n    let strg: SavedTokenStorage;\n    if (tokenFile === \":mem:\") {\n      strg = new MemTokenStorage();\n    } else {\n      strg = await FileTokenStorage.init(tokenFile, reset);\n    }\n\n    const tp = new TokenProvider(\n      adminContext.tajriba,\n      strg,\n      serviceName,\n      serviceRegistrationToken\n    );\n    adminContext.adminConn = new AdminConnection(\n      adminContext.tajriba,\n      tp.tokens,\n      reset.next.bind(reset)\n    );\n\n    adminContext.sub = subscribeAsync(\n      merge(adminContext.tajriba.connected, adminContext.adminConn.connected),\n      async () => {\n        await adminContext.initOrStop();\n      }\n    );\n\n    return adminContext;\n  }\n\n  async stop() {\n    this.sub?.unsubscribe();\n    delete this.sub;\n    await this.stopSubs();\n    this.tajriba.stop();\n    this.adminConn?.stop();\n  }\n\n  register(\n    subscriber: Subscriber<Context, Kinds> | ListenersCollector<Context, Kinds>\n  ) {\n    this.subs.push(subscriber);\n    if (this.runloop) {\n      this.adminSubs.next(subscriber);\n    }\n  }\n\n  private async initOrStop() {\n    // Forcing this.adminConn since adminConn is always created by init().\n    if (\n      this.tajriba.connected.getValue() &&\n      this.adminConn!.connected.getValue()\n    ) {\n      await this.initSubs();\n    } else {\n      await this.stopSubs();\n    }\n  }\n\n  private async initSubs() {\n    if (this.runloop) {\n      return;\n    }\n\n    /* c8 ignore next 5 */\n    if (!this.adminConn) {\n      // This condition is nearly impossible to create\n      warn(\"context: admin not connected\");\n      return;\n    }\n\n    /* c8 ignore next 6 */\n    const tajAdmin = this.adminConn.admin.getValue();\n    if (!tajAdmin) {\n      // This condition is nearly impossible to create\n      warn(\"context: admin not connected\");\n      return;\n    }\n\n    let globalScopeID: string | undefined;\n    try {\n      const scopes = await tajAdmin.scopes({\n        filter: { kinds: [\"global\"] },\n        first: 100,\n      });\n      globalScopeID = scopes!.edges[0]?.node.id;\n      if (!globalScopeID) {\n        warn(\"context: global scopeID not found\");\n\n        return;\n      }\n    } catch (err) {\n      error(`context: global scopeID not fetched: ${err}`);\n\n      return;\n    }\n\n    this.runloop = new Runloop(\n      this.adminConn,\n      this.ctx,\n      this.kinds,\n      globalScopeID,\n      this.adminSubs,\n      this.adminStop\n    );\n\n    for (const sub of this.subs) {\n      this.adminSubs.next(sub);\n    }\n  }\n\n  private async stopSubs() {\n    this.adminStop.next();\n    if (this.runloop) {\n      await this.runloop.stop();\n      this.runloop = undefined;\n    }\n  }\n}\n\nexport interface StepPayload {\n  id: string;\n  duration: number;\n}\n\nexport interface AddLinkPayload {\n  nodes: { id: string }[];\n  participants: { id: string }[];\n}\n\nexport interface AddTransitionPayload {\n  id: string;\n  from: State;\n  to: State;\n}\n\nexport interface AddScopePayload {\n  id: string;\n  name?: string | null | undefined;\n  kind?: string | null | undefined;\n  attributes: {\n    edges: {\n      node: {\n        id: string;\n        private: boolean;\n        protected: boolean;\n        immutable: boolean;\n        key: string;\n        val?: string | null | undefined;\n        index?: number | null | undefined;\n      };\n    }[];\n  };\n}\n\nexport type Finalizer = () => Promise<void>;\n\nexport class TajribaAdminAccess {\n  constructor(\n    readonly addFinalizer: (cb: Finalizer) => void,\n    readonly addScopes: (input: AddScopeInput[]) => Promise<AddScopePayload[]>,\n    readonly addGroups: (input: AddGroupInput[]) => Promise<{ id: string }[]>,\n    readonly addLinks: (input: LinkInput[]) => Promise<AddLinkPayload[]>,\n    readonly addSteps: (input: AddStepInput[]) => Promise<StepPayload[]>,\n    readonly addTransitions: (\n      input: TransitionInput[]\n    ) => Promise<AddTransitionPayload[]>,\n    readonly globals: Globals\n  ) {}\n}\n","import {\n  AddGroupInput,\n  AddScopeInput,\n  AddStepInput,\n  LinkInput,\n  ScopedAttributesInput,\n  SetAttributeInput,\n  TransitionInput,\n} from \"@empirica/tajriba\";\nimport {\n  BehaviorSubject,\n  Observable,\n  ReplaySubject,\n  Subject,\n  Subscription,\n} from \"rxjs\";\nimport { AttributeChange, AttributeUpdate } from \"../shared/attributes\";\nimport { ScopeConstructor, ScopeIdent, ScopeUpdate } from \"../shared/scopes\";\nimport { error, warn } from \"../utils/console\";\nimport { Attributes } from \"./attributes\";\nimport { Cake } from \"./cake\";\nimport { AdminConnection } from \"./connection\";\nimport {\n  AddLinkPayload,\n  AddScopePayload,\n  AddTransitionPayload,\n  Finalizer,\n  StepPayload,\n  TajribaAdminAccess,\n} from \"./context\";\nimport { EventContext, ListenersCollector, Subscriber } from \"./events\";\nimport { Globals } from \"./globals\";\nimport { awaitObsValue, subscribeAsync } from \"./observables\";\nimport { ConnectionMsg, Participant, participantsSub } from \"./participants\";\nimport { Scopes } from \"./scopes\";\nimport { Subs, Subscriptions } from \"./subscriptions\";\nimport { Transition, transitionsSub } from \"./transitions\";\n\nexport class Runloop<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> {\n  private subs = new Subscriptions<Context, Kinds>();\n  private evtctx: EventContext<Context, Kinds>;\n  private participants = new Map<string, Participant>();\n  private connections = new ReplaySubject<ConnectionMsg>();\n  private transitions = new Subject<Transition>();\n  private scopesSub = new Subject<ScopeUpdate>();\n  private attributesSub = new Subject<AttributeUpdate>();\n  private donesSub = new Subject<string[]>();\n  private attributes: Attributes;\n  private finalizers: Finalizer[] = [];\n  private groupPromises: Promise<{ id: string }[]>[] = [];\n  private stepPromises: Promise<StepPayload[]>[] = [];\n  private scopePromises: Promise<AddScopePayload[]>[] = [];\n  private linkPromises: Promise<AddLinkPayload>[] = [];\n  private transitionPromises: Promise<AddTransitionPayload>[] = [];\n  private attributeInputs: SetAttributeInput[] = [];\n  private scopes: Scopes<Context, Kinds>;\n  private cake: Cake<Context, Kinds>;\n  private running = new BehaviorSubject<boolean>(false);\n  private stopped = false;\n\n  constructor(\n    private conn: AdminConnection,\n    private ctx: Context,\n    private kinds: Kinds,\n    globalScopeID: string,\n    subs: Observable<\n      Subscriber<Context, Kinds> | ListenersCollector<Context, Kinds>\n    >,\n    stop: Observable<void>\n  ) {\n    this.attributes = new Attributes(\n      this.attributesSub,\n      this.donesSub,\n      this.setAttributes.bind(this)\n    );\n\n    const mut = new TajribaAdminAccess(\n      this.addFinalizer.bind(this),\n      this.addScopes.bind(this),\n      this.addGroups.bind(this),\n      this.addLinks.bind(this),\n      this.addSteps.bind(this),\n      this.addTransitions.bind(this),\n      new Globals(\n        this.taj.globalAttributes(),\n        globalScopeID,\n        this.setAttributes.bind(this)\n      )\n    );\n\n    this.scopes = new Scopes<Context, Kinds>(\n      this.scopesSub,\n      this.donesSub,\n      this.ctx,\n      this.kinds,\n      this.attributes,\n      mut\n    );\n\n    this.evtctx = new EventContext(this.subs, mut, this.scopes);\n    this.cake = new Cake(\n      this.evtctx,\n      this.scopes.scope.bind(this.scopes),\n      this.scopes.subscribeKind.bind(this.scopes),\n      (kind: keyof Kinds, key: string) =>\n        this.attributes.subscribeAttribute(<string>kind, key),\n      this.connections,\n      this.transitions\n    );\n    this.cake.postCallback = this.postCallback.bind(this, true);\n\n    const subsSub = subscribeAsync(subs, async (subscriber) => {\n      let listeners: ListenersCollector<Context, Kinds>;\n      if (typeof subscriber === \"function\") {\n        listeners = new ListenersCollector<Context, Kinds>();\n        subscriber(listeners);\n      } else {\n        listeners = subscriber;\n      }\n\n      await this.cake.add(listeners);\n    });\n\n    let stopSub: Subscription;\n    stopSub = stop.subscribe({\n      next: () => {\n        subsSub.unsubscribe();\n        stopSub.unsubscribe();\n      },\n    });\n  }\n\n  /**\n   * @internal\n   *\n   * NOTE: For testing purposes only.\n   */\n  get _attributes() {\n    return this.attributes;\n  }\n\n  /**\n   * @internal\n   *\n   * NOTE: For testing purposes only.\n   */\n  get _scopes() {\n    return this.scopes;\n  }\n\n  /**\n   * @internal\n   *\n   * NOTE: For testing purposes only.\n   */\n  async _postCallback() {\n    return await this.postCallback(true);\n  }\n\n  private async postCallback(final: boolean) {\n    if (this.stopped) {\n      return;\n    }\n\n    this.running.next(true);\n\n    const promises: Promise<any>[] = [];\n\n    const subs = this.subs.newSubs();\n    if (subs) {\n      promises.push(this.processNewSub(subs));\n    }\n\n    promises.push(...this.groupPromises);\n    this.groupPromises = [];\n    promises.push(...this.stepPromises);\n    this.stepPromises = [];\n    promises.push(...this.scopePromises);\n    this.scopePromises = [];\n    promises.push(...this.linkPromises);\n    this.linkPromises = [];\n    promises.push(...this.transitionPromises);\n    this.transitionPromises = [];\n\n    if (this.attributeInputs.length > 0) {\n      // If the same key is set twice within the same loop, only send 1\n      // setAttribute update.\n      const uniqueAttrs: { [key: string]: SetAttributeInput } = {};\n      for (const attr of this.attributeInputs) {\n        if (!attr.nodeID) {\n          error(`runloop: attribute without nodeID: ${JSON.stringify(attr)}`);\n          continue;\n        }\n\n        uniqueAttrs[`${attr.nodeID}-${attr.key}`] = attr;\n      }\n\n      const attrs = Object.values(uniqueAttrs);\n\n      promises.push(this.taj.setAttributes(attrs));\n      this.attributeInputs = [];\n    }\n\n    const res = await Promise.allSettled(promises);\n    for (const r of res) {\n      if (r.status === \"rejected\") {\n        warn(`failed load: ${r.reason}`);\n      }\n    }\n\n    const finalizer = this.finalizers.shift();\n    if (finalizer) {\n      await finalizer();\n      await this.postCallback(false);\n    }\n\n    if (final) {\n      this.running.next(false);\n    }\n  }\n\n  async stop() {\n    await this.cake.stop();\n    await awaitObsValue(this.running, false);\n    this.stopped = true;\n  }\n\n  addFinalizer(cb: Finalizer) {\n    this.finalizers.push(cb);\n  }\n\n  async addScopes(inputs: AddScopeInput[]) {\n    if (this.stopped) {\n      // warn(\"addScopes on stopped\", inputs);\n\n      return [];\n    }\n\n    const addScopes = this.taj.addScopes(inputs).catch((err) => {\n      warn(err.message);\n      return [];\n    });\n    this.scopePromises.push(\n      addScopes.then((scopes) => {\n        for (const scope of scopes) {\n          for (const attrEdge of scope.attributes.edges) {\n            this.attributesSub.next({\n              attribute: attrEdge.node as AttributeChange,\n              removed: false,\n            });\n          }\n\n          this.scopesSub.next({\n            scope: scope as ScopeIdent,\n            removed: false,\n          });\n        }\n\n        this.donesSub.next(scopes.map((s) => s.id));\n\n        return scopes;\n      })\n    );\n\n    return addScopes;\n  }\n\n  async addGroups(inputs: AddGroupInput[]) {\n    if (this.stopped) {\n      // warn(\"addGroups on stopped\", inputs);\n\n      return [];\n    }\n\n    const addGroups = this.taj.addGroups(inputs);\n    this.groupPromises.push(addGroups);\n    return addGroups;\n  }\n\n  async addLinks(inputs: LinkInput[]) {\n    if (this.stopped) {\n      // warn(\"addLinks on stopped\", inputs);\n\n      return [];\n    }\n\n    const proms: Promise<AddLinkPayload>[] = [];\n    for (const input of inputs) {\n      const linkPromise = this.taj.addLink(input);\n      this.linkPromises.push(linkPromise);\n      proms.push(linkPromise);\n    }\n\n    return Promise.all(proms);\n  }\n\n  async addSteps(inputs: AddStepInput[]) {\n    if (this.stopped) {\n      // warn(\"addSteps on stopped\", inputs);\n\n      return [];\n    }\n\n    const addSteps = this.taj.addSteps(inputs);\n    this.stepPromises.push(addSteps);\n    return addSteps;\n  }\n\n  async addTransitions(inputs: TransitionInput[]) {\n    if (this.stopped) {\n      // warn(\"addTransitions on stopped\", inputs);\n\n      return [];\n    }\n\n    const proms: Promise<AddTransitionPayload>[] = [];\n    for (const input of inputs) {\n      const transitionPromise = this.taj.transition(input);\n      this.transitionPromises.push(transitionPromise);\n      proms.push(transitionPromise);\n    }\n\n    return Promise.all(proms);\n  }\n\n  async setAttributes(inputs: SetAttributeInput[]) {\n    this.attributeInputs.push(...inputs);\n  }\n\n  // TODO ADD iteration attributes per scope, only first 100...\n  private loadAllScopes(filters: ScopedAttributesInput[], after?: any) {\n    this.taj.scopes({ filter: filters, first: 100, after }).then((conn) => {\n      const scopes: { [key: string]: ScopeIdent } = {};\n      for (const edge of conn?.edges || []) {\n        for (const attrEdge of edge.node.attributes.edges || []) {\n          this.attributesSub.next({\n            attribute: attrEdge.node as AttributeChange,\n            removed: false,\n          });\n        }\n\n        scopes[edge.node.id] = edge.node as ScopeIdent;\n      }\n\n      for (const scope of Object.values(scopes)) {\n        this.scopesSub.next({\n          scope,\n          removed: false,\n        });\n      }\n\n      if (conn?.pageInfo.hasNextPage && conn?.pageInfo.endCursor) {\n        return this.loadAllScopes(filters, conn?.pageInfo.endCursor);\n      }\n    });\n  }\n\n  private async processNewScopesSub(filters: ScopedAttributesInput[]) {\n    if (filters.length === 0) {\n      return;\n    }\n\n    let resolve: (value: void) => void;\n    const prom = new Promise((r) => (resolve = r));\n    this.taj.scopedAttributes(filters).subscribe({\n      next: ({ attribute, scopesUpdated, done }) => {\n        if (attribute) {\n          if (attribute.node.__typename !== \"Scope\") {\n            error(`scoped attribute with non-scope node`);\n            return;\n          }\n\n          this.attributesSub.next({\n            attribute: attribute as AttributeChange,\n            removed: false,\n          });\n\n          this.scopesSub.next({\n            scope: attribute.node as ScopeIdent,\n            removed: false,\n          });\n        }\n\n        if (done) {\n          resolve();\n          if (!scopesUpdated) {\n            error(`scopesUpdated is empty`);\n            return;\n          }\n\n          this.donesSub.next(scopesUpdated);\n        }\n      },\n    });\n\n    // await Promise.all([prom, initProm]);\n    await prom;\n  }\n\n  private async processNewSub(subs: Subs) {\n    const filters: ScopedAttributesInput[] = [];\n    if (subs.scopes.ids.length > 0) {\n      filters.push({ ids: subs.scopes.ids });\n    }\n\n    if (subs.scopes.kinds.length > 0) {\n      filters.push({ kinds: subs.scopes.kinds });\n    }\n\n    if (subs.scopes.names.length > 0) {\n      filters.push({ names: subs.scopes.names });\n    }\n\n    if (subs.scopes.keys.length > 0) {\n      filters.push({ keys: subs.scopes.keys });\n    }\n\n    if (subs.scopes.kvs.length > 0) {\n      filters.push({ kvs: subs.scopes.kvs });\n    }\n\n    if (subs.participants) {\n      await participantsSub(this.taj, this.connections, this.participants);\n    }\n\n    if (subs.transitions.length > 0) {\n      for (const id of subs.transitions) {\n        transitionsSub(this.taj, this.transitions, id);\n      }\n    }\n\n    await this.processNewScopesSub(filters);\n  }\n\n  private get taj() {\n    return this.conn.admin.getValue()!;\n  }\n}\n","import { Observable } from \"rxjs\";\nimport { Attribute } from \"../shared/attributes\";\nimport { ScopeConstructor } from \"../shared/scopes\";\nimport { debug, error, warn } from \"../utils/console\";\nimport { AttributeMsg } from \"./attributes\";\nimport {\n  AttributeEventListener,\n  EventContext,\n  EvtCtxCallback,\n  KindEventListener,\n  ListenersCollector,\n  ListernerPlacement,\n  TajEventListener,\n  TajribaEvent,\n} from \"./events\";\nimport { subscribeAsync } from \"./observables\";\nimport { Connection, ConnectionMsg } from \"./participants\";\nimport { promiseHandle, PromiseHandle } from \"./promises\";\nimport { Scope, ScopeMsg } from \"./scopes\";\nimport { Transition } from \"./transitions\";\n\n// Cake triggers callbacks, respecting listener placement\n\nexport interface unsuber {\n  unsubscribe(): void;\n}\n\nexport class Cake<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> {\n  postCallback: (() => Promise<void>) | undefined;\n  private stopped = false;\n  private unsubs: unsuber[] = [];\n\n  constructor(\n    private evtctx: EventContext<Context, Kinds>,\n    private scope: (id: string) => Scope<Context, Kinds> | undefined,\n    private kindSubscription: (\n      kind: keyof Kinds\n    ) => Observable<ScopeMsg<Context, Kinds>>,\n    private attributeSubscription: (\n      kind: keyof Kinds,\n      key: string\n    ) => Observable<AttributeMsg>,\n    private connections: Observable<ConnectionMsg>,\n    private transitions: Observable<Transition>\n  ) {}\n\n  async stop() {\n    this.stopped = true;\n    for (const unsub of this.unsubs) {\n      unsub.unsubscribe();\n    }\n  }\n\n  async add(listeners: ListenersCollector<Context, Kinds>) {\n    for (const start of listeners.starts) {\n      debug(\"start callback\");\n      try {\n        await start.callback(this.evtctx);\n      } catch (err) {\n        prettyPrintError(\"start\", err as Error);\n      }\n\n      if (this.postCallback) {\n        await this.postCallback();\n      }\n    }\n\n    if (listeners.kindListeners.length > 0) {\n      const kindListeners = new Map<\n        keyof Kinds,\n        KindEventListener<EvtCtxCallback<Context, Kinds>>[]\n      >();\n\n      for (const listener of listeners.kindListeners) {\n        const callbacks = kindListeners.get(listener.kind) || [];\n        callbacks.push(listener);\n        callbacks.sort(comparePlacement);\n        kindListeners.set(listener.kind, callbacks);\n      }\n\n      for (const [kind, listeners] of kindListeners) {\n        let kl = this.kindListeners.get(kind) || [];\n        if (this.kindListeners.has(kind)) {\n          const until = this.kindLast.get(kind);\n          if (until) {\n            await this.startKind(kind, () => listeners, until);\n          }\n          kl.push(...listeners);\n          kl.sort(comparePlacement);\n          this.kindListeners.set(kind, kl);\n        } else {\n          this.kindListeners.set(kind, listeners);\n          await this.startKind(kind, () => this.kindListeners.get(kind) || []);\n        }\n      }\n    }\n\n    if (listeners.attributeListeners.length > 0) {\n      const attributeListeners = new Map<\n        string,\n        AttributeEventListener<EvtCtxCallback<Context, Kinds>>[]\n      >();\n\n      for (const listener of listeners.attributeListeners) {\n        const key = listener.kind + \"-\" + listener.key;\n        const callbacks = attributeListeners.get(key) || [];\n        callbacks.push(listener);\n        callbacks.sort(comparePlacement);\n        attributeListeners.set(key, callbacks);\n      }\n\n      for (const [kkey, listeners] of attributeListeners) {\n        const kind = listeners[0]!.kind;\n        const key = listeners[0]!.key;\n        let kl = this.attributeListeners.get(kkey) || [];\n        if (this.attributeListeners.has(kkey)) {\n          const until = this.attributeLast.get(kkey);\n          if (until) {\n            await this.startAttribute(kind, key, () => listeners, until);\n          }\n          kl.push(...listeners);\n          kl.sort(comparePlacement);\n          this.attributeListeners.set(kkey, kl);\n        } else {\n          this.attributeListeners.set(kkey, listeners);\n          await this.startAttribute(\n            kind,\n            key,\n            () => this.attributeListeners.get(kkey) || []\n          );\n        }\n      }\n    }\n\n    for (const listener of listeners.tajEvents) {\n      switch (listener.event) {\n        case TajribaEvent.TransitionAdd: {\n          if (this.transitionEvents.length == 0) {\n            this.startTransitionAdd();\n          }\n\n          this.transitionEvents.push(listener);\n          this.transitionEvents.sort(comparePlacement);\n\n          break;\n        }\n        case TajribaEvent.ParticipantConnect: {\n          if (this.connectedEvents.length == 0) {\n            this.startConnected();\n          }\n\n          for (const [_, conn] of this.connectionsMap) {\n            try {\n              await listener.callback(this.evtctx, {\n                participant: conn.participant,\n              });\n            } catch (err) {\n              prettyPrintError(\"participant connect\", err as Error);\n            }\n\n            if (this.postCallback) {\n              await this.postCallback();\n            }\n          }\n\n          this.connectedEvents.push(listener);\n          this.connectedEvents.sort(comparePlacement);\n\n          break;\n        }\n        case TajribaEvent.ParticipantDisconnect: {\n          if (this.disconnectedEvents.length == 0) {\n            this.startDisconnected();\n          }\n\n          this.disconnectedEvents.push(listener);\n          this.disconnectedEvents.sort(comparePlacement);\n\n          break;\n        }\n        // This is difficult to simulate\n        /* c8 ignore next 3 */\n        default: {\n          error(`unsupported tajriba event listener: ${listener.event}`);\n        }\n      }\n    }\n\n    for (const ready of listeners.readys) {\n      debug(\"ready callback\");\n      try {\n        await ready.callback(this.evtctx);\n      } catch (err) {\n        prettyPrintError(\"ready\", err as Error);\n      }\n    }\n  }\n\n  kindListeners = new Map<\n    keyof Kinds,\n    KindEventListener<EvtCtxCallback<Context, Kinds>>[]\n  >();\n  kindLast = new Map<keyof Kinds, Scope<Context, Kinds>>();\n  async startKind(\n    kind: keyof Kinds,\n    callbacks: () => KindEventListener<EvtCtxCallback<Context, Kinds>>[],\n    until?: Scope<Context, Kinds>\n  ) {\n    let handle: PromiseHandle | undefined = promiseHandle();\n    const unsub = subscribeAsync(\n      this.kindSubscription(kind),\n      async ({ scope, done }) => {\n        if (this.stopped) {\n          if (handle) {\n            handle.result();\n          }\n\n          return;\n        }\n\n        if (scope) {\n          for (const callback of callbacks()) {\n            try {\n              await callback.callback(this.evtctx, { [kind]: scope });\n            } catch (err) {\n              prettyPrintError(kind as string, err as Error);\n            }\n            if (this.postCallback) {\n              await this.postCallback();\n            }\n          }\n\n          if (until) {\n            if (scope === until) {\n              if (handle) {\n                handle.result();\n                handle = undefined;\n              } else {\n                warn(`until kind without handle`);\n              }\n            }\n          } else {\n            this.kindLast.set(kind, scope);\n          }\n        }\n\n        if (!until && done && handle) {\n          handle.result();\n          handle = undefined;\n        }\n      }\n    );\n\n    if (handle) {\n      await handle.promise;\n    }\n\n    if (until) {\n      unsub.unsubscribe();\n    } else {\n      this.unsubs.push(unsub);\n    }\n  }\n\n  attributeListeners = new Map<\n    string,\n    AttributeEventListener<EvtCtxCallback<Context, Kinds>>[]\n  >();\n  attributeLast = new Map<string, Attribute>();\n  async startAttribute(\n    kind: keyof Kinds,\n    key: string,\n    callbacks: () => AttributeEventListener<EvtCtxCallback<Context, Kinds>>[],\n    until?: Attribute\n  ) {\n    let handle: PromiseHandle | undefined = promiseHandle();\n    const unsub = this.attributeSubscription(kind, key).subscribe(\n      async ({ attribute, done }) => {\n        if (this.stopped) {\n          if (handle) {\n            handle.result();\n          }\n\n          return;\n        }\n\n        if (attribute) {\n          const k = <string>kind + \"-\" + key;\n\n          const props: { [key: string]: any } = {\n            [key]: attribute.value,\n            attribute,\n          };\n\n          if (attribute.nodeID) {\n            const scope = this.scope(attribute.nodeID);\n            if (scope) {\n              props[<string>kind] = scope;\n            }\n          }\n\n          for (const callback of callbacks()) {\n            try {\n              await callback.callback(this.evtctx, props);\n            } catch (err) {\n              prettyPrintError(`${kind as string}.${key}`, err as Error);\n            }\n\n            if (this.stopped) {\n              return;\n            }\n\n            if (this.postCallback) {\n              await this.postCallback();\n            }\n\n            if (this.stopped) {\n              return;\n            }\n          }\n\n          if (until) {\n            if (attribute === until) {\n              if (handle) {\n                handle.result();\n                handle = undefined;\n              } else {\n                warn(`until attribute without handle`);\n              }\n            }\n          } else {\n            this.attributeLast.set(k, attribute);\n          }\n        }\n\n        if (!until && done && handle) {\n          handle.result();\n          handle = undefined;\n        }\n      }\n    );\n\n    if (handle) {\n      await handle.promise;\n    }\n\n    if (until) {\n      unsub.unsubscribe();\n    } else {\n      this.unsubs.push(unsub);\n    }\n  }\n\n  transitionEvents: TajEventListener<EvtCtxCallback<Context, Kinds>>[] = [];\n  startTransitionAdd() {\n    const unsub = subscribeAsync(this.transitions, async (transition) => {\n      for (const callback of this.transitionEvents) {\n        if (this.stopped) {\n          return;\n        }\n\n        debug(\n          `transition callback from '${transition.from}' to '${transition.to}'`\n        );\n\n        try {\n          await callback.callback(this.evtctx, {\n            transition,\n            step: transition.step,\n          });\n        } catch (err) {\n          prettyPrintError(\"transition\", err as Error);\n        }\n\n        if (this.postCallback) {\n          await this.postCallback();\n        }\n      }\n    });\n\n    this.unsubs.push(unsub);\n  }\n\n  connectedEvents: TajEventListener<EvtCtxCallback<Context, Kinds>>[] = [];\n  connectionsMap = new Map<string, Connection>();\n  async startConnected() {\n    let handle: PromiseHandle | undefined = promiseHandle();\n    const unsub = subscribeAsync(\n      this.connections,\n      async ({ connection, done }) => {\n        if (this.stopped) {\n          if (handle) {\n            handle.result();\n          }\n\n          return;\n        }\n\n        if (connection) {\n          if (!connection.connected) {\n            return;\n          }\n\n          this.connectionsMap.set(connection.participant.id, connection);\n\n          for (const callback of this.connectedEvents) {\n            debug(`connected callback`);\n\n            try {\n              await callback.callback(this.evtctx, {\n                participant: connection.participant,\n              });\n            } catch (err) {\n              prettyPrintError(\"participant connect\", err as Error);\n            }\n\n            if (this.postCallback) {\n              await this.postCallback();\n            }\n          }\n        }\n\n        if (done && handle) {\n          handle.result();\n          handle = undefined;\n        }\n      }\n    );\n\n    if (handle) {\n      await handle.promise;\n    }\n\n    this.unsubs.push(unsub);\n  }\n\n  disconnectedEvents: TajEventListener<EvtCtxCallback<Context, Kinds>>[] = [];\n  startDisconnected() {\n    const unsub = subscribeAsync(this.connections, async ({ connection }) => {\n      if (this.stopped) {\n        return;\n      }\n\n      if (!connection || connection.connected) {\n        return;\n      }\n\n      this.connectionsMap.delete(connection.participant.id);\n\n      for (const callback of this.disconnectedEvents) {\n        debug(`disconnected callback`);\n\n        try {\n          await callback.callback(this.evtctx, {\n            participant: connection.participant,\n          });\n        } catch (err) {\n          prettyPrintError(\"participant disconnect\", err as Error);\n        }\n\n        if (this.postCallback) {\n          await this.postCallback();\n        }\n      }\n    });\n\n    this.unsubs.push(unsub);\n  }\n}\n\ntype HasPlacement = { placement: ListernerPlacement };\nconst comparePlacement = (a: HasPlacement, b: HasPlacement) =>\n  a.placement - b.placement;\n\nfunction prettyPrintError(location: string, err: Error) {\n  error(`Error caught in \"${location}\" callback:`);\n  error(err);\n}\n","import fs from \"fs/promises\";\nimport path from \"path\";\nimport { BehaviorSubject, merge, Observable, SubscriptionLike } from \"rxjs\";\nimport { TajribaConnection } from \"../shared/tajriba_connection\";\nimport { error } from \"../utils/console\";\nimport { bsu } from \"../utils/object\";\nimport { subscribeAsync } from \"./observables\";\n\nexport class TokenProvider {\n  private sub: SubscriptionLike | undefined;\n  readonly tokens = bsu<string | null>(undefined);\n\n  constructor(\n    taj: TajribaConnection,\n    storage: SavedTokenStorage,\n    serviceName: string,\n    serviceRegistrationToken: string\n  ) {\n    let connected = false;\n    let token: string | null | undefined;\n    this.sub = subscribeAsync(\n      merge(taj.connected, storage.tokens),\n      async (tokenOrConnected) => {\n        if (typeof tokenOrConnected === \"boolean\") {\n          connected = tokenOrConnected;\n        } else {\n          token = tokenOrConnected;\n        }\n\n        if (token) {\n          this.tokens.next(token);\n          return;\n        }\n\n        if (!connected) {\n          return;\n        }\n\n        if (token === undefined) {\n          return;\n        }\n\n        try {\n          const t = await taj.tajriba.registerService(\n            serviceName,\n            serviceRegistrationToken\n          );\n\n          if (t) {\n            storage.updateToken(t);\n          }\n        } catch (err) {\n          error(`token: register service ${(err as Error).message}`);\n          return;\n        }\n      }\n    );\n  }\n\n  get token() {\n    return this.tokens.getValue();\n  }\n\n  // When stopped, cannot be restarted\n  stop() {\n    this.sub?.unsubscribe();\n    this.sub = undefined;\n  }\n}\n\nexport interface SavedTokenStorage {\n  tokens: BehaviorSubject<string | null | undefined>;\n  updateToken: (token: string) => Promise<void>;\n  clearToken: () => Promise<void>;\n}\n\nexport class MemTokenStorage {\n  tokens = new BehaviorSubject<string | null | undefined>(null);\n\n  async updateToken(token: string) {\n    this.tokens.next(token);\n  }\n\n  async clearToken() {\n    this.tokens.next(undefined);\n  }\n}\n\nexport class FileTokenStorage {\n  private _tokens = bsu<string | null>(null);\n\n  private constructor(\n    protected serviceTokenFile: string,\n    resetToken: Observable<void>\n  ) {\n    resetToken.subscribe({\n      next: () => {\n        this.clearToken();\n      },\n    });\n  }\n\n  static async init(serviceTokenFile: string, resetToken: Observable<void>) {\n    const p = new this(serviceTokenFile, resetToken);\n\n    const token = await p.readToken();\n    if (token) {\n      p._tokens.next(token);\n    }\n\n    return p;\n  }\n\n  private async readToken() {\n    try {\n      const data = await fs.readFile(this.serviceTokenFile, {\n        encoding: \"utf8\",\n      });\n\n      if (data.length > 0) {\n        return data;\n      }\n    } catch (err) {\n      const e = err as NodeJS.ErrnoException;\n      if (e.code !== \"ENOENT\") {\n        error(`token: read token file ${e.message}`);\n      }\n    }\n\n    return;\n  }\n\n  private async writeToken(token: string) {\n    try {\n      // Ensure directory exists\n      const dir = path.dirname(this.serviceTokenFile);\n      await fs.mkdir(dir, { recursive: true });\n      await fs.writeFile(this.serviceTokenFile, token);\n    } catch (err) {\n      error(`token: write token file ${(err as Error).message}`);\n    }\n  }\n\n  private async deleteTokenFile() {\n    try {\n      await fs.unlink(this.serviceTokenFile);\n    } catch (err) {\n      error(`token: delete token file ${(err as Error).message}`);\n    }\n  }\n\n  get tokens() {\n    return this._tokens;\n  }\n\n  get token() {\n    return this._tokens.getValue();\n  }\n\n  async updateToken(token: string) {\n    if (token === this._tokens.getValue()) {\n      return;\n    }\n\n    this._tokens.next(token);\n    await this.writeToken(token);\n  }\n\n  async clearToken() {\n    await this.deleteTokenFile();\n\n    if (this.token) {\n      this._tokens.next(undefined);\n    }\n  }\n}\n"],"mappings":"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","names":["Globals","merge","Subject","listeners","Globals","BehaviorSubject","BehaviorSubject","Subject","merge"]}