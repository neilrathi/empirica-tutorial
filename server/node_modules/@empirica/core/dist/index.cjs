"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../../node_modules/fs.realpath/old.js
var require_old = __commonJS({
  "../../../node_modules/fs.realpath/old.js"(exports) {
    var pathModule = require("path");
    var isWindows = process.platform === "win32";
    var fs = require("fs");
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    var normalize = pathModule.normalize;
    if (isWindows) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports.realpathSync = function realpathSync(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs.lstatSync(base);
          knownHard[base] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          resolvedLink = cache[base];
        } else {
          var stat = fs.lstatSync(base);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            continue;
          }
          var linkTarget = null;
          if (!isWindows) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs.statSync(base);
            linkTarget = fs.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base] = resolvedLink;
          if (!isWindows)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    exports.realpath = function realpath(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs.lstat(base, function(err) {
            if (err)
              return cb(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          return gotResolvedLink(cache[base]);
        }
        return fs.lstat(base, gotStat);
      }
      function gotStat(err, stat) {
        if (err)
          return cb(err);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          return process.nextTick(LOOP);
        }
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs.stat(base, function(err2) {
          if (err2)
            return cb(err2);
          fs.readlink(base, function(err3, target) {
            if (!isWindows)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base2) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base2] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
  }
});

// ../../../node_modules/fs.realpath/index.js
var require_fs = __commonJS({
  "../../../node_modules/fs.realpath/index.js"(exports, module2) {
    module2.exports = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync;
    realpath.realpathSync = realpathSync;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs = require("fs");
    var origRealpath = fs.realpath;
    var origRealpathSync = fs.realpathSync;
    var version = process.version;
    var ok = /^v[0-5]\./.test(version);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs.realpath = realpath;
      fs.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs.realpath = origRealpath;
      fs.realpathSync = origRealpathSync;
    }
  }
});

// ../../../node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "../../../node_modules/concat-map/index.js"(exports, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// ../../../node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "../../../node_modules/balanced-match/index.js"(exports, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// ../../../node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "../../../node_modules/brace-expansion/index.js"(exports, module2) {
    var concatMap2 = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z6 = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z6 + c.slice(1);
                else
                  c = z6 + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap2(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// ../../../node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "../../../node_modules/minimatch/minimatch.js"(exports, module2) {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path = function() {
      try {
        return require("path");
      } catch (e) {
      }
    }() || {
      sep: "/"
    };
    minimatch.sep = path.sep;
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      b = b || {};
      var t = {};
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      m.Minimatch.defaults = function defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      };
      m.filter = function filter2(pattern, options) {
        return orig.filter(pattern, ext(def, options));
      };
      m.defaults = function defaults(options) {
        return orig.defaults(ext(def, options));
      };
      m.makeRe = function makeRe2(pattern, options) {
        return orig.makeRe(pattern, ext(def, options));
      };
      m.braceExpand = function braceExpand2(pattern, options) {
        return orig.braceExpand(pattern, ext(def, options));
      };
      m.match = function(list, pattern, options) {
        return orig.match(list, pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      assertValidPattern(pattern);
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      assertValidPattern(pattern);
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (!options.allowWindowsEscape && path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = function debug2() {
          console.error.apply(console, arguments);
        };
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    }
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = function(pattern) {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    Minimatch.prototype.parse = parse;
    var SUBPARSE = {};
    function parse(pattern, isSub) {
      assertValidPattern(pattern);
      var options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/": {
            return false;
          }
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case "[":
        case ".":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = function match(f, partial) {
      if (typeof partial === "undefined")
        partial = this.partial;
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path.sep !== "/") {
        f = f.split(path.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    };
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// ../../../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../../../node_modules/inherits/inherits_browser.js"(exports, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../../../node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "../../../node_modules/inherits/inherits.js"(exports, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// ../../../node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS({
  "../../../node_modules/path-is-absolute/index.js"(exports, module2) {
    "use strict";
    function posix(path) {
      return path.charAt(0) === "/";
    }
    function win32(path) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  }
});

// ../../../node_modules/glob/common.js
var require_common = __commonJS({
  "../../../node_modules/glob/common.js"(exports) {
    exports.setopts = setopts;
    exports.ownProp = ownProp;
    exports.makeAbs = makeAbs;
    exports.finish = finish;
    exports.mark = mark;
    exports.isIgnored = isIgnored;
    exports.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var fs = require("fs");
    var path = require("path");
    var minimatch = require_minimatch();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasort(a, b) {
      return a.localeCompare(b, "en");
    }
    function setupIgnores(self2, options) {
      self2.ignore = options.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self2, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self2.silent = !!options.silent;
      self2.pattern = pattern;
      self2.strict = options.strict !== false;
      self2.realpath = !!options.realpath;
      self2.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
      self2.follow = !!options.follow;
      self2.dot = !!options.dot;
      self2.mark = !!options.mark;
      self2.nodir = !!options.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options.sync;
      self2.nounique = !!options.nounique;
      self2.nonull = !!options.nonull;
      self2.nosort = !!options.nosort;
      self2.nocase = !!options.nocase;
      self2.stat = !!options.stat;
      self2.noprocess = !!options.noprocess;
      self2.absolute = !!options.absolute;
      self2.fs = options.fs || fs;
      self2.maxLength = options.maxLength || Infinity;
      self2.cache = options.cache || /* @__PURE__ */ Object.create(null);
      self2.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
      self2.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self2, options);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self2.cwd = cwd;
      else {
        self2.cwd = path.resolve(options.cwd);
        self2.changedCwd = self2.cwd !== cwd;
      }
      self2.root = options.root || path.resolve(self2.cwd, "/");
      self2.root = path.resolve(self2.root);
      if (process.platform === "win32")
        self2.root = self2.root.replace(/\\/g, "/");
      self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
      if (process.platform === "win32")
        self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
      self2.nomount = !!options.nomount;
      options.nonegate = true;
      options.nocomment = true;
      options.allowWindowsEscape = false;
      self2.minimatch = new Minimatch(pattern, options);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i = 0, l = self2.matches.length; i < l; i++) {
        var matches = self2.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal = self2.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(alphasort);
      if (self2.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self2._mark(all[i]);
        }
        if (self2.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self2, m2);
        });
      self2.found = all;
    }
    function mark(self2, p) {
      var abs = makeAbs(self2, p);
      var c = self2.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self2, m);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self2, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path.join(self2.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self2.changedCwd) {
        abs = path.resolve(self2.cwd, f);
      } else {
        abs = path.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
    function childrenIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
  }
});

// ../../../node_modules/glob/sync.js
var require_sync = __commonJS({
  "../../../node_modules/glob/sync.js"(exports, module2) {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob().Glob;
    var util = require("util");
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert.ok(this instanceof GlobSync);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index) {
          var set = self2.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var p in matchset) {
            try {
              p = self2._makeAbs(p);
              var real = rp.realpathSync(p, self2.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self2._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert.ok(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      if (isIgnored(this, e))
        return;
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs;
      }
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error2 = new Error(er.code + " invalid cwd " + this.cwd);
            error2.path = this.cwd;
            error2.code = er.code;
            throw error2;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = this.fs.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat = this.fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});

// ../../../node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "../../../node_modules/wrappy/wrappy.js"(exports, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// ../../../node_modules/once/once.js
var require_once = __commonJS({
  "../../../node_modules/once/once.js"(exports, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// ../../../node_modules/inflight/inflight.js
var require_inflight = __commonJS({
  "../../../node_modules/inflight/inflight.js"(exports, module2) {
    var wrappy = require_wrappy();
    var reqs = /* @__PURE__ */ Object.create(null);
    var once = require_once();
    module2.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array = [];
      for (var i = 0; i < length; i++)
        array[i] = args[i];
      return array;
    }
  }
});

// ../../../node_modules/glob/glob.js
var require_glob = __commonJS({
  "../../../node_modules/glob/glob.js"(exports, module2) {
    module2.exports = glob;
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var inherits = require_inherits();
    var EE = require("events").EventEmitter;
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self2 = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self2._processing;
        if (self2._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self2._finish();
            });
          } else {
            self2._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self2 = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self2 = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
      found.forEach(function(p, i) {
        p = self2._makeAbs(p);
        rp.realpath(p, self2.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self2.emit("error", er);
          if (--n === 0) {
            self2.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs;
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        self2.fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb();
        } else
          self2._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self2 = this;
      self2.fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self2, abs, cb) {
      return function(er, entries) {
        if (er)
          self2._readdirError(abs, er, cb);
        else
          self2._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error2 = new Error(er.code + " invalid cwd " + this.cwd);
            error2.path = this.cwd;
            error2.code = er.code;
            this.emit("error", error2);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self2 = this;
      this._stat(prefix, function(er, exists) {
        self2._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        self2.fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return self2.fs.stat(abs, function(er2, stat2) {
            if (er2)
              self2._stat2(f, abs, null, lstat, cb);
            else
              self2._stat2(f, abs, er2, stat2, cb);
          });
        } else {
          self2._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
        return cb(null, false, stat);
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat);
    };
  }
});

// ../../../node_modules/rimraf/rimraf.js
var require_rimraf = __commonJS({
  "../../../node_modules/rimraf/rimraf.js"(exports, module2) {
    var assert = require("assert");
    var path = require("path");
    var fs = require("fs");
    var glob = void 0;
    try {
      glob = require_glob();
    } catch (_err) {
    }
    var defaultGlobOpts = {
      nosort: true,
      silent: true
    };
    var timeout2 = 0;
    var isWindows = process.platform === "win32";
    var defaults = (options) => {
      const methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach((m) => {
        options[m] = options[m] || fs[m];
        m = m + "Sync";
        options[m] = options[m] || fs[m];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
      options.emfileWait = options.emfileWait || 1e3;
      if (options.glob === false) {
        options.disableGlob = true;
      }
      if (options.disableGlob !== true && glob === void 0) {
        throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
      }
      options.disableGlob = options.disableGlob || false;
      options.glob = options.glob || defaultGlobOpts;
    };
    var rimraf = (p, options, cb) => {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert.equal(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      defaults(options);
      let busyTries = 0;
      let errState = null;
      let n = 0;
      const next = (er) => {
        errState = errState || er;
        if (--n === 0)
          cb(errState);
      };
      const afterGlob = (er, results) => {
        if (er)
          return cb(er);
        n = results.length;
        if (n === 0)
          return cb();
        results.forEach((p2) => {
          const CB = (er2) => {
            if (er2) {
              if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
                busyTries++;
                return setTimeout(() => rimraf_(p2, options, CB), busyTries * 100);
              }
              if (er2.code === "EMFILE" && timeout2 < options.emfileWait) {
                return setTimeout(() => rimraf_(p2, options, CB), timeout2++);
              }
              if (er2.code === "ENOENT")
                er2 = null;
            }
            timeout2 = 0;
            next(er2);
          };
          rimraf_(p2, options, CB);
        });
      };
      if (options.disableGlob || !glob.hasMagic(p))
        return afterGlob(null, [p]);
      options.lstat(p, (er, stat) => {
        if (!er)
          return afterGlob(null, [p]);
        glob(p, options.glob, afterGlob);
      });
    };
    var rimraf_ = (p, options, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p, (er, st) => {
        if (er && er.code === "ENOENT")
          return cb(null);
        if (er && er.code === "EPERM" && isWindows)
          fixWinEPERM(p, options, er, cb);
        if (st && st.isDirectory())
          return rmdir(p, options, er, cb);
        options.unlink(p, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT")
              return cb(null);
            if (er2.code === "EPERM")
              return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
            if (er2.code === "EISDIR")
              return rmdir(p, options, er2, cb);
          }
          return cb(er2);
        });
      });
    };
    var fixWinEPERM = (p, options, er, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.chmod(p, 438, (er2) => {
        if (er2)
          cb(er2.code === "ENOENT" ? null : er);
        else
          options.stat(p, (er3, stats) => {
            if (er3)
              cb(er3.code === "ENOENT" ? null : er);
            else if (stats.isDirectory())
              rmdir(p, options, er, cb);
            else
              options.unlink(p, cb);
          });
      });
    };
    var fixWinEPERMSync = (p, options, er) => {
      assert(p);
      assert(options);
      try {
        options.chmodSync(p, 438);
      } catch (er2) {
        if (er2.code === "ENOENT")
          return;
        else
          throw er;
      }
      let stats;
      try {
        stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT")
          return;
        else
          throw er;
      }
      if (stats.isDirectory())
        rmdirSync(p, options, er);
      else
        options.unlinkSync(p);
    };
    var rmdir = (p, options, originalEr, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.rmdir(p, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
          rmkids(p, options, cb);
        else if (er && er.code === "ENOTDIR")
          cb(originalEr);
        else
          cb(er);
      });
    };
    var rmkids = (p, options, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        if (n === 0)
          return options.rmdir(p, cb);
        let errState;
        files.forEach((f) => {
          rimraf(path.join(p, f), options, (er2) => {
            if (errState)
              return;
            if (er2)
              return cb(errState = er2);
            if (--n === 0)
              options.rmdir(p, cb);
          });
        });
      });
    };
    var rimrafSync = (p, options) => {
      options = options || {};
      defaults(options);
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      let results;
      if (options.disableGlob || !glob.hasMagic(p)) {
        results = [p];
      } else {
        try {
          options.lstatSync(p);
          results = [p];
        } catch (er) {
          results = glob.sync(p, options.glob);
        }
      }
      if (!results.length)
        return;
      for (let i = 0; i < results.length; i++) {
        const p2 = results[i];
        let st;
        try {
          st = options.lstatSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM" && isWindows)
            fixWinEPERMSync(p2, options, er);
        }
        try {
          if (st && st.isDirectory())
            rmdirSync(p2, options, null);
          else
            options.unlinkSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM")
            return isWindows ? fixWinEPERMSync(p2, options, er) : rmdirSync(p2, options, er);
          if (er.code !== "EISDIR")
            throw er;
          rmdirSync(p2, options, er);
        }
      }
    };
    var rmdirSync = (p, options, originalEr) => {
      assert(p);
      assert(options);
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "ENOTDIR")
          throw originalEr;
        if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
          rmkidsSync(p, options);
      }
    };
    var rmkidsSync = (p, options) => {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach((f) => rimrafSync(path.join(p, f), options));
      const retries = isWindows ? 100 : 1;
      let i = 0;
      do {
        let threw = true;
        try {
          const ret = options.rmdirSync(p, options);
          threw = false;
          return ret;
        } finally {
          if (++i < retries && threw)
            continue;
        }
      } while (true);
    };
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
  }
});

// node_modules/tmp/lib/tmp.js
var require_tmp = __commonJS({
  "node_modules/tmp/lib/tmp.js"(exports, module2) {
    var fs = require("fs");
    var os = require("os");
    var path = require("path");
    var crypto = require("crypto");
    var _c = { fs: fs.constants, os: os.constants };
    var rimraf = require_rimraf();
    var RANDOM_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    var TEMPLATE_PATTERN = /XXXXXX/;
    var DEFAULT_TRIES = 3;
    var CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR);
    var IS_WIN32 = os.platform() === "win32";
    var EBADF = _c.EBADF || _c.os.errno.EBADF;
    var ENOENT = _c.ENOENT || _c.os.errno.ENOENT;
    var DIR_MODE = 448;
    var FILE_MODE = 384;
    var EXIT = "exit";
    var _removeObjects = [];
    var FN_RMDIR_SYNC = fs.rmdirSync.bind(fs);
    var FN_RIMRAF_SYNC = rimraf.sync;
    var _gracefulCleanup = false;
    function tmpName(options, callback) {
      const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
      try {
        _assertAndSanitizeOptions(opts);
      } catch (err) {
        return cb(err);
      }
      let tries = opts.tries;
      (function _getUniqueName() {
        try {
          const name = _generateTmpName(opts);
          fs.stat(name, function(err) {
            if (!err) {
              if (tries-- > 0)
                return _getUniqueName();
              return cb(new Error("Could not get a unique tmp filename, max tries reached " + name));
            }
            cb(null, name);
          });
        } catch (err) {
          cb(err);
        }
      })();
    }
    function tmpNameSync(options) {
      const args = _parseArguments(options), opts = args[0];
      _assertAndSanitizeOptions(opts);
      let tries = opts.tries;
      do {
        const name = _generateTmpName(opts);
        try {
          fs.statSync(name);
        } catch (e) {
          return name;
        }
      } while (tries-- > 0);
      throw new Error("Could not get a unique tmp filename, max tries reached");
    }
    function file(options, callback) {
      const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
      tmpName(opts, function _tmpNameCreated(err, name) {
        if (err)
          return cb(err);
        fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err2, fd) {
          if (err2)
            return cb(err2);
          if (opts.discardDescriptor) {
            return fs.close(fd, function _discardCallback(possibleErr) {
              return cb(possibleErr, name, void 0, _prepareTmpFileRemoveCallback(name, -1, opts, false));
            });
          } else {
            const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
            cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));
          }
        });
      });
    }
    function fileSync(options) {
      const args = _parseArguments(options), opts = args[0];
      const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
      const name = tmpNameSync(opts);
      var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
      if (opts.discardDescriptor) {
        fs.closeSync(fd);
        fd = void 0;
      }
      return {
        name,
        fd,
        removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)
      };
    }
    function dir(options, callback) {
      const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
      tmpName(opts, function _tmpNameCreated(err, name) {
        if (err)
          return cb(err);
        fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err2) {
          if (err2)
            return cb(err2);
          cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));
        });
      });
    }
    function dirSync(options) {
      const args = _parseArguments(options), opts = args[0];
      const name = tmpNameSync(opts);
      fs.mkdirSync(name, opts.mode || DIR_MODE);
      return {
        name,
        removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)
      };
    }
    function _removeFileAsync(fdPath, next) {
      const _handler = function(err) {
        if (err && !_isENOENT(err)) {
          return next(err);
        }
        next();
      };
      if (0 <= fdPath[0])
        fs.close(fdPath[0], function() {
          fs.unlink(fdPath[1], _handler);
        });
      else
        fs.unlink(fdPath[1], _handler);
    }
    function _removeFileSync(fdPath) {
      let rethrownException = null;
      try {
        if (0 <= fdPath[0])
          fs.closeSync(fdPath[0]);
      } catch (e) {
        if (!_isEBADF(e) && !_isENOENT(e))
          throw e;
      } finally {
        try {
          fs.unlinkSync(fdPath[1]);
        } catch (e) {
          if (!_isENOENT(e))
            rethrownException = e;
        }
      }
      if (rethrownException !== null) {
        throw rethrownException;
      }
    }
    function _prepareTmpFileRemoveCallback(name, fd, opts, sync) {
      const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync);
      const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync, removeCallbackSync);
      if (!opts.keep)
        _removeObjects.unshift(removeCallbackSync);
      return sync ? removeCallbackSync : removeCallback;
    }
    function _prepareTmpDirRemoveCallback(name, opts, sync) {
      const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);
      const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;
      const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);
      const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);
      if (!opts.keep)
        _removeObjects.unshift(removeCallbackSync);
      return sync ? removeCallbackSync : removeCallback;
    }
    function _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {
      let called = false;
      return function _cleanupCallback(next) {
        if (!called) {
          const toRemove = cleanupCallbackSync || _cleanupCallback;
          const index = _removeObjects.indexOf(toRemove);
          if (index >= 0)
            _removeObjects.splice(index, 1);
          called = true;
          if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {
            return removeFunction(fileOrDirName);
          } else {
            return removeFunction(fileOrDirName, next || function() {
            });
          }
        }
      };
    }
    function _garbageCollector() {
      if (!_gracefulCleanup)
        return;
      while (_removeObjects.length) {
        try {
          _removeObjects[0]();
        } catch (e) {
        }
      }
    }
    function _randomChars(howMany) {
      let value = [], rnd = null;
      try {
        rnd = crypto.randomBytes(howMany);
      } catch (e) {
        rnd = crypto.pseudoRandomBytes(howMany);
      }
      for (var i = 0; i < howMany; i++) {
        value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);
      }
      return value.join("");
    }
    function _isBlank(s) {
      return s === null || _isUndefined(s) || !s.trim();
    }
    function _isUndefined(obj) {
      return typeof obj === "undefined";
    }
    function _parseArguments(options, callback) {
      if (typeof options === "function") {
        return [{}, options];
      }
      if (_isUndefined(options)) {
        return [{}, callback];
      }
      const actualOptions = {};
      for (const key of Object.getOwnPropertyNames(options)) {
        actualOptions[key] = options[key];
      }
      return [actualOptions, callback];
    }
    function _generateTmpName(opts) {
      const tmpDir = opts.tmpdir;
      if (!_isUndefined(opts.name))
        return path.join(tmpDir, opts.dir, opts.name);
      if (!_isUndefined(opts.template))
        return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));
      const name = [
        opts.prefix ? opts.prefix : "tmp",
        "-",
        process.pid,
        "-",
        _randomChars(12),
        opts.postfix ? "-" + opts.postfix : ""
      ].join("");
      return path.join(tmpDir, opts.dir, name);
    }
    function _assertAndSanitizeOptions(options) {
      options.tmpdir = _getTmpDir(options);
      const tmpDir = options.tmpdir;
      if (!_isUndefined(options.name))
        _assertIsRelative(options.name, "name", tmpDir);
      if (!_isUndefined(options.dir))
        _assertIsRelative(options.dir, "dir", tmpDir);
      if (!_isUndefined(options.template)) {
        _assertIsRelative(options.template, "template", tmpDir);
        if (!options.template.match(TEMPLATE_PATTERN))
          throw new Error(`Invalid template, found "${options.template}".`);
      }
      if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0)
        throw new Error(`Invalid tries, found "${options.tries}".`);
      options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;
      options.keep = !!options.keep;
      options.detachDescriptor = !!options.detachDescriptor;
      options.discardDescriptor = !!options.discardDescriptor;
      options.unsafeCleanup = !!options.unsafeCleanup;
      options.dir = _isUndefined(options.dir) ? "" : path.relative(tmpDir, _resolvePath(options.dir, tmpDir));
      options.template = _isUndefined(options.template) ? void 0 : path.relative(tmpDir, _resolvePath(options.template, tmpDir));
      options.template = _isBlank(options.template) ? void 0 : path.relative(options.dir, options.template);
      options.name = _isUndefined(options.name) ? void 0 : _sanitizeName(options.name);
      options.prefix = _isUndefined(options.prefix) ? "" : options.prefix;
      options.postfix = _isUndefined(options.postfix) ? "" : options.postfix;
    }
    function _resolvePath(name, tmpDir) {
      const sanitizedName = _sanitizeName(name);
      if (sanitizedName.startsWith(tmpDir)) {
        return path.resolve(sanitizedName);
      } else {
        return path.resolve(path.join(tmpDir, sanitizedName));
      }
    }
    function _sanitizeName(name) {
      if (_isBlank(name)) {
        return name;
      }
      return name.replace(/["']/g, "");
    }
    function _assertIsRelative(name, option, tmpDir) {
      if (option === "name") {
        if (path.isAbsolute(name))
          throw new Error(`${option} option must not contain an absolute path, found "${name}".`);
        let basename = path.basename(name);
        if (basename === ".." || basename === "." || basename !== name)
          throw new Error(`${option} option must not contain a path, found "${name}".`);
      } else {
        if (path.isAbsolute(name) && !name.startsWith(tmpDir)) {
          throw new Error(`${option} option must be relative to "${tmpDir}", found "${name}".`);
        }
        let resolvedPath = _resolvePath(name, tmpDir);
        if (!resolvedPath.startsWith(tmpDir))
          throw new Error(`${option} option must be relative to "${tmpDir}", found "${resolvedPath}".`);
      }
    }
    function _isEBADF(error2) {
      return _isExpectedError(error2, -EBADF, "EBADF");
    }
    function _isENOENT(error2) {
      return _isExpectedError(error2, -ENOENT, "ENOENT");
    }
    function _isExpectedError(error2, errno, code) {
      return IS_WIN32 ? error2.code === code : error2.code === code && error2.errno === errno;
    }
    function setGracefulCleanup() {
      _gracefulCleanup = true;
    }
    function _getTmpDir(options) {
      return path.resolve(_sanitizeName(options && options.tmpdir || os.tmpdir()));
    }
    process.addListener(EXIT, _garbageCollector);
    Object.defineProperty(module2.exports, "tmpdir", {
      enumerable: true,
      configurable: false,
      get: function() {
        return _getTmpDir();
      }
    });
    module2.exports.dir = dir;
    module2.exports.dirSync = dirSync;
    module2.exports.file = file;
    module2.exports.fileSync = fileSync;
    module2.exports.tmpName = tmpName;
    module2.exports.tmpNameSync = tmpNameSync;
    module2.exports.setGracefulCleanup = setGracefulCleanup;
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Attribute: () => Attribute,
  Attributes: () => Attributes,
  Chat: () => Chat,
  Classic: () => Classic,
  ClassicListenersCollector: () => ClassicListenersCollector,
  ClassicLoader: () => ClassicLoader,
  Consent: () => Consent,
  EmpiricaClassic: () => EmpiricaClassic,
  EmpiricaContext: () => EmpiricaContext,
  EmpiricaMenu: () => EmpiricaMenu,
  EmpiricaParticipant: () => EmpiricaParticipant,
  Finished: () => Finished,
  Game: () => Game2,
  Globals: () => Globals,
  ListenersCollector: () => ListenersCollector,
  Loading: () => Loading,
  Lobby: () => Lobby2,
  Logo: () => Logo,
  LogsMock: () => LogsMock,
  NoGames: () => NoGames,
  ParticipantContext: () => ParticipantContext,
  Player: () => Player3,
  PlayerCreate: () => PlayerCreate,
  PlayerGame: () => PlayerGame2,
  PlayerRound: () => PlayerRound2,
  PlayerStage: () => PlayerStage3,
  Quiz: () => Quiz,
  Round: () => Round2,
  Scope: () => Scope3,
  Scopes: () => Scopes3,
  Slider: () => Slider,
  Stage: () => Stage2,
  Step: () => Step2,
  Steps: () => Steps,
  Sweeper: () => Sweeper,
  TajribaConnection: () => TajribaConnection,
  TajribaProvider: () => TajribaProvider,
  captureLogs: () => captureLogs,
  captureLogsAsync: () => captureLogsAsync,
  classicKinds: () => classicKinds,
  createNewParticipant: () => createNewParticipant,
  debug: () => debug,
  error: () => error,
  info: () => info,
  isDevelopment: () => isDevelopment,
  isProduction: () => isProduction,
  isTest: () => isTest,
  levels: () => levels,
  log: () => log,
  mockLogging: () => mockLogging,
  setLogLevel: () => setLogLevel,
  stopMockLogging: () => stopMockLogging,
  trace: () => trace,
  useConsent: () => useConsent,
  useGame: () => useGame,
  useGlobal: () => useGlobal,
  usePartModeCtx: () => usePartModeCtx,
  usePartModeCtxKey: () => usePartModeCtxKey,
  useParticipantContext: () => useParticipantContext,
  usePlayer: () => usePlayer,
  usePlayerID: () => usePlayerID,
  usePlayers: () => usePlayers,
  useRound: () => useRound,
  useStage: () => useStage,
  useStageTimer: () => useStageTimer,
  useTajriba: () => useTajriba,
  useTajribaConnected: () => useTajribaConnected,
  useTajribaConnecting: () => useTajribaConnecting,
  warn: () => warn
});
module.exports = __toCommonJS(src_exports);

// src/shared/globals.ts
var import_rxjs = require("rxjs");
var Globals = class {
  constructor(globals) {
    this.attrs = /* @__PURE__ */ new Map();
    this.updates = /* @__PURE__ */ new Map();
    this.self = new import_rxjs.BehaviorSubject(void 0);
    globals.subscribe({
      next: ({ attribute, done }) => {
        if (attribute) {
          let val = void 0;
          if (attribute.val) {
            val = JSON.parse(attribute.val);
          }
          this.updates.set(attribute.key, val);
        }
        if (done) {
          for (const [key, val] of this.updates) {
            this.obs(key).next(val);
          }
          this.updates.clear();
          if (this.self) {
            this.self.next(this);
          }
        }
      }
    });
  }
  get(key) {
    const o = this.attrs.get(key);
    if (o) {
      return o.getValue();
    }
    return void 0;
  }
  obs(key) {
    let o = this.attrs.get(key);
    if (!o) {
      o = new import_rxjs.BehaviorSubject(void 0);
      this.attrs.set(key, o);
    }
    return o;
  }
};

// src/shared/tajriba_connection.ts
var import_tajriba = require("@empirica/tajriba");

// src/utils/object.ts
var import_rxjs2 = require("rxjs");
function bs(init) {
  return new import_rxjs2.BehaviorSubject(init);
}
function bsu(init = void 0) {
  return new import_rxjs2.BehaviorSubject(init);
}
function deepEqual(obj1, obj2) {
  if (obj1 === obj2)
    return true;
  if (isPrimitive(obj1) && isPrimitive(obj2))
    return obj1 === obj2;
  if (Object.keys(obj1).length !== Object.keys(obj2).length)
    return false;
  for (let key in obj1) {
    if (!(key in obj2))
      return false;
    if (!deepEqual(obj1[key], obj2[key]))
      return false;
  }
  return true;
}
function isPrimitive(obj) {
  return obj !== Object(obj);
}

// src/shared/tajriba_connection.ts
var ErrNotConnected = new Error("not connected");
var TajribaConnection = class {
  constructor(url) {
    this.url = url;
    this._connected = bs(false);
    this._connecting = bs(true);
    this._stopped = bs(false);
    this.tajriba = import_tajriba.Tajriba.connect(this.url);
    this._connected.next(this.tajriba.connected);
    this.tajriba.on("connected", () => {
      this._connected.next(true);
      this._connecting.next(false);
    });
    this.tajriba.on("disconnected", () => {
      this._connected.next(false);
      this._connecting.next(true);
    });
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    return this._connected;
  }
  get stopped() {
    return this._stopped;
  }
  async sessionParticipant(token, pident) {
    if (!this._connected.getValue()) {
      throw ErrNotConnected;
    }
    return await this.tajriba.sessionParticipant(token, pident);
  }
  async sessionAdmin(token) {
    if (!this._connected.getValue()) {
      throw ErrNotConnected;
    }
    return await this.tajriba.sessionAdmin(token);
  }
  stop() {
    if (this._stopped.getValue()) {
      return;
    }
    if (this.tajriba) {
      this.tajriba.removeAllListeners("connected");
      this.tajriba.removeAllListeners("disconnected");
      this.tajriba.stop();
    }
    this._connecting.next(false);
    this._connected.next(false);
    this._stopped.next(true);
  }
};

// src/admin/attributes.ts
var import_rxjs4 = require("rxjs");

// src/shared/attributes.ts
var import_rxjs3 = require("rxjs");

// src/utils/console.ts
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
var LogsMock = class {
  constructor() {
    this.logs = [];
  }
  log(line) {
    this.logs.push(line);
  }
  clear() {
    this.logs = [];
  }
};
var logsMock;
function captureLogs(cb) {
  const lm = mockLogging();
  cb();
  const ret = lm.logs;
  stopMockLogging();
  return ret;
}
async function captureLogsAsync(cb) {
  const lm = mockLogging();
  await cb();
  const ret = lm.logs;
  stopMockLogging();
  return ret;
}
function mockLogging() {
  if (!logsMock) {
    logsMock = new LogsMock();
  }
  return logsMock;
}
function stopMockLogging() {
  logsMock = void 0;
}
var colorHex = {
  [1 /* Bold */]: "font-weight: bold",
  [30 /* Black */]: "color: #000000",
  [31 /* Red */]: "color: #cc0000",
  [32 /* Green */]: "color: #4e9a06",
  [33 /* Yellow */]: "color: #c4a000",
  [34 /* Blue */]: "color: #729fcf",
  [35 /* Magenta */]: "color: #75507b",
  [36 /* Cyan */]: "color: #06989a",
  [37 /* White */]: "color: #d3d7cf",
  [90 /* DarkGray */]: "color: #555753"
};
var levels = {
  trace: 0,
  debug: 1,
  log: 2,
  info: 2,
  warn: 3,
  error: 4
};
var reversLevels = {};
for (const key in levels) {
  reversLevels[levels[key]] = key;
}
var currentLevel = 2;
function setLogLevel(level) {
  const lvl = levels[level];
  if (lvl === void 0) {
    return;
  }
  currentLevel = lvl;
}
function formatConsoleDate(date, level) {
  var hour = date.getHours();
  var minutes = date.getMinutes();
  var seconds = date.getSeconds();
  var milliseconds = date.getMilliseconds();
  const str = (hour < 10 ? "0" + hour : hour) + ":" + (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds) + "." + ("00" + milliseconds).slice(-3);
  if (isBrowser) {
    const ts = colorize(str, 90 /* DarkGray */).concat(level);
    return [ts[0] + " " + level[0], ts[1], level[1]];
  }
  return colorize(str, 90 /* DarkGray */).concat(level);
}
var createLogger = (lvl, level) => {
  return (...args) => {
    if (lvl < currentLevel) {
      return;
    }
    if (logsMock) {
      logsMock.log({ level: reversLevels[lvl], args });
      return;
    }
    if (args.length === 1) {
      switch (typeof args[0]) {
        case "string":
          for (const line of args[0].split("\n")) {
            console.log(...formatConsoleDate(/* @__PURE__ */ new Date(), level).concat(line));
          }
          return;
        case "object":
          if (args[0] instanceof Error) {
            const error2 = args[0];
            const prettyErr = error2.name + ": " + error2.message.replace(new RegExp(`^${error2.name}[: ]*`), "") + "\n" + (error2.stack || "").split("\n").map((line) => line.trim()).map((line) => {
              if (line.startsWith(error2.name + ": " + error2.message))
                return null;
              if (line.startsWith("at")) {
                return "  " + line;
              }
              return line;
            }).filter(Boolean).join("\n");
            for (const line of prettyErr.split("\n")) {
              console.log(...formatConsoleDate(/* @__PURE__ */ new Date(), level).concat(line));
            }
            return;
          }
      }
    }
    console.log(...formatConsoleDate(/* @__PURE__ */ new Date(), level).concat(args));
  };
};
function colorize(s, ...cc) {
  if (isBrowser) {
    const attr = [];
    for (const c of cc) {
      attr.push(colorHex[c]);
    }
    return [`%c${s}`, attr.join("; ")];
  }
  let out = "";
  for (const c of cc) {
    out += `\x1B[${c}m`;
  }
  out += `${s}\x1B[0m`;
  return [out];
}
var trace = createLogger(0, colorize("TRC", 35 /* Magenta */));
var debug = createLogger(1, colorize("DBG", 33 /* Yellow */));
var log = createLogger(2, colorize("LOG", 33 /* Yellow */));
var info = createLogger(2, colorize("INF", 32 /* Green */));
var warn = createLogger(3, colorize("WRN", 36 /* Cyan */));
var error = createLogger(4, colorize("ERR", 31 /* Red */, 1 /* Bold */));

// src/shared/attributes.ts
var Attributes = class {
  constructor(attributesObs, donesObs, setAttributes) {
    this.setAttributes = setAttributes;
    this.attrs = /* @__PURE__ */ new Map();
    this.updates = /* @__PURE__ */ new Map();
    attributesObs.subscribe({
      next: ({ attribute, removed }) => {
        this.update(attribute, removed);
      }
    });
    donesObs.subscribe({
      next: (scopeIDs) => {
        this.next(scopeIDs);
      }
    });
  }
  attribute(scopeID, key) {
    let scopeMap = this.attrs.get(scopeID);
    if (!scopeMap) {
      scopeMap = /* @__PURE__ */ new Map();
      this.attrs.set(scopeID, scopeMap);
    }
    let attr = scopeMap.get(key);
    if (!attr) {
      attr = new Attribute(this.setAttributes, scopeID, key);
      scopeMap.set(key, attr);
    }
    return attr;
  }
  attributes(scopeID) {
    let scopeMap = this.attrs.get(scopeID);
    if (!scopeMap) {
      scopeMap = /* @__PURE__ */ new Map();
      this.attrs.set(scopeID, scopeMap);
    }
    return Array.from(scopeMap.values());
  }
  attributePeek(scopeID, key) {
    let scopeUpdateMap = this.updates.get(scopeID);
    if (scopeUpdateMap) {
      const updated = scopeUpdateMap.get(key);
      if (updated) {
        if (typeof updated === "boolean") {
          return;
        } else {
          if (!updated.val) {
            return;
          } else {
            const attr2 = new Attribute(this.setAttributes, scopeID, key);
            attr2._update(updated);
            return attr2;
          }
        }
      }
    }
    let scopeMap = this.attrs.get(scopeID);
    if (!scopeMap) {
      return;
    }
    let attr = scopeMap.get(key);
    if (!attr) {
      return;
    }
    if (attr.value === void 0) {
      return;
    }
    return attr;
  }
  nextAttributeValue(scopeID, key) {
    const attr = this.attributePeek(scopeID, key);
    if (!attr) {
      return;
    }
    return attr.value;
  }
  update(attr, removed) {
    let nodeID = attr.nodeID;
    if (!nodeID) {
      if (!attr.node?.id) {
        error(`new attribute without node ID`);
        return;
      }
      nodeID = attr.node.id;
    }
    let scopeMap = this.updates.get(nodeID);
    if (!scopeMap) {
      scopeMap = /* @__PURE__ */ new Map();
      this.updates.set(nodeID, scopeMap);
    }
    if (removed) {
      scopeMap.set(attr.key, true);
    } else {
      let key = attr.key;
      if (attr.index !== void 0 && attr.index !== null) {
        key = `${key}[${attr.index}]`;
      }
      scopeMap.set(key, attr);
    }
  }
  scopeWasUpdated(scopeID) {
    if (!scopeID) {
      return false;
    }
    return this.updates.has(scopeID);
  }
  next(scopeIDs) {
    for (const [scopeID, attrs2] of this.updates) {
      if (!scopeIDs.includes(scopeID)) {
        continue;
      }
      let scopeMap = this.attrs.get(scopeID);
      if (!scopeMap) {
        scopeMap = /* @__PURE__ */ new Map();
        this.attrs.set(scopeID, scopeMap);
      }
      for (const [key, attrOrDel] of attrs2) {
        if (typeof attrOrDel === "boolean") {
          let attr = scopeMap.get(key);
          if (attr) {
            attr._update(void 0);
          }
        } else {
          let attr = scopeMap.get(attrOrDel.key);
          if (!attr) {
            attr = new Attribute(this.setAttributes, scopeID, attrOrDel.key);
            scopeMap.set(attrOrDel.key, attr);
          }
          attr._update(attrOrDel);
        }
      }
    }
    for (const scopeID of scopeIDs) {
      this.updates.delete(scopeID);
    }
  }
};
var Attribute = class {
  constructor(setAttributes, scopeID, key) {
    this.setAttributes = setAttributes;
    this.scopeID = scopeID;
    this.key = key;
    this.val = new import_rxjs3.BehaviorSubject(void 0);
  }
  get id() {
    return this.attr?.id;
  }
  get createdAt() {
    return this.attr ? new Date(this.attr.createdAt) : null;
  }
  get obs() {
    return this.val;
  }
  get value() {
    return this.val.getValue();
  }
  get nodeID() {
    return this.attr?.nodeID || this.attr?.node?.id;
  }
  // items returns the attribute changes for the current attribute, if it is a
  // vector. Otherwise it returns null;
  get items() {
    if (!this.attrs) {
      return null;
    }
    return this.attrs;
  }
  set(value, ao) {
    const attrProps = this._prepSet(value, ao);
    this.setAttributes([attrProps]);
    trace(`SET ${this.key} = ${value} (${this.scopeID})`);
  }
  _prepSet(value, ao, item) {
    if (!item && ao?.index !== void 0) {
      const index = ao.index;
      if (!this.attrs) {
        this.attrs = [];
      }
      if (index + 1 > (this.attrs?.length || 0)) {
        this.attrs.length = index + 1;
      }
      if (!this.attrs[index]) {
        this.attrs[index] = new Attribute(
          this.setAttributes,
          this.scopeID,
          this.key
        );
      }
      this.attrs[index]._prepSet(value, ao, true);
      const v = this._recalcVectorVal();
      this.val.next(v);
    } else {
      this.val.next(value);
    }
    const attrProps = {
      key: this.key,
      nodeID: this.scopeID,
      val: JSON.stringify(value)
    };
    if (ao) {
      attrProps.private = ao.private;
      attrProps.protected = ao.protected;
      attrProps.immutable = ao.immutable;
      attrProps.append = ao.append;
      attrProps.index = ao.index;
    }
    return attrProps;
  }
  _recalcVectorVal() {
    return this.attrs.map(
      (a) => !a || a.val == void 0 ? null : a.value || null
    );
  }
  // internal only
  _update(attr, item) {
    if (attr && this.attr && this.attr.id === attr.id) {
      return;
    }
    if (attr && attr.vector && !item) {
      if (attr.index === void 0) {
        error(`vector attribute missing index`);
        return;
      }
      if (this.attrs == void 0) {
        this.attrs = [];
      }
      while (this.attrs.length < attr.index + 1) {
        const newAttr2 = new Attribute(
          this.setAttributes,
          this.scopeID,
          this.key
        );
        this.attrs.push(newAttr2);
      }
      const newAttr = new Attribute(this.setAttributes, this.scopeID, this.key);
      newAttr._update(attr, true);
      this.attrs[attr.index] = newAttr;
      const value2 = this._recalcVectorVal();
      this.val.next(value2);
      return;
    }
    this.attr = attr;
    let value = void 0;
    if (this.attr?.val) {
      value = JSON.parse(this.attr.val);
    }
    this.val.next(value);
  }
};

// src/admin/connection.ts
var import_rxjs6 = require("rxjs");

// src/admin/observables.ts
var import_rxjs5 = require("rxjs");
function subscribeAsync(obs, fn) {
  const cancel = new import_rxjs5.Subject();
  obs.pipe((0, import_rxjs5.concatMap)(fn), (0, import_rxjs5.takeUntil)(cancel)).subscribe();
  return {
    closed: false,
    unsubscribe() {
      if (this.closed) {
        warn("closing a closed async observable subscription");
        return;
      }
      this.closed = true;
      cancel.next();
      cancel.unsubscribe();
    }
  };
}

// src/admin/context.ts
var import_rxjs11 = require("rxjs");

// src/admin/runloop.ts
var import_rxjs9 = require("rxjs");

// src/admin/events.ts
var TajribaEvent = /* @__PURE__ */ ((TajribaEvent2) => {
  TajribaEvent2["TransitionAdd"] = "TRANSITION_ADD";
  TajribaEvent2["ParticipantConnect"] = "PARTICIPANT_CONNECT";
  TajribaEvent2["ParticipantDisconnect"] = "PARTICIPANT_DISCONNECT";
  return TajribaEvent2;
})(TajribaEvent || {});
var placementString = /* @__PURE__ */ new Map();
placementString.set(0 /* Before */, "before");
placementString.set(1 /* None */, "on");
placementString.set(2 /* After */, "after");
function PlacementString(placement) {
  return placementString.get(placement);
}
function unique(kind, placement, callback) {
  return async (ctx, props) => {
    const attr = props.attribute;
    const scope = props[kind];
    if (!attr.id || scope.get(`ran-${PlacementString(placement)}-${attr.id}`)) {
      return;
    }
    await callback(ctx, props);
    scope.set(`ran-${PlacementString(placement)}-${attr.id}`, true);
  };
}
var ListenersCollector = class {
  constructor() {
    /** @internal */
    this.starts = [];
    /** @internal */
    this.readys = [];
    /** @internal */
    this.tajEvents = [];
    /** @internal */
    this.kindListeners = [];
    /** @internal */
    this.attributeListeners = [];
  }
  get unique() {
    return new ListenersCollectorProxy(this);
  }
  on(kindOrEvent, keyOrNodeIDOrEventOrCallback, callback) {
    this.registerListerner(
      1 /* None */,
      kindOrEvent,
      keyOrNodeIDOrEventOrCallback,
      callback
    );
  }
  before(kindOrEvent, keyOrNodeIDOrEventOrCallback, callback, uniqueCall) {
    this.registerListerner(
      0 /* Before */,
      kindOrEvent,
      keyOrNodeIDOrEventOrCallback,
      callback,
      uniqueCall
    );
  }
  after(kindOrEvent, keyOrNodeIDOrEventOrCallback, callback, uniqueCall) {
    this.registerListerner(
      2 /* After */,
      kindOrEvent,
      keyOrNodeIDOrEventOrCallback,
      callback,
      uniqueCall
    );
  }
  registerListerner(placement, kindOrEvent, keyOrNodeIDOrEventOrCallback, callback, uniqueCall = false) {
    if (kindOrEvent === "start") {
      if (callback) {
        throw new Error("start event only accepts 2 arguments");
      }
      if (typeof keyOrNodeIDOrEventOrCallback !== "function") {
        throw new Error("second argument expected to be a callback");
      }
      this.starts.push({
        placement,
        callback: keyOrNodeIDOrEventOrCallback
      });
      return;
    }
    if (kindOrEvent === "ready") {
      if (callback) {
        throw new Error("ready event only accepts 2 arguments");
      }
      if (typeof keyOrNodeIDOrEventOrCallback !== "function") {
        throw new Error("second argument expected to be a callback");
      }
      this.readys.push({
        placement,
        callback: keyOrNodeIDOrEventOrCallback
      });
      return;
    }
    if (Object.values(TajribaEvent).includes(kindOrEvent)) {
      if (typeof keyOrNodeIDOrEventOrCallback !== "function") {
        throw new Error("second argument expected to be a callback");
      }
      this.tajEvents.push({
        placement,
        event: kindOrEvent,
        callback: keyOrNodeIDOrEventOrCallback
      });
      return;
    }
    if (typeof keyOrNodeIDOrEventOrCallback === "function") {
      this.kindListeners.push({
        placement,
        kind: kindOrEvent,
        callback: keyOrNodeIDOrEventOrCallback
      });
    } else {
      if (typeof keyOrNodeIDOrEventOrCallback !== "string") {
        throw new Error("second argument expected to be an attribute key");
      }
      if (typeof callback !== "function") {
        throw new Error("third argument expected to be a callback");
      }
      if (uniqueCall) {
        callback = unique(kindOrEvent, placement, callback);
      }
      this.attributeListeners.push({
        placement,
        kind: kindOrEvent,
        key: keyOrNodeIDOrEventOrCallback,
        callback
      });
    }
  }
};
var ListenersCollectorProxy = class extends ListenersCollector {
  constructor(coll) {
    super();
    this.coll = coll;
  }
  registerListerner(placement, kindOrEvent, keyOrNodeIDOrEventOrCallback, callback) {
    if (kindOrEvent === "start" || kindOrEvent === "ready" || Object.values(TajribaEvent).includes(kindOrEvent) || typeof keyOrNodeIDOrEventOrCallback === "function") {
      throw new Error("only attribute listeners can be unique");
    }
    super.registerListerner(
      placement,
      kindOrEvent,
      keyOrNodeIDOrEventOrCallback,
      callback,
      true
    );
    while (true) {
      const listener = this.attributeListeners.pop();
      if (!listener) {
        break;
      }
      this.coll.attributeListeners.push(listener);
    }
  }
};

// src/admin/participants.ts
var import_tajriba2 = require("@empirica/tajriba");

// src/admin/scopes.ts
var import_rxjs8 = require("rxjs");

// src/shared/scopes.ts
var import_rxjs7 = require("rxjs");
var Scopes = class {
  constructor(scopesObs, donesObs, ctx, kinds2, attributes) {
    this.ctx = ctx;
    this.kinds = kinds2;
    this.attributes = attributes;
    this.scopes = /* @__PURE__ */ new Map();
    // newScopes is used to track scopes that have appeared for the first time.
    this.newScopes = /* @__PURE__ */ new Map();
    this.scopesByKind = /* @__PURE__ */ new Map();
    this.kindUpdated = /* @__PURE__ */ new Set();
    scopesObs.subscribe({
      next: ({ scope, removed }) => {
        this.update(scope, removed);
      }
    });
    donesObs.subscribe({
      next: (scopeIDs) => {
        this.next(scopeIDs);
      }
    });
  }
  scope(id) {
    return this.scopes.get(id)?.getValue();
  }
  scopeObs(id) {
    return this.scopes.get(id);
  }
  byKind(kind) {
    let map2 = this.scopesByKind.get(kind);
    if (!map2) {
      map2 = /* @__PURE__ */ new Map();
      this.scopesByKind.set(kind, map2);
    }
    return map2;
  }
  kindWasUpdated(kind) {
    return this.kindUpdated.has(kind);
  }
  next(scopeIDs) {
    this.kindUpdated.clear();
    for (const [_, scopeSubject] of this.scopes) {
      const scope = scopeSubject.getValue();
      if ((scope._updated || this.attributes.scopeWasUpdated(scope.id)) && scopeIDs.includes(scope.id)) {
        scope._updated = false;
        scopeSubject.next(scope);
      }
    }
  }
  update(scope, removed) {
    const existing = this.scopes.get(scope.id)?.getValue();
    if (removed) {
      if (!existing) {
        warn("scopes: missing scope on removal", scope.id, scope.kind);
        return;
      }
      existing._deleted = true;
      existing._updated = true;
      this.scopes.delete(scope.id);
      if (!scope.kind) {
        warn("scopes: scope missing kind on scope on removal");
        return;
      }
      const kind2 = scope.kind;
      this.scopesByKind.get(kind2).delete(scope.id);
      this.kindUpdated.add(kind2);
      return;
    }
    if (existing) {
      existing._deleted = false;
      return;
    }
    if (!scope.kind) {
      warn("scopes: scope missing kind on scope");
      return;
    }
    const kind = scope.kind;
    const scopeClass = this.kinds[kind];
    if (!scopeClass) {
      warn(`scopes: unknown scope kind: ${scope.kind}`);
      return;
    }
    const obj = this.create(scopeClass, scope);
    const subj = new import_rxjs7.BehaviorSubject(obj);
    this.scopes.set(scope.id, subj);
    this.newScopes.set(scope.id, true);
    let skm = this.scopesByKind.get(kind);
    if (!skm) {
      skm = /* @__PURE__ */ new Map();
      this.scopesByKind.set(kind, skm);
    }
    skm.set(scope.id, obj);
    obj._updated = true;
    this.kindUpdated.add(kind);
  }
  create(scopeClass, scope) {
    return new scopeClass(this.ctx, scope, this.attributes);
  }
};
var Scope = class {
  constructor(ctx, scope, attributes) {
    this.ctx = ctx;
    this.scope = scope;
    this.attributes = attributes;
    /**
     * @internal
     */
    this._deleted = false;
    /**
     * @internal
     */
    this._updated = false;
  }
  get id() {
    return this.scope.id;
  }
  /**
   * @internal
   */
  get kind() {
    return this.scope.kind;
  }
  get(key) {
    return this.attributes.attribute(this.scope.id, key).value;
  }
  getAttribute(key) {
    return this.attributes.attribute(this.scope.id, key);
  }
  obs(key) {
    return this.attributes.attribute(this.scope.id, key).obs;
  }
  set(keyOrAttributes, value, ao) {
    if (typeof keyOrAttributes === "string") {
      if (value === void 0) {
        value = null;
      }
      return this.attributes.attribute(this.scope.id, keyOrAttributes).set(value, ao);
    }
    const nextProps = [];
    for (const attr of keyOrAttributes) {
      nextProps.push(
        this.attributes.attribute(this.scope.id, attr.key)._prepSet(attr.value, attr.ao)
      );
    }
    this.attributes.setAttributes(nextProps);
  }
  append(key, value, ao) {
    if (!ao) {
      ao = {};
    }
    ao.append = true;
    return this.attributes.attribute(this.scope.id, key).set(value, ao);
  }
  inspect() {
    const attrs2 = this.attributes.attributes(this.scope.id);
    const out = {};
    for (const attr of attrs2) {
      out[attr.key] = attr.value;
    }
    return out;
  }
  /**
   * @internal
   */
  hasUpdated() {
    return this._updated || this.attributes.scopeWasUpdated(this.id);
  }
};

// src/admin/scopes.ts
var Scope2 = class extends Scope {
  constructor(ctx, scope, scopes, attributes) {
    super(ctx, scope, attributes);
    this.scopes = scopes;
    this.taj = scopes.taj;
  }
  scopeByID(id) {
    return this.scopes.scope(id);
  }
  scopeByKey(key) {
    const id = this.get(key);
    if (!id || typeof id !== "string") {
      return;
    }
    return this.scopes.scope(id);
  }
  scopesByKind(kind) {
    return this.scopes.byKind(kind);
  }
  scopesByKindID(kind, id) {
    return this.scopes.byKind(kind).get(id);
  }
  scopesByKindMatching(kind, key, val) {
    const scopes = Array.from(this.scopes.byKind(kind).values());
    return scopes.filter((s) => s.get(key) === val);
  }
  addScopes(input) {
    return this.taj.addScopes(input);
  }
  addGroups(input) {
    return this.taj.addGroups(input);
  }
  addLinks(input) {
    return this.taj.addLinks(input);
  }
  addSteps(input) {
    return this.taj.addSteps(input);
  }
  addTransitions(input) {
    return this.taj.addTransitions(input);
  }
  addFinalizer(cb) {
    this.taj.addFinalizer(cb);
  }
  /**
   * @internal
   */
  get globals() {
    return this.taj.globals;
  }
};

// src/admin/transitions.ts
var import_tajriba3 = require("@empirica/tajriba");

// src/admin/token_file.ts
var import_rxjs10 = require("rxjs");

// src/admin/classic/api/connection_test_helper.ts
var import_tmp = __toESM(require_tmp(), 1);
import_tmp.default.setGracefulCleanup();

// src/admin/classic/classic.ts
var import_tajriba5 = require("@empirica/tajriba");
var import_zod3 = require("zod");

// src/utils/random.ts
function pickRandom(items) {
  const random = Math.floor(Math.random() * items.length);
  return items[random];
}
function shuffle(a) {
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}
function selectRandom(arr, num) {
  return shuffle(arr.slice()).slice(0, num);
}

// src/admin/classic/helpers.ts
function scopeConstructor(input) {
  return [
    input,
    {
      get(key) {
        const attr = input.attributes?.find((a) => a.key === key);
        if (!attr) {
          return;
        }
        return attr.val ? JSON.parse(attr.val) : void 0;
      },
      set: (key, value, ao) => {
        const attr = input.attributes?.find((a) => a.key === key);
        if (attr) {
          attr.val = JSON.stringify(value);
          return;
        }
        const props = {
          key,
          val: JSON.stringify(value),
          ...ao
        };
        if (!input.attributes) {
          input.attributes = [];
        }
        input.attributes.push(props);
      }
    }
  ];
}
function attrs(attrs2) {
  const result = [];
  for (const attr of attrs2) {
    const {
      append,
      immutable,
      index,
      key,
      nodeID,
      private: privat,
      protected: protecte,
      value
    } = attr;
    result.push({
      append,
      immutable,
      index,
      key,
      nodeID,
      private: privat,
      protected: protecte,
      val: JSON.stringify(value)
    });
  }
  return result;
}

// src/admin/classic/models.ts
var import_tajriba4 = require("@empirica/tajriba");
var import_zod = require("zod");
var isString = import_zod.z.string().parse;
var isOptionalNumber = import_zod.z.number().optional().parse;
var endedStatuses = ["ended", "terminated", "failed"];
var reservedKeys = [
  "batchID",
  "gameID",
  "stageID",
  "roundID",
  "start",
  "ended",
  "timerID"
];
var lobbyConfigSchema = import_zod.z.object({
  kind: import_zod.z.union([import_zod.z.literal("shared"), import_zod.z.literal("individual")]),
  duration: import_zod.z.number().min(1),
  strategy: import_zod.z.union([import_zod.z.literal("fail"), import_zod.z.literal("ignore")]),
  extensions: import_zod.z.number().min(1).optional()
});
var indexSortable = (a, b) => a.get("index") - b.get("index");
var Batch = class extends Scope2 {
  get isRunning() {
    return this.get("status") === "running";
  }
  get games() {
    return this.scopesByKindMatching("game", "batchID", this.id);
  }
  addGame(attributes) {
    if (!Array.isArray(attributes)) {
      const newAttr = [];
      for (const key in attributes) {
        newAttr.push({
          key,
          value: attributes[key]
        });
      }
      attributes = newAttr;
    }
    const [scope, accessors] = scopeConstructor({
      kind: "game",
      attributes: attrs([
        ...attributes.filter((a) => !reservedKeys.includes(a.key)),
        {
          key: "batchID",
          value: this.id,
          immutable: true
        },
        {
          key: "start",
          value: false,
          protected: true
        },
        {
          key: "ended",
          value: false,
          protected: true
        }
      ])
    });
    this.addScopes([scope]);
    return accessors;
  }
  end(reason) {
    if (this.hasEnded) {
      return;
    }
    this.set("status", "ended");
    this.set("endedReason", reason);
  }
  get hasEnded() {
    return endedStatuses.includes(this.get("status"));
  }
  get lobbyConfig() {
    return lobbyConfigSchema.parse(this.get("lobbyConfig"));
  }
};
var BatchOwned = class extends Scope2 {
  get batch() {
    return this.scopeByKey("batchID");
  }
};
var Game = class extends BatchOwned {
  get rounds() {
    const rounds = this.scopesByKindMatching("round", "gameID", this.id);
    rounds.sort(indexSortable);
    return rounds;
  }
  get stages() {
    const stages = this.scopesByKindMatching("stage", "gameID", this.id);
    stages.sort(indexSortable);
    return stages;
  }
  get players() {
    return this.scopesByKindMatching("player", "gameID", this.id);
  }
  get currentStage() {
    return this.scopeByKey("stageID");
  }
  get currentRound() {
    return this.currentStage?.round;
  }
  get hasEnded() {
    return endedStatuses.includes(this.get("status"));
  }
  // The game has started, but it might not be running yet, it might still be in
  // the gameStart callbacks.
  // This will always be true once the game has started (even after the game
  // ends).
  get hasStarted() {
    return Boolean(this.get("start"));
  }
  get hasNotStarted() {
    return !this.hasStarted;
  }
  // Game has passed the gameStart callbacks and is currently running. This will
  // be true until the game ends.
  get isRunning() {
    return this.get("status") === "running";
  }
  get lobbyConfig() {
    return this.batch.lobbyConfig;
  }
  // Starts the game if it is not already started.
  start() {
    if (!this.get("start")) {
      this.set("start", true);
    }
  }
  async assignPlayer(player) {
    if (this.hasEnded) {
      throw new Error("cannot assign player to ended Game");
    }
    const previousGameID = player.get("gameID");
    const previousGameTreatment = player.get("treatment");
    const treatment = this.get("treatment");
    if (!treatment) {
      warn(`game without treatment: ${this.id}`);
    }
    player.set("gameID", this.id);
    if (treatment) {
      player.set("treatment", treatment);
    }
    if (previousGameTreatment && JSON.stringify(previousGameTreatment) !== JSON.stringify(treatment)) {
      if (previousGameID) {
        warn(
          `reassigning player from ${previousGameID} to ${this.id} with different treatments`
        );
      } else {
        warn(`reassigning player to ${this.id} with different treatment`);
      }
    }
    if (previousGameID) {
      await this.scopeByID(previousGameID)?.removePlayer(player);
    }
    await this.addPlayer(player);
  }
  // Add player to running game
  async addPlayer(player) {
    if (!this.isRunning) {
      await this.addLinks([
        {
          link: true,
          participantIDs: [player.participantID],
          nodeIDs: [this.id]
        }
      ]);
      return;
    }
    const otherParticipantIDs = [];
    const groupID = isString(this.get("groupID"));
    const newPlayerNodeIDs = [this.id, groupID];
    const otherNodeIDs = [];
    const stage = this.currentStage;
    if (!stage) {
      return;
    }
    const timerID = stage.get("timerID");
    if (timerID) {
      newPlayerNodeIDs.push(timerID);
    }
    newPlayerNodeIDs.push(stage.id);
    const round = stage.round;
    if (!round) {
      return;
    }
    newPlayerNodeIDs.push(round.id);
    const playerGameID = await this.createPlayerGame(player);
    const playerRoundID = await round.createPlayerRound(player);
    const playerStageID = await stage.createPlayerStage(player);
    if (!playerGameID || !playerRoundID || !playerStageID) {
      return;
    }
    newPlayerNodeIDs.push(player.id);
    newPlayerNodeIDs.push(playerGameID);
    newPlayerNodeIDs.push(playerRoundID);
    newPlayerNodeIDs.push(playerStageID);
    otherNodeIDs.push(player.id);
    otherNodeIDs.push(playerGameID);
    otherNodeIDs.push(playerRoundID);
    otherNodeIDs.push(playerStageID);
    for (const plyr of this.players) {
      if (player !== plyr) {
        newPlayerNodeIDs.push(plyr.id);
        newPlayerNodeIDs.push(isString(plyr.get(`playerGameID-${this.id}`)));
        newPlayerNodeIDs.push(isString(plyr.get(`playerRoundID-${round.id}`)));
        newPlayerNodeIDs.push(isString(plyr.get(`playerStageID-${stage.id}`)));
        otherParticipantIDs.push(plyr.participantID);
      }
    }
    await this.addLinks([
      // Add links for new player with games and other players.
      {
        link: true,
        participantIDs: [player.participantID],
        nodeIDs: newPlayerNodeIDs
      },
      // Add links for other players with new player.
      {
        link: true,
        participantIDs: otherParticipantIDs,
        nodeIDs: otherNodeIDs
      }
    ]);
  }
  // Remove player from running game
  async removePlayer(player) {
    if (!this.isRunning) {
      await this.addLinks([
        {
          link: false,
          participantIDs: [player.participantID],
          nodeIDs: [this.id]
        }
      ]);
      return;
    }
    const participantIDs = [player.participantID];
    const otherParticipantIDs = [];
    const groupID = isString(this.get("groupID"));
    const nodeIDs = [this.id, groupID, player.id];
    const otherNodeIDs = [player.id];
    const stage = this.currentStage;
    if (!stage) {
      return;
    }
    const timerID = stage.get("timerID");
    if (timerID) {
      nodeIDs.push(timerID);
    }
    nodeIDs.push(stage.id);
    const round = stage.round;
    if (!round) {
      return;
    }
    const players = [...this.players, player];
    for (const plyr of players) {
      nodeIDs.push(isString(plyr.get(`playerRoundID-${round.id}`)));
      nodeIDs.push(isString(plyr.get(`playerStageID-${stage.id}`)));
      nodeIDs.push(isString(plyr.get(`playerGameID-${this.id}`)));
      if (player.id !== plyr.id) {
        nodeIDs.push(plyr.id);
        otherParticipantIDs.push(plyr.participantID);
      } else {
        otherNodeIDs.push(isString(plyr.get(`playerRoundID-${round.id}`)));
        otherNodeIDs.push(isString(plyr.get(`playerStageID-${stage.id}`)));
        otherNodeIDs.push(isString(plyr.get(`playerGameID-${this.id}`)));
      }
    }
    await this.addLinks([
      { link: false, participantIDs, nodeIDs },
      {
        link: false,
        participantIDs: otherParticipantIDs,
        nodeIDs: otherNodeIDs
      }
    ]);
  }
  addRound(attributes) {
    if (!Array.isArray(attributes)) {
      const newAttr = [];
      for (const key in attributes) {
        newAttr.push({
          key,
          value: attributes[key]
        });
      }
      attributes = newAttr;
    }
    const batchID = this.get("batchID");
    if (!batchID) {
      throw new Error("missing batch ID on game");
    }
    const game = this;
    const gameID = game.id;
    let roundIndex = isOptionalNumber(this._tmpRoundIndex);
    if (roundIndex === void 0) {
      roundIndex = isOptionalNumber(game.get("roundIndex"));
    }
    if (roundIndex === void 0) {
      roundIndex = -1;
    }
    roundIndex += 1;
    this._tmpRoundIndex = roundIndex;
    game.set("roundIndex", this._tmpRoundIndex);
    const [scope, accessors] = scopeConstructor({
      kind: "round",
      attributes: attrs([
        ...attributes.filter((a) => !reservedKeys.includes(a.key)),
        {
          key: "index",
          value: roundIndex,
          immutable: true
        },
        {
          key: "gameID",
          value: gameID,
          immutable: true
        },
        {
          key: "batchID",
          value: batchID,
          immutable: true
        },
        {
          key: "start",
          value: false,
          protected: true
        },
        {
          key: "ended",
          value: false,
          protected: true
        }
      ])
    });
    const roundProm = this.addScopes([scope]);
    const stageAdds = [];
    const addStage = (attributes2) => {
      if (!Array.isArray(attributes2)) {
        const newAttr = [];
        for (const key in attributes2) {
          newAttr.push({
            key,
            value: attributes2[key]
          });
        }
        attributes2 = newAttr;
      }
      const durAttr = attributes2.find((a) => a.key === "duration");
      const res = import_zod.z.number().int().gte(1).safeParse(durAttr?.value);
      if (!res.success) {
        throw new Error(`stage duration invalid: ${res.error}`);
      }
      const [scope2, accessors2] = scopeConstructor({
        kind: "stage",
        attributes: attrs([
          ...attributes2.filter((a) => !reservedKeys.includes(a.key)),
          {
            key: "gameID",
            value: gameID,
            immutable: true
          },
          {
            key: "batchID",
            value: batchID,
            immutable: true
          },
          {
            key: "start",
            value: false,
            protected: true
          },
          {
            key: "ended",
            value: false,
            protected: true
          }
        ])
      });
      stageAdds.push(scope2);
      return accessors2;
    };
    this.addFinalizer(async () => {
      this._tmpRoundIndex = void 0;
      let rounds;
      try {
        rounds = await roundProm;
      } catch (err) {
        error(`failed to create round: ${err}`);
        return;
      }
      if (rounds.length < 1) {
        error(`failed to create round`);
        return;
      }
      const roundID = rounds[0].id;
      const round = this.scopeByID(roundID);
      if (!round) {
        throw "round not found in round finalizer";
      }
      let stageIndex = isOptionalNumber(round.get("stageIndex")) || 0;
      for (const scope2 of stageAdds) {
        const durAttr = scope2.attributes.find((a) => a.key === "duration");
        if (!durAttr || !durAttr.val) {
          error(`stage duration not found`);
          continue;
        }
        const res = import_zod.z.number().int().gte(1).safeParse(JSON.parse(durAttr.val));
        if (!res.success) {
          throw new Error(`stage duration invalid: ${res.error}`);
        }
        const duration = res.data;
        scope2.attributes.push({
          key: "roundID",
          val: JSON.stringify(roundID),
          immutable: true
        });
        let steps;
        try {
          steps = await this.addSteps([{ duration }]);
        } catch (err) {
          error(`failed to create steps: ${err}`);
          return;
        }
        if (steps.length < 1) {
          error(`failed to create steps`);
          return;
        }
        const stepID = steps[0].id;
        scope2.attributes.push({
          key: "timerID",
          val: JSON.stringify(stepID),
          immutable: true
        });
        scope2.attributes.push({
          key: "index",
          val: `${stageIndex}`,
          immutable: true
        });
        stageIndex++;
      }
      round.set("stageIndex", stageIndex);
      await this.addScopes(stageAdds);
    });
    return {
      ...accessors,
      addStage
    };
  }
  end(status, reason) {
    if (this.hasEnded) {
      return;
    }
    if (!endedStatuses.includes(status)) {
      warn(`game: attempting to end game with wrong status`);
      return;
    }
    this.set("status", status);
    this.set("endedReason", reason);
    const stage = this.currentStage;
    if (!stage) {
      return;
    }
    stage.end("ended", reason);
  }
  async createPlayerGame(player) {
    const key = `playerGameID-${this.id}`;
    if (player.get(key)) {
      return isString(player.get(key));
    }
    const batchID = isString(this.get("batchID"));
    const playerGames = await this.addScopes([
      {
        kind: "playerGame",
        attributes: attrs([
          {
            key: "batchID",
            value: batchID,
            immutable: true
          },
          {
            key: "gameID",
            value: this.id,
            immutable: true
          },
          {
            key: "playerID",
            value: player.id,
            immutable: true
          }
        ])
      }
    ]);
    if (playerGames.length < 1) {
      error(`failed to create playerGame`);
      return;
    }
    player.set(key, playerGames[0].id);
    return playerGames[0].id;
  }
};
var GameOwned = class extends BatchOwned {
  get currentGame() {
    return this.scopeByKey("gameID");
  }
};
var Player = class extends GameOwned {
  get game() {
    const game = this.currentGame;
    if (!game) {
      return;
    }
    const key = `playerGameID-${game.id}`;
    return this.scopeByKey(key);
  }
  get currentRound() {
    return this.currentStage?.round;
  }
  get round() {
    const round = this.currentRound;
    if (!round) {
      return;
    }
    const key = `playerRoundID-${round.id}`;
    return this.scopeByKey(key);
  }
  get currentStage() {
    return this.currentGame?.currentStage;
  }
  get stage() {
    const stage = this.currentStage;
    if (!stage) {
      return;
    }
    const key = `playerStageID-${stage.id}`;
    return this.scopeByKey(key);
  }
  exit(reason) {
    if (this.get("ended")) {
      return;
    }
    this.set("ended", reason);
  }
  hasUpdated() {
    if (super.hasUpdated()) {
      return true;
    }
    return Boolean(
      this.round?.hasUpdated() || this.stage?.hasUpdated() || this.game?.hasUpdated()
    );
  }
};
var PlayerGame = class extends GameOwned {
};
var PlayerRound = class extends GameOwned {
};
var PlayerStage = class extends GameOwned {
  get stage() {
    return this.scopeByKey("stageID");
  }
  get player() {
    return this.scopeByKey("playerID");
  }
};
var minStageDuration = 5;
var maxStageDuration = 1e9;
var Round = class extends GameOwned {
  get stages() {
    const stages = this.scopesByKindMatching(
      "stage",
      "roundID",
      this.id
    );
    stages.sort(indexSortable);
    return stages;
  }
  addStage(attributes) {
    if (!Array.isArray(attributes)) {
      const newAttr = [];
      for (const key in attributes) {
        newAttr.push({
          key,
          value: attributes[key]
        });
      }
      attributes = newAttr;
    }
    const durAttr = attributes.find((a) => a.key === "duration");
    const res = import_zod.z.number().int().gte(minStageDuration).lte(maxStageDuration).safeParse(durAttr?.value);
    if (!res.success) {
      throw new Error(`stage duration invalid: ${res.error}`);
    }
    const duration = res.data;
    const batchID = this.get("batchID");
    if (!batchID) {
      throw new Error("missing batch ID on round");
    }
    const gameID = this.get("gameID");
    if (!gameID) {
      throw new Error("missing game ID on round");
    }
    const stageIndex = import_zod.z.number().parse(this.get("stageIndex") || -1) + 1;
    this.set("stageIndex", stageIndex);
    const [scope, accessors] = scopeConstructor({
      kind: "stage",
      attributes: attrs([
        ...attributes.filter((a) => !reservedKeys.includes(a.key)),
        {
          key: "index",
          value: stageIndex,
          immutable: true
        },
        {
          key: "roundID",
          value: this.id,
          immutable: true
        },
        {
          key: "gameID",
          value: gameID,
          immutable: true
        },
        {
          key: "batchID",
          value: batchID,
          immutable: true
        },
        {
          key: "start",
          value: false,
          protected: true
        },
        {
          key: "ended",
          value: false,
          protected: true
        }
      ])
    });
    this.addFinalizer(async () => {
      let steps;
      try {
        steps = await this.addSteps([{ duration }]);
      } catch (err) {
        error(`failed to create steps: ${err}`);
        return;
      }
      if (steps.length < 1) {
        error(`failed to create steps`);
        return;
      }
      const stepID = steps[0].id;
      scope.attributes.push({
        key: "timerID",
        val: JSON.stringify(stepID),
        immutable: true
      });
      this.addScopes([scope]);
    });
    return accessors;
  }
  async createPlayerRound(player) {
    const key = `playerRoundID-${this.id}`;
    if (player.get(key)) {
      return isString(player.get(key));
    }
    const gameID = isString(this.get("gameID"));
    const batchID = isString(this.get("batchID"));
    const playerRounds = await this.addScopes([
      {
        kind: "playerRound",
        attributes: attrs([
          {
            key: "batchID",
            value: batchID,
            immutable: true
          },
          {
            key: "gameID",
            value: gameID,
            immutable: true
          },
          {
            key: "roundID",
            value: this.id,
            immutable: true
          },
          {
            key: "playerID",
            value: player.id,
            immutable: true
          }
        ])
      }
    ]);
    if (playerRounds.length < 1) {
      error(`failed to create playerRound`);
      return;
    }
    player.set(key, playerRounds[0].id);
    return playerRounds[0].id;
  }
};
var Stage = class extends GameOwned {
  get round() {
    return this.scopeByKey("roundID");
  }
  isCurrent() {
    return this.currentGame?.get("stageID") === this.id;
  }
  end(status, reason) {
    if (this.get("ended")) {
      return;
    }
    this.set("status", status);
    this.set("endedReason", reason);
    this.addTransitions([
      {
        from: import_tajriba4.State.Running,
        to: import_tajriba4.State.Ended,
        nodeID: this.get("timerID"),
        cause: reason
      }
    ]);
  }
  async createPlayerStage(player) {
    const key = `playerStageID-${this.id}`;
    if (player.get(key)) {
      return isString(player.get(key));
    }
    const roundID = isString(this.get("roundID"));
    const gameID = isString(this.get("gameID"));
    const batchID = isString(this.get("batchID"));
    const playerStages = await this.addScopes([
      {
        kind: "playerStage",
        attributes: attrs([
          {
            key: "batchID",
            value: batchID,
            immutable: true
          },
          {
            key: "gameID",
            value: gameID,
            immutable: true
          },
          {
            key: "roundID",
            value: roundID,
            immutable: true
          },
          {
            key: "stageID",
            value: this.id,
            immutable: true
          },
          {
            key: "playerID",
            value: player.id,
            immutable: true
          }
        ])
      }
    ]);
    if (playerStages.length < 1) {
      error(`failed to create playerStage`);
      return;
    }
    player.set(key, playerStages[0].id);
    return playerStages[0].id;
  }
};
var classicKinds = {
  batch: Batch,
  game: Game,
  player: Player,
  playerGame: PlayerGame,
  playerRound: PlayerRound,
  playerStage: PlayerStage,
  round: Round,
  stage: Stage
};
var EventProxy = class {
  constructor(ctx) {
    this.ctx = ctx;
  }
  // Returns all loaded Batches.
  get batches() {
    return Array.from(this.ctx.scopesByKind("batch").values());
  }
  // Returns all loaded Games accross Batches.
  get games() {
    return Array.from(this.ctx.scopesByKind("game").values());
  }
  // Returns all loaded Players accross all Games.
  get players() {
    return Array.from(this.ctx.scopesByKind("player").values());
  }
};
function evt(ctx) {
  return new EventProxy(ctx);
}

// src/admin/classic/schemas.ts
var import_zod2 = require("zod");
var treatmentSchema = import_zod2.z.record(import_zod2.z.string().min(1), import_zod2.z.any());
var batchConfigSchema = import_zod2.z.discriminatedUnion("kind", [
  import_zod2.z.object({
    kind: import_zod2.z.literal("custom"),
    config: import_zod2.z.any()
  }),
  import_zod2.z.object({
    kind: import_zod2.z.literal("simple"),
    config: import_zod2.z.object({
      count: import_zod2.z.number().int().positive(),
      treatments: import_zod2.z.object({
        factors: treatmentSchema
      }).array()
    })
  }),
  import_zod2.z.object({
    kind: import_zod2.z.literal("complete"),
    config: import_zod2.z.object({
      treatments: import_zod2.z.object({
        count: import_zod2.z.number().int().positive(),
        treatment: import_zod2.z.object({
          factors: treatmentSchema
        })
      }).array()
    })
  })
]);

// src/admin/classic/classic.ts
var isGame = import_zod3.z.instanceof(Game).parse;
var isRound = import_zod3.z.instanceof(Round).parse;
var isStage = import_zod3.z.instanceof(Stage).parse;
var isString2 = import_zod3.z.string().parse;
function Classic({
  disableAssignment,
  disableIntroCheck,
  disableGameCreation,
  disableBatchAutoend = false
} = {}) {
  return function(_) {
    const online = /* @__PURE__ */ new Map();
    const playersForParticipant = /* @__PURE__ */ new Map();
    const stageForStepID = /* @__PURE__ */ new Map();
    async function assignplayer(ctx, player, skipGameIDs) {
      if (disableAssignment) {
        return;
      }
      if (player.get("gameID")) {
        return;
      }
      for (const batch of evt(ctx).batches) {
        if (!batch.isRunning) {
          continue;
        }
        let availableGames = [];
        for (const game2 of batch.games) {
          if (!game2.hasStarted && (!skipGameIDs || !skipGameIDs?.includes(game2.id))) {
            availableGames.push(game2);
          }
        }
        if (availableGames.length === 0) {
          continue;
        }
        if (player.get("treatment")) {
          availableGames = availableGames.filter(
            (g) => deepEqual(g.get("treatment"), player.get("treatment"))
          );
        }
        if (availableGames.length === 0) {
          continue;
        }
        const game = pickRandom(availableGames);
        await game.assignPlayer(player);
        return;
      }
      if (player.get("gameID") !== void 0) {
        player.set("ended", "no more games");
      }
    }
    function checkShouldOpenExperiment(ctx) {
      let shouldOpenExperiment = false;
      LOOP:
        for (const batch of evt(ctx).batches) {
          if (!batch.isRunning) {
            continue;
          }
          for (const game of batch.games) {
            if (!game.hasStarted) {
              shouldOpenExperiment = true;
              break LOOP;
            }
          }
        }
      ctx.globals.set("experimentOpen", shouldOpenExperiment);
    }
    function tryToStartGame(ctx, game) {
      if (game.get("stageID"))
        return;
      if (game.stages.length === 0) {
        return;
      }
      const groupID = isString2(game.get("groupID"));
      const players = game.players.filter((p) => !p.get("ended"));
      const participantIDs = [];
      const nodeIDs = [game.id, groupID];
      for (const player of players) {
        nodeIDs.push(player.id);
        participantIDs.push(player.participantID);
        const playerGameID = player.get(`playerGameID-${game.id}`);
        if (!playerGameID) {
          return;
        }
        nodeIDs.push(playerGameID);
      }
      ctx.addLinks([{ link: true, participantIDs, nodeIDs }]);
      const round = isRound(game.rounds[0]);
      if (round.stages.length === 0) {
        return;
      }
      const stage = isStage(round.stages[0]);
      game.set("stageID", stage.id);
      round.set("start", true);
    }
    _.on("PARTICIPANT_CONNECT" /* ParticipantConnect */, async (ctx, { participant }) => {
      online.set(participant.id, participant);
      const player = playersForParticipant.get(participant.id);
      if (!player) {
        await ctx.addScopes([
          {
            attributes: attrs([
              {
                key: "participantID",
                value: participant.id,
                immutable: true
              },
              {
                key: "participantIdentifier",
                value: participant.identifier,
                immutable: true
              }
            ]),
            kind: "player"
          }
        ]);
      } else {
        await assignplayer(ctx, player);
      }
    });
    _.on("PARTICIPANT_DISCONNECT" /* ParticipantDisconnect */, (_2, { participant }) => {
      online.delete(participant.id);
    });
    _.on("player", async (ctx, { player }) => {
      const participantID = isString2(player.get("participantID"));
      player.participantID = participantID;
      playersForParticipant.set(participantID, player);
      ctx.addLinks([
        {
          link: true,
          participantIDs: [player.participantID],
          nodeIDs: [player.id]
        }
      ]);
      if (online.has(participantID)) {
        await assignplayer(ctx, player);
      }
    });
    _.on("batch", (_2, { batch }) => {
      if (disableGameCreation || batch.get("initialized")) {
        return;
      }
      batch.set("initialized", true);
      const config = batchConfigSchema.parse(batch.get("config"));
      switch (config.kind) {
        case "simple":
          for (let i = 0; i < config.config.count; i++) {
            const treatment = pickRandom(config.config.treatments).factors;
            batch.addGame([
              {
                key: "treatment",
                value: treatment,
                immutable: true
              }
            ]);
          }
          break;
        case "complete":
          for (const t of config.config.treatments) {
            for (let i = 0; i < t.count; i++) {
              batch.addGame([
                {
                  key: "treatment",
                  value: t.treatment.factors,
                  immutable: true
                }
              ]);
            }
          }
          break;
        default:
          warn("callbacks: batch created without a config");
          return;
      }
    });
    _.unique.on(
      "batch",
      "status",
      async (ctx, { batch, status }) => {
        switch (status) {
          case "running": {
            for (const [_2, player] of playersForParticipant) {
              if (player.participantID) {
                await assignplayer(ctx, player);
              }
            }
            checkShouldOpenExperiment(ctx);
            break;
          }
          case "terminated":
            for (const game of batch.games) {
              game.end(status, "batch ended");
            }
            checkShouldOpenExperiment(ctx);
            break;
          case "ended":
            checkShouldOpenExperiment(ctx);
            break;
          case "created":
            break;
          default:
            warn("unknown batch status:", status);
            break;
        }
      }
    );
    _.unique.on("game", "status", (ctx, { game, status }) => {
      switch (status) {
        case "running": {
          tryToStartGame(ctx, game);
          checkShouldOpenExperiment(ctx);
          break;
        }
        case "ended":
        case "failed":
        case "terminated":
          for (const player of game.players) {
            player.set("ended", `game ${status}`);
          }
          const finishedBatch = !disableBatchAutoend && game.batch.games.every((g) => g.hasEnded);
          if (finishedBatch) {
            game.batch.end("all games finished");
          }
          checkShouldOpenExperiment(ctx);
          break;
        default:
          warn(`unkown game status: ${status}`);
          break;
      }
    });
    _.on("game", async (ctx, { game }) => {
      if (game.get("groupID")) {
        return;
      }
      let groups;
      try {
        groups = await ctx.addGroups([{ participantIDs: [] }]);
      } catch (err) {
        error(`failed to create game group: ${err}`);
        return;
      }
      if (groups.length < 1) {
        error(`failed to create game groups`);
        return;
      }
      const groupID = groups[0].id;
      game.set("groupID", groupID);
    });
    _.on("stage", "gameID", async (ctx, { stage }) => {
      if (!stage.currentGame?.isRunning) {
        return;
      }
      tryToStartGame(ctx, stage.currentGame);
    });
    _.after("stage", "timerID", (_2, { stage, timerID }) => {
      stageForStepID.set(timerID, stage);
    });
    function getNextStage(stage, game) {
      if (game.hasEnded) {
        return { stop: true, nextStage: void 0, nextRound: void 0 };
      }
      const currentRound = isRound(stage.round);
      let nextRound = currentRound;
      const roundStages = currentRound.stages;
      let nextStage = roundStages[stage.get("index") + 1];
      if (!nextStage) {
        const gameRounds = game.rounds;
        nextRound = gameRounds[currentRound.get("index") + 1];
        if (!nextRound) {
          return { stop: true, nextStage: void 0, nextRound: void 0 };
        }
        nextStage = nextRound.stages[0];
        if (!nextStage) {
          return { stop: true, nextStage: void 0, nextRound: void 0 };
        }
      }
      return { nextStage, nextRound, stop: false };
    }
    _.on("player", "introDone", async (ctx, { player }) => {
      if (disableIntroCheck || !player.currentGame) {
        return;
      }
      const game = isGame(player.currentGame);
      const treatment = treatmentSchema.parse(game.get("treatment"));
      const playerCount = treatment["playerCount"];
      const readyPlayers = game.players.filter(
        (p) => p.get("introDone") && !p.get("ended")
      );
      if (readyPlayers.length < playerCount) {
        trace("introDone: not enough players ready yet");
        return;
      }
      if (game.hasStarted) {
        trace("introDone: game already started");
        return;
      }
      const players = selectRandom(readyPlayers, playerCount);
      const playersIDS = players.map((p) => p.id);
      for (const plyr of game.players) {
        if (!playersIDS.includes(plyr.id)) {
          plyr.set("gameID", null);
          await assignplayer(ctx, plyr, [game.id]);
        }
      }
      trace("introDone: starting game");
      game.start();
    });
    _.unique.before(
      "game",
      "start",
      async (_2, { game, start }) => {
        if (!start) {
          return;
        }
        for (const player of game.players) {
          await game.createPlayerGame(player);
        }
      }
    );
    _.unique.after("game", "start", (_2, { game, start }) => {
      if (!start) {
        return;
      }
      game.set("status", "running");
    });
    _.unique.before(
      "round",
      "start",
      async (_2, { round, start }) => {
        if (!start) {
          return;
        }
        const game = isGame(round.currentGame);
        for (const player of game.players) {
          await round.createPlayerRound(player);
        }
      }
    );
    _.unique.after(
      "round",
      "start",
      (ctx, { round, start }) => {
        if (!start)
          return;
        const game = isGame(round.currentGame);
        const stageID = isString2(game.get("stageID"));
        const stage = isStage(game.stages.find((s) => s.id === stageID));
        if (stage.get("start")) {
          return;
        }
        const participantIDs = [];
        const nodeIDs = [round.id];
        for (const player of game.players) {
          participantIDs.push(player.participantID);
          nodeIDs.push(isString2(player.get(`playerRoundID-${round.id}`)));
        }
        ctx.addLinks([{ link: true, participantIDs, nodeIDs }]);
        stage.set("start", true);
      }
    );
    _.unique.before(
      "stage",
      "start",
      async (_2, { stage, start }) => {
        if (!start)
          return;
        const game = isGame(stage.currentGame);
        for (const player of game.players) {
          await stage.createPlayerStage(player);
        }
      }
    );
    _.unique.after(
      "stage",
      "start",
      (ctx, { stage, start }) => {
        if (!start)
          return;
        if (stage.get("started")) {
          return;
        }
        stage.set("started", true);
        const game = isGame(stage.currentGame);
        const timerID = isString2(stage.get("timerID"));
        const participantIDs = [];
        const nodeIDs = [stage.id, timerID];
        for (const player of game.players) {
          participantIDs.push(player.participantID);
          nodeIDs.push(isString2(player.get(`playerStageID-${stage.id}`)));
        }
        ctx.addLinks([{ link: true, participantIDs, nodeIDs }]);
        ctx.addTransitions([
          {
            from: import_tajriba5.State.Created,
            to: import_tajriba5.State.Running,
            nodeID: timerID,
            cause: "stage start"
          }
        ]);
      }
    );
    _.after(
      "playerStage",
      "submit",
      (ctx, { playerStage, submit }) => {
        if (!submit)
          return;
        if (!playerStage.stage || !playerStage.stage.isCurrent()) {
          return;
        }
        const players = playerStage.player.currentGame.players;
        if (players.length === 0) {
          warn("callbacks: no players onSubmit");
          return;
        }
        const haveAllPlayersSubmitted = players.every(
          (p) => p.get("ended") || !online.has(p.get("participantID")?.toString()) || p.stage?.get("submit")
        );
        if (haveAllPlayersSubmitted) {
          ctx.addTransitions([
            {
              from: import_tajriba5.State.Running,
              to: import_tajriba5.State.Ended,
              nodeID: isString2(playerStage.stage.get("timerID")),
              cause: "players submitted"
            }
          ]);
          trace(`all player submitted, transitioning`);
        } else {
          trace(`not all player submitted`);
        }
      }
    );
    _.unique.after(
      "stage",
      "ended",
      (ctx, { stage, ended }) => {
        if (!ended)
          return;
        const game = isGame(stage.currentGame);
        const timerID = isString2(stage.get("timerID"));
        const round = isRound(stage.round);
        const participantIDs = [];
        const nodeIDs = [stage.id, timerID];
        for (const player of game.players) {
          participantIDs.push(player.participantID);
          nodeIDs.push(isString2(player.get(`playerStageID-${stage.id}`)));
        }
        ctx.addLinks([{ link: false, participantIDs, nodeIDs }]);
        const { stop, nextRound, nextStage } = getNextStage(stage, game);
        if (stop) {
          round.set("ended", true);
          return;
        }
        if (round.id !== nextRound.id) {
          round.set("ended", true);
        } else {
          game.set("stageID", nextStage.id);
          nextStage.set("start", true);
        }
      }
    );
    _.unique.after(
      "round",
      "ended",
      (ctx, { round, ended }) => {
        if (!ended)
          return;
        const game = isGame(round.currentGame);
        const stage = isStage(game.currentStage);
        const participantIDs = [];
        const nodeIDs = [round.id];
        for (const player of game.players) {
          participantIDs.push(player.participantID);
          nodeIDs.push(isString2(player.get(`playerRoundID-${round.id}`)));
        }
        ctx.addLinks([{ link: false, participantIDs, nodeIDs }]);
        const { stop, nextRound, nextStage } = getNextStage(stage, game);
        if (stop) {
          game.set("stageID", null);
          game.set("ended", true);
          return;
        }
        game.set("stageID", nextStage.id);
        nextRound.set("start", true);
      }
    );
    _.unique.after("game", "ended", (_2, { game, ended }) => {
      if (!ended)
        return;
      game.end("ended", "end of game");
    });
    _.on(
      "TRANSITION_ADD" /* TransitionAdd */,
      (_2, { step, transition: { from, to } }) => {
        const stage = stageForStepID.get(step.id);
        if (!stage) {
          return;
        }
        debug(`transition stage: ${from} => ${to}`);
        if (from === import_tajriba5.State.Running && to === import_tajriba5.State.Ended) {
          const stage2 = isStage(stageForStepID.get(step.id));
          if (!stage2.get("ended")) {
            stage2.set("ended", true);
          }
        }
      }
    );
  };
}

// src/admin/classic/api/api.ts
var import_tajriba6 = require("@empirica/tajriba");

// src/admin/classic/export/export_csv.ts
var import_archiver = __toESM(require("archiver"), 1);
var import_stream_buffers = __toESM(require("stream-buffers"), 1);

// src/admin/classic/loader.ts
var import_zod4 = require("zod");
var string = import_zod4.z.string();
function ClassicLoader(_) {
  _.on("start", function(ctx) {
    ctx.participantsSub();
    ctx.scopeSub({ kinds: ["batch", "player"] });
  });
  _.on("batch", "status", function(ctx, { batch, status }) {
    if (["running", "created"].includes(status)) {
      ctx.scopeSub({
        kvs: [{ key: "batchID", val: JSON.stringify(batch.id) }]
      });
    }
  });
  _.on("stage", "timerID", function(ctx, { timerID }) {
    ctx.transitionsSub(string.parse(timerID));
  });
}

// src/admin/classic/lobby.ts
var import_tajriba7 = require("@empirica/tajriba");
var import_zod5 = require("zod");
var nanosecond = 1;
var microsecond = 1e3 * nanosecond;
var millisecond = 1e3 * microsecond;
var second = 1e3 * millisecond;

// src/admin/classic/proxy.ts
var ClassicListenersCollector = class extends ListenersCollector {
  /**
   * onGameStart is triggered just before the game start. It is a great place to
   * create rounds and stages and initialize values on the game, the players,
   * the rounds, and the stages.
   *
   * Players are accessible on the game, `game.players`.
   * You can add Rounds to a Game with `game.addRound({ some: "attribute" })`.
   * `game.AddRound` returns a Round object. On the Round object, you can create
   * Stages: `round.addStage({ some: "value" })`.
   *
   * @example
   * ```js
   * const round = game.addRound({
   *   name: "Round 1 - Jelly Beans",
   *   task: "jellybeans",
   * });
   * round.addStage({ name: "Answer", duration: 300 });
   * round.addStage({ name: "Result", duration: 120 });
   *
   * game.players.forEach((player) => player.set("score", 0));
   * ```
   * */
  onGameStart(cb) {
    this.unique.on(
      "game",
      "start",
      (_, { game, start }) => {
        if (!start)
          return;
        cb({ game });
      }
    );
  }
  onRoundStart(cb) {
    this.unique.on(
      "round",
      "start",
      (_, { round, start }) => {
        if (!start)
          return;
        cb({ round });
      }
    );
  }
  onStageStart(cb) {
    this.unique.on(
      "stage",
      "start",
      (_, { stage, start }) => {
        if (!start)
          return;
        cb({ stage });
      }
    );
  }
  onStageEnded(cb) {
    this.unique.on(
      "stage",
      "ended",
      (_, { stage, ended }) => {
        if (!ended)
          return;
        cb({ stage });
      }
    );
  }
  onRoundEnded(cb) {
    this.unique.on(
      "round",
      "ended",
      (_, { round, ended }) => {
        if (!ended)
          return;
        cb({ round });
      }
    );
  }
  onGameEnded(cb) {
    this.unique.on(
      "game",
      "ended",
      (_, { game, ended }) => {
        if (!ended)
          return;
        cb({ game });
      }
    );
  }
};

// src/player/provider.ts
var import_rxjs12 = require("rxjs");
var TajribaProvider = class {
  constructor(changes, globals, setAttributes) {
    this.globals = globals;
    this.setAttributes = setAttributes;
    this.scopes = new import_rxjs12.Subject();
    this.attributes = new import_rxjs12.Subject();
    this.participants = new import_rxjs12.Subject();
    this.steps = new import_rxjs12.Subject();
    this.dones = new import_rxjs12.Subject();
    let scopeIDs = [];
    changes.pipe((0, import_rxjs12.groupBy)((chg) => chg?.change?.__typename)).subscribe({
      next: (group) => {
        switch (group.key) {
          case "ScopeChange":
            group.subscribe({
              next: (msg) => {
                if (!msg.change || msg.removed === null || msg.removed === void 0) {
                  trace("AttributeChange empty");
                } else {
                  this.scopes.next({
                    scope: msg.change,
                    removed: msg.removed
                  });
                }
                if (msg.done) {
                  this.dones.next(scopeIDs);
                }
              }
            });
            break;
          case "AttributeChange":
            group.subscribe({
              next: (msg) => {
                if (!msg.change || msg.removed === null || msg.removed === void 0) {
                  trace("AttributeChange empty");
                } else {
                  const atChange = msg.change;
                  scopeIDs.push(atChange.nodeID || atChange.node.id);
                  this.attributes.next({
                    attribute: atChange,
                    removed: msg.removed
                  });
                }
                if (msg.done) {
                  this.dones.next(scopeIDs);
                  scopeIDs = [];
                }
              }
            });
            break;
          case "ParticipantChange":
            group.subscribe({
              next: (msg) => {
                if (!msg.change || msg.removed === null || msg.removed === void 0) {
                  trace("ParticipantChange empty");
                } else {
                  this.participants.next({
                    participant: msg.change,
                    removed: msg.removed
                  });
                }
                if (msg.done) {
                  this.dones.next([]);
                }
              }
            });
            break;
          case "StepChange":
            group.subscribe({
              next: (msg) => {
                if (!msg.change || msg.removed === null || msg.removed === void 0) {
                  trace("StepChange empty");
                } else {
                  this.steps.next({
                    step: msg.change,
                    removed: msg.removed
                  });
                }
                if (msg.done) {
                  this.dones.next([]);
                }
              }
            });
            break;
          default:
            group.subscribe({
              next: (change) => {
                if (change.done) {
                  this.dones.next([]);
                }
              }
            });
            break;
        }
      }
    });
  }
};

// src/player/scopes.ts
var Scopes3 = class extends Scopes {
  constructor(scopesObs, donesObs, ctx, kinds2, attributes, steps) {
    super(scopesObs, donesObs, ctx, kinds2, attributes);
    this.steps = steps;
  }
  create(scopeClass, scope) {
    return new scopeClass(
      this.ctx,
      scope,
      this,
      this.attributes,
      this.steps
    );
  }
};
var Scope3 = class extends Scope {
  constructor(ctx, scope, scopes, attributes, steps) {
    super(ctx, scope, attributes);
    this.scopes = scopes;
    this.steps = steps;
  }
  scopeByKey(key) {
    const id = this.get(key);
    if (!id || typeof id !== "string") {
      return;
    }
    return this.scopes.scope(id);
  }
  ticker(id) {
    return this.steps.step(id);
  }
  tickerByKey(key) {
    const id = this.get(key);
    if (!id || typeof id !== "string") {
      return;
    }
    return this.ticker(id);
  }
};

// src/player/steps.ts
var import_rxjs13 = require("rxjs");
var scheduled = [];
var mockNow = null;
function pnow() {
  if (mockNow !== null) {
    return mockNow;
  } else {
    return performance.now();
  }
}
function timeout(callback, ms) {
  if (mockNow !== null) {
    const schd = {
      cb: callback,
      from: mockNow,
      dur: ms
    };
    scheduled.push(schd);
  } else {
    setTimeout(callback, ms);
  }
}
var Step2 = class {
  constructor(step, ticker) {
    this.running = false;
    this.ticker = new import_rxjs13.BehaviorSubject(void 0);
    this.startAt = 0;
    this.endAt = 0;
    ticker.pipe((0, import_rxjs13.map)(this.recalc.bind(this))).subscribe({
      next: (val) => {
        this.ticker.next(val);
      }
    });
    this._update(step);
  }
  recalc(t) {
    if (!this.running) {
      return void 0;
    }
    return {
      started: t >= this.startAt,
      ended: t >= this.endAt,
      elapsed: Math.round(t - this.startAt),
      remaining: Math.round(this.endAt - t),
      duration: this.endAt - this.startAt
    };
  }
  obs() {
    return this.ticker;
  }
  get current() {
    return this.recalc(pnow());
  }
  // internal only
  _update(step) {
    if (!step.running) {
      this.running = false;
      this.ticker.next(void 0);
      return;
    }
    if (step.elapsed === null || step.remaining === null || step.elapsed === void 0 || step.remaining === void 0) {
      this.running = false;
      return;
    }
    const now = pnow();
    this.startAt = now - step.elapsed * 1e3;
    this.endAt = now + step.remaining * 1e3;
    this.running = step.elapsed >= 0 && step.remaining >= 0;
    this.ticker.next(this.recalc(now));
  }
  // internal only
  _stop() {
    this.running = false;
    this.ticker.next(void 0);
  }
};
var Steps = class {
  constructor(stepsObs, donesObs) {
    this.steps = /* @__PURE__ */ new Map();
    this.updates = /* @__PURE__ */ new Map();
    this._hadUpdates = false;
    stepsObs.subscribe({
      next: ({ step, removed }) => {
        this.update(step, removed);
      }
    });
    donesObs.subscribe({
      next: () => {
        this.next();
      }
    });
    this.ticker = new import_rxjs13.BehaviorSubject(Math.floor(pnow()));
    const controller = new AbortController();
    timerInterval(1e3, controller.signal, (t) => {
      this.ticker.next(t);
    });
  }
  step(stepID) {
    return this.steps.get(stepID);
  }
  hadUpdates() {
    const hadUpdates = this._hadUpdates;
    this._hadUpdates = false;
    return hadUpdates;
  }
  update(step, removed) {
    if (removed) {
      this.updates.set(step.id, true);
    } else {
      this.updates.set(step.id, step);
    }
    this._hadUpdates = true;
  }
  next() {
    for (const [id, stepOrDel] of this.updates) {
      let step = this.steps.get(id);
      if (typeof stepOrDel === "boolean") {
        if (step) {
          step._stop();
          this.steps.delete(id);
        }
      } else {
        if (!step) {
          step = new Step2(stepOrDel, this.ticker);
          this.steps.set(id, step);
        }
        step._update(stepOrDel);
      }
    }
    this.updates.clear();
  }
};
var root = typeof self === "object" && self.self == self ? self : typeof global === "object" && global.global == global ? global : {};
if (!root["requestAnimationFrame"]) {
  root["requestAnimationFrame"] = (cb) => cb(pnow());
}
function timerInterval(ms = 1e3, signal, callback) {
  const start = Math.floor(pnow() / 1e3) * 1e3;
  function frame(time) {
    if (signal.aborted)
      return;
    callback(time);
    scheduleFrame(time);
  }
  function scheduleFrame(time) {
    const elapsed = time - start;
    const roundedElapsed = Math.round(elapsed / ms) * ms;
    const targetNext = start + roundedElapsed + ms;
    const delay = targetNext - pnow();
    timeout(() => requestAnimationFrame(frame), delay);
  }
  scheduleFrame(start);
}

// src/player/utils.ts
var isDevelopment = process.env.NODE_ENV === "development";
var isProduction = process.env.NODE_ENV === "production";
var isTest = process.env.NODE_ENV === "test";
var createNewParticipant = (key = "participantKey") => {
  const url = new URL(document.location.href);
  url.searchParams.set(key, (/* @__PURE__ */ new Date()).getTime().toString());
  window.open(url.href, "_blank")?.focus();
};

// src/player/classic/classic.ts
var import_rxjs14 = require("rxjs");
var endedStatuses2 = ["ended", "terminated", "failed"];
var Game2 = class extends Scope3 {
  get hasEnded() {
    return endedStatuses2.includes(this.get("status"));
  }
  get stage() {
    return this.scopeByKey("stageID");
  }
  get round() {
    return this.stage?.round;
  }
};
var Player3 = class extends Scope3 {
  get game() {
    const { game } = this.ctx;
    if (!game) {
      return;
    }
    const key = `playerGameID-${game.id}`;
    return this.scopeByKey(key);
  }
  get round() {
    const { stage } = this.ctx;
    if (!stage) {
      return;
    }
    const { round } = stage;
    if (!round) {
      return;
    }
    const key = `playerRoundID-${round.id}`;
    return this.scopeByKey(key);
  }
  get stage() {
    const { stage } = this.ctx;
    if (!stage) {
      return;
    }
    const key = `playerStageID-${stage.id}`;
    return this.scopeByKey(key);
  }
  hasUpdated() {
    if (super.hasUpdated()) {
      return true;
    }
    return Boolean(
      this.round?.hasUpdated() || this.stage?.hasUpdated() || this.game?.hasUpdated()
    );
  }
};
var PlayerGame2 = class extends Scope3 {
};
var PlayerRound2 = class extends Scope3 {
};
var PlayerStage3 = class extends Scope3 {
};
var Round2 = class extends Scope3 {
};
var Stage2 = class extends Scope3 {
  get round() {
    return this.scopeByKey("roundID");
  }
  get timer() {
    return this.tickerByKey("timerID");
  }
};
var Context3 = class {
};
var kinds = {
  game: Game2,
  player: Player3,
  playerGame: PlayerGame2,
  playerRound: PlayerRound2,
  playerStage: PlayerStage3,
  round: Round2,
  stage: Stage2
};
function EmpiricaClassic(participantID, provider) {
  const attributesDones = new import_rxjs14.Subject();
  const scopesDones = new import_rxjs14.Subject();
  const ctx = new Context3();
  const attributes = new Attributes(
    provider.attributes,
    attributesDones,
    provider.setAttributes
  );
  const steps = new Steps(
    provider.steps,
    provider.dones
  );
  const scopes = new Scopes3(
    provider.scopes,
    scopesDones,
    ctx,
    kinds,
    attributes,
    steps
  );
  const participantIDs = /* @__PURE__ */ new Set();
  const glob = new Globals(provider.globals);
  const ret = {
    game: new import_rxjs14.BehaviorSubject(void 0),
    player: new import_rxjs14.BehaviorSubject(void 0),
    players: new import_rxjs14.BehaviorSubject(void 0),
    round: new import_rxjs14.BehaviorSubject(void 0),
    stage: new import_rxjs14.BehaviorSubject(void 0),
    globals: glob.self
  };
  provider.participants.subscribe({
    next: ({ participant, removed }) => {
      if (removed) {
        if (participantIDs.has(participant.id)) {
          participantIDs.delete(participant.id);
        }
      } else {
        if (!participantIDs.has(participant.id)) {
          participantIDs.add(participant.id);
        }
      }
    }
  });
  let scopesUpdated = /* @__PURE__ */ new Set();
  provider.attributes.subscribe({
    next: (attr) => {
      const nodeID = attr.attribute.node?.id || attr.attribute.nodeID;
      if (!nodeID) {
        return;
      }
      scopesUpdated.add(nodeID);
    }
  });
  provider.dones.subscribe({
    next: () => {
      const current = getCurrent(ret);
      const updated = getMainObjects(participantID, scopes, attributes);
      ctx.game = updated.game;
      ctx.stage = updated.stage;
      if (scopeChanged(current.game, updated.game)) {
        ret.game.next(updated.game);
      }
      if (scopeChanged(current.player, updated.player)) {
        ret.player.next(updated.player);
      }
      if (scopeChanged(current.round, updated.round)) {
        ret.round.next(updated.round);
      }
      if (scopeChanged(current.stage, updated.stage) || steps.hadUpdates()) {
        ret.stage.next(updated.stage);
      }
      let playersChanged = false;
      const players = [];
      for (let i = 0; i < (updated.players || []).length; i++) {
        let p = updated.players[i];
        if (p) {
          const partID = attributes.nextAttributeValue(
            p.id,
            "participantID"
          );
          if (!participantIDs.has(partID)) {
            p = void 0;
          }
        }
        if (!playersChanged && scopeChanged(p, (current.players || [])[i])) {
          playersChanged = true;
        }
        if (p) {
          players.push(p);
        }
      }
      if (playersChanged) {
        ret.players.next(players);
      }
      const scopeIDs = Array.from(scopesUpdated);
      scopesDones.next(scopeIDs);
      attributesDones.next(scopeIDs);
      scopesUpdated.clear();
    }
  });
  return ret;
}
function scopeChanged(current, updated) {
  if (!current && !updated) {
    if (current === void 0 && updated === null) {
      return true;
    }
    return false;
  }
  if (!current || !updated) {
    return true;
  }
  return current.id !== updated.id || updated.hasUpdated();
}
function getCurrent(ctx) {
  return {
    game: ctx.game.getValue(),
    player: ctx.player.getValue(),
    round: ctx.round.getValue(),
    stage: ctx.stage.getValue(),
    players: ctx.players.getValue()
  };
}
function getMainObjects(participantID, scopes, attributes) {
  const players = scopes.byKind("player");
  const res = {
    players: Array.from(players.values()),
    game: null,
    player: null,
    round: null,
    stage: null
  };
  if (players.size === 0) {
    return res;
  }
  res.player = Array.from(players.values()).find((p) => {
    const pID = attributes.nextAttributeValue(p.id, "participantID");
    return pID === participantID;
  });
  if (!res.player) {
    return res;
  }
  res.game = nextScopeByKey(scopes, attributes, res.player, "gameID");
  if (!res.game) {
    return res;
  }
  for (const player of res.players || []) {
    const key = `playerGameID-${res.game.id}`;
    if (!nextScopeByKey(scopes, attributes, player, key)) {
      return res;
    }
  }
  res.stage = nextScopeByKey(scopes, attributes, res.game, "stageID");
  if (!res.stage) {
    return res;
  }
  for (const player of res.players || []) {
    const key = `playerStageID-${res.stage.id}`;
    if (!nextScopeByKey(scopes, attributes, player, key)) {
      delete res.stage;
      return res;
    }
  }
  res.round = nextScopeByKey(scopes, attributes, res.stage, "roundID");
  if (!res.round) {
    return res;
  }
  for (const player of res.players || []) {
    const key = `playerRoundID-${res.round.id}`;
    if (!nextScopeByKey(scopes, attributes, player, key)) {
      delete res.stage;
      delete res.round;
      return res;
    }
  }
  return res;
}
function nextScopeByKey(scopes, attributes, scope, key) {
  const id = attributes.nextAttributeValue(scope.id, key);
  if (!id || typeof id !== "string") {
    return null;
  }
  return scopes.scope(id) || null;
}

// src/player/classic/react/EmpiricaContext.tsx
var import_react11 = __toESM(require("react"), 1);

// src/player/react/Consent.tsx
var import_react = __toESM(require("react"), 1);
var defaultTitle = "Do you consent to participate in this experiment?";
var defaultText = `This experiment is part of a scientific project. Your decision
to participate in this experiment is entirely voluntary. There
are no known or anticipated risks to participating in this
experiment. There is no way for us to identify you. The only
information we will have, in addition to your responses, is
the timestamps of your interactions with our site. The results
of our research may be presented at scientific meetings or
published in scientific journals. Clicking on the "I AGREE"
button indicates that you are at least 18 years of age, and
agree to participate voluntary.`;
var defaultButtonText = "I AGREE";
function Consent({
  title = defaultTitle,
  text = defaultText,
  buttonText = defaultButtonText,
  onConsent
}) {
  return /* @__PURE__ */ import_react.default.createElement(
    "div",
    {
      className: "relative h-full z-10 overflow-y-auto",
      "aria-labelledby": "modal-title",
      role: "dialog",
      "aria-modal": "true"
    },
    /* @__PURE__ */ import_react.default.createElement("div", { className: "flex items-end justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0" }, /* @__PURE__ */ import_react.default.createElement(
      "div",
      {
        className: "absolute inset-0 bg-gray-500 bg-opacity-75 transition-opacity",
        "aria-hidden": "true"
      }
    ), /* @__PURE__ */ import_react.default.createElement(
      "span",
      {
        className: "hidden sm:inline-block sm:align-middle sm:h-screen",
        "aria-hidden": "true"
      },
      "\u200B"
    ), /* @__PURE__ */ import_react.default.createElement("div", { className: "inline-block align-bottom bg-white rounded-lg px-4 pt-5 pb-4 text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-lg sm:w-full sm:p-6" }, /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("div", { className: "mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-green-100" }, /* @__PURE__ */ import_react.default.createElement(
      "svg",
      {
        className: "h-6 w-6 text-green-600",
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        stroke: "currentColor",
        "aria-hidden": "true"
      },
      /* @__PURE__ */ import_react.default.createElement(
        "path",
        {
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "2",
          d: "M5 13l4 4L19 7"
        }
      )
    )), /* @__PURE__ */ import_react.default.createElement("div", { className: "mt-3 sm:mt-5" }, /* @__PURE__ */ import_react.default.createElement(
      "h3",
      {
        className: "text-lg text-center leading-6 font-medium text-gray-900",
        id: "modal-title"
      },
      title
    ), /* @__PURE__ */ import_react.default.createElement("div", { className: "mt-2" }, /* @__PURE__ */ import_react.default.createElement("div", { className: "text-sm text-gray-500 text-justify" }, text)))), /* @__PURE__ */ import_react.default.createElement("div", { className: "mt-5 sm:mt-6" }, /* @__PURE__ */ import_react.default.createElement(
      "button",
      {
        type: "button",
        className: "inline-flex justify-center w-full rounded-md border border-transparent shadow-sm px-4 py-2 bg-empirica-600 text-base font-medium text-white hover:bg-empirica-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-empirica-500 sm:text-sm",
        onClick: onConsent
      },
      buttonText
    ))))
  );
}

// src/player/react/Finished.tsx
var import_react2 = __toESM(require("react"), 1);
function Finished() {
  return /* @__PURE__ */ import_react2.default.createElement("div", { className: "h-full flex flex-col items-center justify-center" }, /* @__PURE__ */ import_react2.default.createElement("h2", { className: "font-medium text-gray-700" }, "Finished"), /* @__PURE__ */ import_react2.default.createElement("p", { className: "mt-2 text-gray-400" }, "Thank you for participating"));
}

// src/player/react/Loading.tsx
var import_react3 = __toESM(require("react"), 1);
function Loading() {
  return /* @__PURE__ */ import_react3.default.createElement("div", { className: "h-full w-full flex items-center justify-center" }, /* @__PURE__ */ import_react3.default.createElement(
    "svg",
    {
      width: "44",
      height: "44",
      viewBox: "0 0 44 44",
      xmlns: "http://www.w3.org/2000/svg",
      className: "text-empirica-200 stroke-current"
    },
    /* @__PURE__ */ import_react3.default.createElement("g", { fill: "none", fillRule: "evenodd", strokeWidth: "2" }, /* @__PURE__ */ import_react3.default.createElement("circle", { cx: "22", cy: "22", r: "1" }, /* @__PURE__ */ import_react3.default.createElement(
      "animate",
      {
        attributeName: "r",
        begin: "0s",
        dur: "1.8s",
        values: "1; 20",
        calcMode: "spline",
        keyTimes: "0; 1",
        keySplines: "0.165, 0.84, 0.44, 1",
        repeatCount: "indefinite"
      }
    ), /* @__PURE__ */ import_react3.default.createElement(
      "animate",
      {
        attributeName: "stroke-opacity",
        begin: "0s",
        dur: "1.8s",
        values: "1; 0",
        calcMode: "spline",
        keyTimes: "0; 1",
        keySplines: "0.3, 0.61, 0.355, 1",
        repeatCount: "indefinite"
      }
    )), /* @__PURE__ */ import_react3.default.createElement("circle", { cx: "22", cy: "22", r: "1" }, /* @__PURE__ */ import_react3.default.createElement(
      "animate",
      {
        attributeName: "r",
        begin: "-0.9s",
        dur: "1.8s",
        values: "1; 20",
        calcMode: "spline",
        keyTimes: "0; 1",
        keySplines: "0.165, 0.84, 0.44, 1",
        repeatCount: "indefinite"
      }
    ), /* @__PURE__ */ import_react3.default.createElement(
      "animate",
      {
        attributeName: "stroke-opacity",
        begin: "-0.9s",
        dur: "1.8s",
        values: "1; 0",
        calcMode: "spline",
        keyTimes: "0; 1",
        keySplines: "0.3, 0.61, 0.355, 1",
        repeatCount: "indefinite"
      }
    )))
  ));
}

// src/player/react/NoGames.tsx
var import_react4 = __toESM(require("react"), 1);
function NoGames() {
  return /* @__PURE__ */ import_react4.default.createElement("div", { className: "h-screen flex items-center justify-center" }, /* @__PURE__ */ import_react4.default.createElement("div", { className: "w-92 flex flex-col items-center" }, /* @__PURE__ */ import_react4.default.createElement("h2", { className: "text-gray-700 font-medium" }, "No experiments available"), /* @__PURE__ */ import_react4.default.createElement("p", { className: "mt-2 text-gray-400 text-justify" }, "There are currently no available experiments. Please wait until an experiment becomes available or come back at a later date."), isDevelopment ? /* @__PURE__ */ import_react4.default.createElement("p", { className: "mt-4 text-gray-700" }, "Go to", " ", /* @__PURE__ */ import_react4.default.createElement(
    "a",
    {
      href: "/admin",
      target: "empirica-admin",
      className: "text-empirica-500"
    },
    "Admin"
  ), " ", "to get started") : ""));
}

// src/player/react/PlayerCreate.tsx
var import_react5 = __toESM(require("react"), 1);
function PlayerCreate({ onPlayerID, connecting }) {
  const [playerID, setPlayerID] = (0, import_react5.useState)("");
  const handleSubmit = (evt2) => {
    evt2.preventDefault();
    if (!playerID || playerID.trim() === "") {
      return;
    }
    onPlayerID(playerID);
  };
  return /* @__PURE__ */ import_react5.default.createElement("div", { className: "min-h-screen bg-empirica-50 flex flex-col justify-center py-12 sm:px-6 lg:px-8" }, /* @__PURE__ */ import_react5.default.createElement("div", { className: "sm:mx-auto sm:w-full sm:max-w-md" }, /* @__PURE__ */ import_react5.default.createElement("h2", { className: "mt-6 text-center text-3xl font-extrabold text-gray-900" }, "Enter your Player Identifier")), /* @__PURE__ */ import_react5.default.createElement("div", { className: "mt-8 sm:mx-auto sm:w-full sm:max-w-md" }, /* @__PURE__ */ import_react5.default.createElement("div", { className: "bg-white py-8 px-4 shadow sm:rounded-lg sm:px-10" }, /* @__PURE__ */ import_react5.default.createElement(
    "form",
    {
      className: "space-y-6",
      action: "#",
      method: "POST",
      onSubmit: handleSubmit
    },
    /* @__PURE__ */ import_react5.default.createElement("fieldset", { disabled: connecting }, /* @__PURE__ */ import_react5.default.createElement("div", null, /* @__PURE__ */ import_react5.default.createElement(
      "label",
      {
        htmlFor: "email",
        className: "block text-sm font-medium text-gray-700"
      },
      "Identifier"
    ), /* @__PURE__ */ import_react5.default.createElement("div", { className: "mt-1" }, /* @__PURE__ */ import_react5.default.createElement(
      "input",
      {
        id: "playerID",
        name: "playerID",
        type: "text",
        autoComplete: "off",
        required: true,
        autoFocus: true,
        className: "appearance-none block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-empirica-500 focus:border-empirica-500 sm:text-sm",
        value: playerID,
        onChange: (e) => setPlayerID(e.target.value)
      }
    ), /* @__PURE__ */ import_react5.default.createElement(
      "p",
      {
        className: "mt-2 text-sm text-gray-500",
        id: "playerID-description"
      },
      "This should be given to you. E.g. email, code..."
    ))), /* @__PURE__ */ import_react5.default.createElement("div", null, /* @__PURE__ */ import_react5.default.createElement(
      "button",
      {
        type: "submit",
        className: "w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-empirica-600 hover:bg-empirica-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-empirica-500"
      },
      "Enter"
    )))
  ))));
}

// src/player/react/hooks.ts
var import_react7 = require("react");
var import_rxjs17 = require("rxjs");

// src/player/react/EmpiricaParticipant.tsx
var import_react6 = __toESM(require("react"), 1);

// src/player/context.ts
var import_rxjs16 = require("rxjs");

// src/player/connection.ts
var import_rxjs15 = require("rxjs");
var ParticipantConnection = class {
  constructor(taj, sessions, resetSession) {
    this.resetSession = resetSession;
    this._tajribaPart = bsu();
    this._connected = bs(false);
    this._connecting = bs(false);
    this._stopped = bs(false);
    let session;
    let connected = false;
    this._sessionsSub = subscribeAsync(
      (0, import_rxjs15.merge)(taj.connected, sessions),
      async (sessionOrConnected) => {
        if (typeof sessionOrConnected === "boolean") {
          connected = sessionOrConnected;
        } else {
          session = sessionOrConnected;
        }
        if (!session || !connected) {
          return;
        }
        if (this._connected.getValue() || this._connecting.getValue()) {
          return;
        }
        this._connecting.next(true);
        try {
          const tajPart = await taj.sessionParticipant(
            session.token,
            session.participant
          );
          this._tajribaPart.next(tajPart);
          if (tajPart.connected) {
            this._connected.next(true);
            this._connecting.next(false);
          }
          tajPart.on("connected", () => {
            if (!this._connected.getValue()) {
              this._connected.next(true);
              this._connecting.next(false);
            }
          });
          tajPart.on("disconnected", () => {
            if (this._connected.getValue()) {
              this._connected.next(false);
              this._connecting.next(false);
            }
          });
          tajPart.on("error", (err) => {
            this._connecting.next(false);
            error("conn error", err);
          });
          tajPart.on("accessDenied", () => {
            if (this._connected.getValue()) {
              this._connected.next(false);
              this._connecting.next(false);
            }
            console.log(
              "accessDenied",
              session?.participant.id,
              session?.token
            );
            this.resetSession();
          });
        } catch (err) {
          if (err !== ErrNotConnected) {
            error("new conn error", err);
            this.resetSession();
          }
        }
      }
    );
  }
  stop() {
    if (this._stopped.getValue()) {
      return;
    }
    const taj = this._tajribaPart.getValue();
    if (taj) {
      taj.removeAllListeners("connected");
      taj.removeAllListeners("disconnected");
      taj.stop();
      this._tajribaPart.next(void 0);
    }
    this._sessionsSub.unsubscribe();
    this._connecting.next(false);
    this._connected.next(false);
    this._stopped.next(true);
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    return this._connected;
  }
  get stopped() {
    return this._stopped;
  }
  get participant() {
    return this._tajribaPart;
  }
};
var MemStorage = class {
  static clear() {
    this.vals = {};
  }
  static getItem(key) {
    return this.vals[key];
  }
  static removeItem(key) {
    delete this.vals[key];
  }
  static setItem(key, value) {
    this.vals[key] = value;
  }
};
MemStorage.vals = {};
var isBrowser2 = typeof window !== "undefined" && typeof window.document !== "undefined";
var storage;
if (isBrowser2) {
  storage = window.localStorage;
}
var _ParticipantSession = class {
  constructor(ns, resetSession) {
    this.ns = ns;
    this._token = this.strg.getItem(this.tokenKey) || void 0;
    const participantStr = this.strg.getItem(this.partKey) || void 0;
    if (participantStr) {
      this._participant = JSON.parse(participantStr);
    }
    const sess = this.calcSession();
    this._sessions = bsu(sess);
    resetSession.subscribe({
      next: () => {
        this.clearSession();
      }
    });
  }
  get sessions() {
    return this._sessions;
  }
  get session() {
    return this._sessions.getValue();
  }
  get token() {
    return this._token;
  }
  get participant() {
    return this._participant;
  }
  get tokenKey() {
    return `${_ParticipantSession.tokenKey}:${this.ns}`;
  }
  get partKey() {
    return `${_ParticipantSession.partKey}:${this.ns}`;
  }
  updateSession(token, participant) {
    this.strg.setItem(this.tokenKey, token);
    this.strg.setItem(this.partKey, JSON.stringify(participant));
    this._token = token;
    this._participant = participant;
    this._sessions.next(this.calcSession());
  }
  clearSession() {
    delete this._token;
    delete this._participant;
    this.strg.removeItem(this.tokenKey);
    this.strg.removeItem(this.partKey);
    this._sessions.next(void 0);
  }
  calcSession() {
    if (this._token && this._participant) {
      return {
        token: this._token,
        participant: this._participant
      };
    }
    return void 0;
  }
  get strg() {
    return _ParticipantSession.storage;
  }
};
var ParticipantSession = _ParticipantSession;
ParticipantSession.tokenKey = "empirica:token";
ParticipantSession.partKey = "empirica:participant";
ParticipantSession.storage = storage;

// src/player/context.ts
var ParticipantContext = class {
  constructor(url, ns) {
    /** @internal */
    this.provider = bsu();
    /** @internal */
    this.globals = bsu();
    this.tajriba = new TajribaConnection(url);
    this.resetSession = new import_rxjs16.Subject();
    this.session = new ParticipantSession(ns, this.resetSession);
    this.participant = new ParticipantConnection(
      this.tajriba,
      this.session.sessions,
      this.resetSession.next.bind(this.resetSession)
    );
    subscribeAsync(this.participant.connected, async (connected) => {
      const part = this.participant.participant.getValue();
      if (connected && part) {
        if (!this.provider.getValue()) {
          this.provider.next(
            new TajribaProvider(
              part.changes(),
              this.tajriba.tajriba.globalAttributes(),
              part.setAttributes.bind(part)
            )
          );
        }
      } else {
        const provider = this.provider.getValue();
        if (provider) {
          this.provider.next(void 0);
        }
      }
    });
    subscribeAsync(this.tajriba.connected, async (connected) => {
      if (connected) {
        this.globals.next(new Globals(this.tajriba.tajriba.globalAttributes()));
      } else {
        const glob = this.globals.getValue();
        if (glob) {
          this.globals.next(void 0);
        }
      }
    });
  }
  get connecting() {
    return this.participant.connecting;
  }
  get connected() {
    return this.participant.connected;
  }
  async register(playerIdentifier) {
    if (!this.tajriba.connected.getValue()) {
      throw ErrNotConnected;
    }
    const [token, participant] = await this.tajriba.tajriba.registerParticipant(
      playerIdentifier
    );
    if (!token) {
      throw new Error("invalid registration");
    }
    this.session.updateSession(token, participant);
  }
  stop() {
    this.tajriba.stop();
    this.participant.stop();
  }
};
var ParticipantMode = class {
  constructor(participant, provider, modeFunc) {
    this._mode = new import_rxjs16.BehaviorSubject(void 0);
    subscribeAsync(provider, async (provider2) => {
      const id = participant.getValue()?.id;
      if (id && provider2 && this._mode.getValue()) {
        warn("spurious provider condition");
        window.location.reload();
      }
      if (id && provider2) {
        this._mode.next(modeFunc(id, provider2));
      } else {
        const mode = this._mode.getValue();
        if (mode) {
          this._mode.next(void 0);
        }
      }
    });
  }
  get mode() {
    return this._mode;
  }
};
var ParticipantModeContext = class extends ParticipantContext {
  constructor(url, ns, modeFunc) {
    super(url, ns);
    this._mode = new ParticipantMode(
      this.participant.participant,
      this.provider,
      modeFunc
    );
  }
  get mode() {
    return this._mode.mode;
  }
};

// src/player/react/EmpiricaParticipant.tsx
var ParticipantCtx = import_react6.default.createContext(void 0);
var contexts = {};
function EmpiricaParticipant({
  url,
  ns,
  modeFunc,
  children
}) {
  let partCtx;
  if (ns in contexts) {
    partCtx = contexts[ns];
  } else {
    if (modeFunc) {
      partCtx = new ParticipantModeContext(url, ns, modeFunc);
    } else {
      partCtx = new ParticipantContext(url, ns);
    }
    contexts[ns] = partCtx;
  }
  return /* @__PURE__ */ import_react6.default.createElement(ParticipantCtx.Provider, { value: partCtx }, children);
}

// src/player/react/hooks.ts
function useParticipantContext() {
  return (0, import_react7.useContext)(ParticipantCtx);
}
function useTajribaConnecting() {
  return useTajribaCtxKey("connecting");
}
function useTajribaConnected() {
  return useTajribaCtxKey("connected");
}
function usePartConnected() {
  return usePartCtxKey("connected");
}
function useTajriba() {
  const ctx = useParticipantContext();
  return ctx?.tajriba;
}
function useGlobal() {
  const ctx = usePartCtxKey("globals");
  const [val, setVal] = (0, import_react7.useState)({ g: void 0 });
  (0, import_react7.useEffect)(() => {
    if (!ctx || !ctx.self) {
      return;
    }
    const sub = ctx.self.subscribe({
      next(g) {
        setVal({ g });
      }
    });
    return sub.unsubscribe.bind(sub);
  }, [ctx]);
  return val.g;
}
var defaultConsentKey = "empirica:consent";
function useConsent(ns = "") {
  const key = `${defaultConsentKey}${ns ? `:${ns}` : ""}`;
  const getConsented = () => Boolean(window.localStorage[key]);
  const [consented, setConsented] = (0, import_react7.useState)(getConsented());
  function onConsent() {
    window.localStorage[key] = true;
    setConsented(true);
  }
  return [consented, consented ? void 0 : onConsent];
}
function usePlayerID() {
  const ctx = useParticipantContext();
  const [connecting, setConnecting] = (0, import_react7.useState)(true);
  const [playerID, setPlayerID] = (0, import_react7.useState)(void 0);
  const [changePlayerID, setChangePlayerID] = (0, import_react7.useState)(void 0);
  (0, import_react7.useEffect)(() => {
    if (!ctx) {
      return;
    }
    let _connecting = true;
    let session;
    const sub = (0, import_rxjs17.merge)(
      ctx.participant.connecting,
      ctx.session.sessions
    ).subscribe({
      next(sessionOrConnecting) {
        if (typeof sessionOrConnecting === "boolean") {
          setConnecting(sessionOrConnecting);
          _connecting = sessionOrConnecting;
        } else {
          session = sessionOrConnecting;
        }
        if (_connecting) {
          setPlayerID(void 0);
          setChangePlayerID(void 0);
        } else if (!session) {
          setPlayerID(void 0);
          setChangePlayerID(() => async (playerIdentifier) => {
            await ctx.register(playerIdentifier);
          });
        } else {
          setPlayerID(session.participant.identifier);
          setChangePlayerID(void 0);
        }
      }
    });
    return sub.unsubscribe.bind(sub);
  }, [ctx]);
  return [connecting, playerID, changePlayerID];
}
function useTajribaCtxKey(name) {
  return useCtxKey(useTajriba, name);
}
function usePartCtxKey(name) {
  return useCtxKey(useParticipantContext, name);
}
function useCtxKey(ctxFunc, name) {
  const ctx = ctxFunc();
  const [val, setVal] = (0, import_react7.useState)(void 0);
  (0, import_react7.useEffect)(() => {
    if (!ctx || !ctx[name]) {
      return;
    }
    const obs = ctx[name];
    const sub = obs.subscribe({
      next(g) {
        setVal(g);
      }
    });
    return sub.unsubscribe.bind(sub);
  }, [ctx]);
  return val;
}

// src/player/classic/react/Lobby.tsx
var import_react9 = __toESM(require("react"), 1);

// src/player/classic/react/hooks.ts
var import_react8 = require("react");
function usePlayer() {
  return usePartModeCtxKey(
    "player"
  );
}
function useGame() {
  return usePartModeCtxKey("game");
}
function useRound() {
  return usePartModeCtxKey(
    "round"
  );
}
function useStage() {
  return usePartModeCtxKey(
    "stage"
  );
}
function useStageTimer() {
  const stage = useStage();
  const [val, setVal] = (0, import_react8.useState)({
    tick: stage?.timer?.current
  });
  const timerSubscription = (0, import_react8.useRef)(null);
  (0, import_react8.useEffect)(() => {
    if (!stage || !stage.timer) {
      return;
    }
    if (timerSubscription.current === null) {
      timerSubscription.current = stage.timer.obs().subscribe({
        next(val2) {
          setVal({ tick: val2 });
        }
      });
    }
    return () => {
      timerSubscription?.current?.unsubscribe.bind(timerSubscription.current);
      timerSubscription.current = null;
    };
  }, [stage?.timer]);
  return val.tick;
}
function usePlayers() {
  return usePartModeCtxKey(
    "players"
  );
}
function usePartModeCtx() {
  const ctx = useParticipantContext();
  const [mode, setMode] = (0, import_react8.useState)({
    data: ctx?.mode?.getValue()
  });
  (0, import_react8.useEffect)(() => {
    if (!ctx || !ctx.mode) {
      return;
    }
    const sub = ctx.mode.subscribe({
      next(m) {
        setMode({ data: m });
      }
    });
    return sub.unsubscribe.bind(sub);
  }, [ctx]);
  return mode.data;
}
function usePartModeCtxKey(name) {
  const mode = usePartModeCtx();
  const iniVal = mode && mode[name];
  const [val, setVal] = (0, import_react8.useState)({
    data: iniVal?.getValue()
  });
  (0, import_react8.useEffect)(() => {
    if (!mode) {
      return;
    }
    const obs = mode[name];
    const sub = obs.subscribe({
      next(val2) {
        setVal({ data: val2 });
      }
    });
    return sub.unsubscribe.bind(sub);
  }, [mode]);
  return val.data;
}

// src/player/classic/react/Lobby.tsx
function Lobby2() {
  const player = usePlayer();
  if (!player) {
    return /* @__PURE__ */ import_react9.default.createElement(Loading, null);
  }
  const treatment = player.get("treatment");
  if (!treatment || !treatment.playerCount) {
    warn("lobby: no treatment found on player");
    return /* @__PURE__ */ import_react9.default.createElement(Loading, null);
  }
  return /* @__PURE__ */ import_react9.default.createElement("div", { className: "flex h-full items-center justify-center" }, /* @__PURE__ */ import_react9.default.createElement("div", { className: "text-center" }, /* @__PURE__ */ import_react9.default.createElement(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 640 512",
      className: "mx-auto h-12 w-12 text-gray-400",
      stroke: "none",
      fill: "currentColor",
      "aria-hidden": "true"
    },
    /* @__PURE__ */ import_react9.default.createElement("path", { d: "M544 224c44.2 0 80-35.8 80-80s-35.8-80-80-80-80 35.8-80 80 35.8 80 80 80zm0-128c26.5 0 48 21.5 48 48s-21.5 48-48 48-48-21.5-48-48 21.5-48 48-48zM320 256c61.9 0 112-50.1 112-112S381.9 32 320 32 208 82.1 208 144s50.1 112 112 112zm0-192c44.1 0 80 35.9 80 80s-35.9 80-80 80-80-35.9-80-80 35.9-80 80-80zm244 192h-40c-15.2 0-29.3 4.8-41.1 12.9 9.4 6.4 17.9 13.9 25.4 22.4 4.9-2.1 10.2-3.3 15.7-3.3h40c24.2 0 44 21.5 44 48 0 8.8 7.2 16 16 16s16-7.2 16-16c0-44.1-34.1-80-76-80zM96 224c44.2 0 80-35.8 80-80s-35.8-80-80-80-80 35.8-80 80 35.8 80 80 80zm0-128c26.5 0 48 21.5 48 48s-21.5 48-48 48-48-21.5-48-48 21.5-48 48-48zm304.1 180c-33.4 0-41.7 12-80.1 12-38.4 0-46.7-12-80.1-12-36.3 0-71.6 16.2-92.3 46.9-12.4 18.4-19.6 40.5-19.6 64.3V432c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48v-44.8c0-23.8-7.2-45.9-19.6-64.3-20.7-30.7-56-46.9-92.3-46.9zM480 432c0 8.8-7.2 16-16 16H176c-8.8 0-16-7.2-16-16v-44.8c0-16.6 4.9-32.7 14.1-46.4 13.8-20.5 38.4-32.8 65.7-32.8 27.4 0 37.2 12 80.2 12s52.8-12 80.1-12c27.3 0 51.9 12.3 65.7 32.8 9.2 13.7 14.1 29.8 14.1 46.4V432zM157.1 268.9c-11.9-8.1-26-12.9-41.1-12.9H76c-41.9 0-76 35.9-76 80 0 8.8 7.2 16 16 16s16-7.2 16-16c0-26.5 19.8-48 44-48h40c5.5 0 10.8 1.2 15.7 3.3 7.5-8.5 16.1-16 25.4-22.4z" })
  ), /* @__PURE__ */ import_react9.default.createElement("h3", { className: "mt-2 text-sm font-medium text-gray-900" }, treatment.playerCount > 1 ? "Waiting for other players" : "Game loading"), /* @__PURE__ */ import_react9.default.createElement("p", { className: "mt-1 text-sm text-gray-500" }, "Please wait for the game to be ready.")));
}

// src/player/classic/react/Steps.tsx
var import_react10 = __toESM(require("react"), 1);
function Steps2({
  steps,
  progressKey,
  doneKey,
  object,
  children
}) {
  let obj;
  const game = useGame();
  const player = usePlayer();
  const [stps, setStps] = (0, import_react10.useState)([]);
  const [stpsSet, setStpsSet] = (0, import_react10.useState)(false);
  (0, import_react10.useEffect)(() => {
    let s;
    if (typeof steps === "function") {
      s = steps({ game, player });
    } else {
      s = steps;
    }
    setStps(s);
    setStpsSet(true);
  }, [steps]);
  (0, import_react10.useEffect)(() => {
    if (stpsSet && (!stps || stps.length === 0)) {
      obj.set(doneKey, true);
    }
  }, [stps]);
  if (object) {
    obj = object;
  } else if (player) {
    obj = player;
  } else {
    error("no receiver and no player in Steps");
    return /* @__PURE__ */ import_react10.default.createElement("div", null, "Missing attribute");
  }
  if (obj.get(doneKey)) {
    return /* @__PURE__ */ import_react10.default.createElement(import_react10.default.Fragment, null, children);
  }
  const index = obj.get(progressKey) || 0;
  const next = () => {
    if (index + 1 >= stps.length) {
      obj.set(doneKey, true);
    } else {
      obj.set(progressKey, index + 1);
    }
  };
  const previous = () => {
    if (index > 0) {
      obj.set(progressKey, index - 1);
    }
  };
  const Step3 = stps[index];
  if (!Step3) {
    return /* @__PURE__ */ import_react10.default.createElement(import_react10.default.Fragment, null);
  }
  return /* @__PURE__ */ import_react10.default.createElement(Step3, { index, previous, next });
}

// src/player/classic/react/EmpiricaContext.tsx
function EmpiricaContext({
  noGames: NoGamesComp = NoGames,
  consent: ConsentComp = Consent,
  playerCreate: PlayerCreateForm = PlayerCreate,
  introSteps = [],
  lobby = Lobby2,
  exitSteps = [],
  finished = Finished,
  loading: LoadingComp = Loading,
  connecting: ConnectingComp = Loading,
  unmanagedGame = false,
  unmanagedAssignment = false,
  disableConsent = false,
  disableNoGames = false,
  disableURLParamsCapture = false,
  children
}) {
  const tajribaConnected = useTajribaConnected();
  const participantConnected = usePartConnected();
  const globals = useGlobal();
  const player = usePlayer();
  const game = useGame();
  const [connecting, hasPlayer, onPlayerID] = usePlayerID();
  const [consented, onConsent] = useConsent();
  if (!tajribaConnected || connecting) {
    return /* @__PURE__ */ import_react11.default.createElement(ConnectingComp, null);
  }
  if (player && player.get("ended")) {
    return /* @__PURE__ */ import_react11.default.createElement(Exit, { exitSteps, finished });
  }
  if (!globals || hasPlayer && (!participantConnected || !player || game === void 0)) {
    return /* @__PURE__ */ import_react11.default.createElement(LoadingComp, null);
  }
  if (!disableNoGames && !globals.get("experimentOpen") && (!hasPlayer || !player?.get("gameID"))) {
    return /* @__PURE__ */ import_react11.default.createElement(NoGamesComp, null);
  }
  if (!disableConsent && !consented) {
    return /* @__PURE__ */ import_react11.default.createElement(ConsentComp, { onConsent });
  }
  if (!hasPlayer) {
    return /* @__PURE__ */ import_react11.default.createElement(PlayerCreateForm, { onPlayerID, connecting });
  }
  if (!player || !game) {
    return /* @__PURE__ */ import_react11.default.createElement(LoadingComp, null);
  }
  if (!disableURLParamsCapture && !player.get("urlParams")) {
    const urlParams = new URLSearchParams(window.location.search);
    player.set("urlParams", Object.fromEntries(urlParams.entries()));
  }
  if (unmanagedAssignment) {
    return /* @__PURE__ */ import_react11.default.createElement(import_react11.default.Fragment, null, children);
  }
  if (game && game.hasEnded) {
    return /* @__PURE__ */ import_react11.default.createElement(Exit, { exitSteps, finished });
  }
  return /* @__PURE__ */ import_react11.default.createElement(Steps2, { progressKey: "intro", doneKey: "introDone", steps: introSteps }, /* @__PURE__ */ import_react11.default.createElement(
    EmpiricaInnerContext,
    {
      exitSteps,
      lobby,
      finished,
      loading: LoadingComp,
      unmanagedGame
    },
    children
  ));
}
function EmpiricaInnerContext({
  children,
  lobby: Lobby3,
  finished,
  exitSteps,
  loading: LoadingComp,
  unmanagedGame = false
}) {
  const game = useGame();
  const stage = useStage();
  const round = useRound();
  if (!game) {
    return /* @__PURE__ */ import_react11.default.createElement(LoadingComp, null);
  }
  if (!Boolean(game.get("status"))) {
    return /* @__PURE__ */ import_react11.default.createElement(Lobby3, null);
  }
  if (game.hasEnded) {
    return /* @__PURE__ */ import_react11.default.createElement(Exit, { exitSteps, finished });
  }
  if (!unmanagedGame && (!stage || !round)) {
    return /* @__PURE__ */ import_react11.default.createElement(LoadingComp, null);
  }
  return /* @__PURE__ */ import_react11.default.createElement(import_react11.default.Fragment, null, children);
}
function Exit({
  exitSteps,
  finished: Finished2
}) {
  return /* @__PURE__ */ import_react11.default.createElement(Steps2, { progressKey: "exitStep", doneKey: "exitStepDone", steps: exitSteps }, /* @__PURE__ */ import_react11.default.createElement(Finished2, null));
}

// src/player/classic/react/Quiz.tsx
var import_react12 = __toESM(require("react"), 1);
function Quiz({ next }) {
  const labelClassName = "block text-sm font-medium text-gray-700 mb-2";
  const inputClassName = "appearance-none block px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-empirica-500 focus:border-empirica-500 sm:text-sm";
  const [sum, setSum] = (0, import_react12.useState)("");
  const [horse, setHorse] = (0, import_react12.useState)("");
  function handleSubmit(e) {
    e.preventDefault();
    if (sum !== "4" || horse !== "white") {
      alert("Incorrect! Read the instructions and please try again.");
    } else {
      next();
    }
  }
  return /* @__PURE__ */ import_react12.default.createElement("div", { className: "flex justify-center" }, /* @__PURE__ */ import_react12.default.createElement("div", { className: "mt-6 sm:mt-24" }, /* @__PURE__ */ import_react12.default.createElement("h3", { className: "text-2xl font-semi-bold text-gray-900" }, "Quiz"), /* @__PURE__ */ import_react12.default.createElement("form", { className: "mt-4", onSubmit: handleSubmit }, /* @__PURE__ */ import_react12.default.createElement("p", { className: "mb-5" }, /* @__PURE__ */ import_react12.default.createElement("label", { className: labelClassName }, "What is 2+2?"), /* @__PURE__ */ import_react12.default.createElement(
    "input",
    {
      className: inputClassName,
      type: "text",
      dir: "auto",
      id: "sum",
      name: "sum",
      placeholder: "e.g. 3",
      value: sum,
      onChange: (e) => setSum(e.target.value),
      autoComplete: "off",
      autoFocus: true,
      required: true
    }
  )), /* @__PURE__ */ import_react12.default.createElement("p", { className: "mb-5" }, /* @__PURE__ */ import_react12.default.createElement("label", { className: labelClassName }, "What color was Napoleon's white horse?"), /* @__PURE__ */ import_react12.default.createElement(
    "input",
    {
      className: inputClassName,
      type: "text",
      dir: "auto",
      id: "horse",
      name: "horse",
      placeholder: "brown",
      value: horse,
      onChange: (e) => setHorse(e.target.value),
      autoComplete: "off",
      required: true
    }
  )), /* @__PURE__ */ import_react12.default.createElement(
    "button",
    {
      type: "submit",
      className: "inline-flex items-center px-4 py-2 border text-sm font-medium rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-empirica-500"
    },
    "Submit"
  ))));
}

// src/player/classic/react/Slider.tsx
var import_react13 = __toESM(require("react"), 1);
function Slider({
  value,
  onChange,
  min = 0,
  max = 100,
  stepSize = 1,
  disabled = false
}) {
  const noVal = value === null || value === void 0;
  const val = noVal ? (max - min) / 2 : value;
  const cls = noVal ? "slider-thumb-zero" : "slider-thumb";
  const ref = (0, import_react13.useRef)(null);
  if (value !== null && ref.current) {
    const nmin = min ? min : 0;
    const nmax = max ? max : 100;
    const newVal = Number((value - nmin) * 100 / (nmax - nmin));
    ref.current.style.left = `calc(${newVal}% + (${8 - newVal * 0.15}px))`;
  }
  return /* @__PURE__ */ import_react13.default.createElement("div", { className: "relative w-full" }, /* @__PURE__ */ import_react13.default.createElement(
    "input",
    {
      className: cls,
      type: "range",
      min,
      max,
      step: stepSize,
      value: val,
      onChange,
      disabled
    }
  ), noVal ? "" : /* @__PURE__ */ import_react13.default.createElement(
    "output",
    {
      ref,
      className: "font-mono absolute w-12 h-7 flex items-center justify-center left-1/2 bottom-7 rounded transform -translate-x-1/2 bg-gray-200"
    },
    value
  ));
}

// src/player/classic/react/chat/Chat.tsx
var import_react16 = __toESM(require("react"), 1);

// src/player/react/EmpiricaMenu.tsx
var import_react15 = __toESM(require("react"), 1);

// src/player/react/Logo.tsx
var import_react14 = __toESM(require("react"), 1);
function Logo() {
  return /* @__PURE__ */ import_react14.default.createElement(
    "svg",
    {
      className: "h-full w-full fill-current",
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 195 185"
    },
    /* @__PURE__ */ import_react14.default.createElement("path", { d: "M25.164 81.9737C22.31 81.9737 19.998 84.2877 20 87.1417L20.028 128.458C20.03 131.309 22.341 133.619 25.192 133.619C28.046 133.619 30.359 131.304 30.357 128.451L30.328 87.1347C30.326 84.2837 28.015 81.9737 25.164 81.9737Z" }),
    /* @__PURE__ */ import_react14.default.createElement("path", { d: "M87.1367 61.3158C84.2837 61.3158 81.9707 63.6298 81.9727 66.4828L82.0017 118.128C82.0037 120.979 84.3147 123.29 87.1667 123.29C90.0197 123.29 92.3327 120.976 92.3307 118.122L92.3007 66.4778C92.2997 63.6258 89.9877 61.3158 87.1367 61.3158Z" }),
    /* @__PURE__ */ import_react14.default.createElement("path", { d: "M107.793 20C104.94 20 102.628 22.313 102.629 25.166L102.661 159.442C102.662 162.294 104.974 164.605 107.826 164.605C110.679 164.605 112.991 162.293 112.99 159.44L112.957 25.163C112.957 22.311 110.645 20 107.793 20Z" }),
    /* @__PURE__ */ import_react14.default.createElement("path", { d: "M128.451 20C125.598 20 123.286 22.313 123.287 25.166L123.319 159.442C123.32 162.294 125.632 164.605 128.484 164.605C131.337 164.605 133.649 162.293 133.648 159.44L133.615 25.163C133.615 22.311 131.303 20 128.451 20Z" }),
    /* @__PURE__ */ import_react14.default.createElement("path", { d: "M149.11 20C146.257 20 143.944 22.313 143.946 25.167L143.977 102.634C143.978 105.485 146.29 107.796 149.141 107.796C151.994 107.796 154.307 105.483 154.306 102.63L154.274 25.162C154.273 22.311 151.961 20 149.11 20Z" }),
    /* @__PURE__ */ import_react14.default.createElement("path", { d: "M169.75 40.6579C166.897 40.6579 164.585 42.9709 164.586 45.8239L164.617 138.785C164.618 141.637 166.93 143.948 169.782 143.948C172.635 143.948 174.947 141.634 174.946 138.781L174.914 45.8209C174.914 42.9689 172.602 40.6579 169.75 40.6579Z" }),
    /* @__PURE__ */ import_react14.default.createElement("path", { d: "M45.8203 61.3158C42.9673 61.3158 40.6553 63.6288 40.6563 66.4818L40.6873 159.443C40.6883 162.295 43.0003 164.606 45.8523 164.606C48.7053 164.606 51.0173 162.292 51.0163 159.439L50.9843 66.4788C50.9843 63.6268 48.6723 61.3158 45.8203 61.3158Z" }),
    /* @__PURE__ */ import_react14.default.createElement("path", { d: "M66.4785 61.3158C63.6255 61.3158 61.3135 63.6288 61.3145 66.4818L61.3455 159.443C61.3465 162.295 63.6585 164.606 66.5105 164.606C69.3635 164.606 71.6755 162.292 71.6745 159.439L71.6425 66.4788C71.6415 63.6268 69.3305 61.3158 66.4785 61.3158Z" })
  );
}

// src/player/react/EmpiricaMenu.tsx
function EmpiricaMenu({ position = "bottom-left" }) {
  const ctx = useParticipantContext();
  if (!ctx) {
    return null;
  }
  function resetSession() {
    ctx.session.clearSession();
    window.location.reload();
  }
  let className = "backdrop-blur-md bg-gray-200/50 rounded fixed z-20 flex space-x-1 text-gray-500";
  switch (position) {
    case "top":
      className += " top-0 mt-2 ml-1/2 -translate-x-1/2";
      break;
    case "top-left":
      className += " top-0 left-0 mt-2 ml-2";
      break;
    case "top-right":
      className += " top-0 right-0 mt-2 mr-2";
      break;
    case "bottom":
      className += " bottom-0 mb-2 ml-1/2 -translate-x-1/2";
      break;
    case "bottom-right":
      className += " bottom-0 right-0 mb-2 mr-2";
      break;
    case "bottom-left":
    default:
      className += " bottom-0 left-0 mb-2 ml-2";
      break;
  }
  const buttons = [
    {
      onClick: () => {
        window.open("https://empirica.ly", "_blank");
      },
      icon: /* @__PURE__ */ import_react15.default.createElement(Logo, null),
      title: "Empirica"
    },
    {
      onClick: () => createNewParticipant(),
      icon: /* @__PURE__ */ import_react15.default.createElement(
        "svg",
        {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 24 24",
          fill: "none",
          strokeWidth: "2",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          className: "h-full w-full stroke-current"
        },
        /* @__PURE__ */ import_react15.default.createElement("path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" }),
        /* @__PURE__ */ import_react15.default.createElement("circle", { cx: "9", cy: "7", r: "4" }),
        /* @__PURE__ */ import_react15.default.createElement("line", { x1: "19", x2: "19", y1: "8", y2: "14" }),
        /* @__PURE__ */ import_react15.default.createElement("line", { x1: "22", x2: "16", y1: "11", y2: "11" })
      ),
      inDevOnly: true,
      title: "New Participant"
    },
    {
      onClick: resetSession,
      icon: /* @__PURE__ */ import_react15.default.createElement(
        "svg",
        {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 24 24",
          fill: "none",
          strokeWidth: "2",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          className: "h-full w-full stroke-current"
        },
        /* @__PURE__ */ import_react15.default.createElement("path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" }),
        /* @__PURE__ */ import_react15.default.createElement("path", { d: "M3 3v5h5" })
      ),
      inDevOnly: true,
      title: "Reset Session"
    },
    {
      onClick: () => {
        window.open("/admin", "_blank");
      },
      icon: /* @__PURE__ */ import_react15.default.createElement(
        "svg",
        {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 24 24",
          fill: "none",
          strokeWidth: "2",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          className: "h-full w-full stroke-current"
        },
        /* @__PURE__ */ import_react15.default.createElement("path", { d: "M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z" })
      ),
      inDevOnly: true,
      title: "Admin"
    },
    {
      onClick: () => {
        window.open("https://docs.empirica.ly", "_blank");
      },
      icon: /* @__PURE__ */ import_react15.default.createElement(
        "svg",
        {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 24 24",
          fill: "none",
          strokeWidth: "2",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          className: "h-full w-full stroke-current"
        },
        /* @__PURE__ */ import_react15.default.createElement("path", { d: "M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z" }),
        /* @__PURE__ */ import_react15.default.createElement("path", { d: "M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z" })
      ),
      inDevOnly: true,
      title: "Documentation"
    }
  ];
  return /* @__PURE__ */ import_react15.default.createElement("div", { className }, buttons.map((button, i) => {
    let sizing = "";
    if (i === 0) {
      sizing = "w-9 h-8 p-1.5 pl-2.5";
      if (buttons.length === 0) {
        sizing += " pr-2.5";
      }
    } else if (i === buttons.length - 1) {
      sizing += "w-8.5 h-8 p-2 pr-2.5";
    }
    return /* @__PURE__ */ import_react15.default.createElement(ToolButton, { key: i, ...button, sizing });
  }));
}
function ToolButton({
  onClick,
  icon,
  title,
  sizing = "",
  inDevOnly = false
}) {
  if (inDevOnly && !isDevelopment) {
    return /* @__PURE__ */ import_react15.default.createElement(import_react15.default.Fragment, null);
  }
  let size = "w-8 h-8 p-2";
  if (sizing) {
    size = sizing;
  }
  let className = "block bg-transparent hover:text-empirica-600 hover:bg-gray-300 rounded " + size;
  return /* @__PURE__ */ import_react15.default.createElement("button", { onClick, className, title }, icon);
}

// src/player/classic/react/chat/Chat.tsx
function Chat({
  scope,
  attribute = "messages",
  loading: LoadingComp = Loading
}) {
  const player = usePlayer();
  if (!scope || !player) {
    return /* @__PURE__ */ import_react16.default.createElement(LoadingComp, null);
  }
  const handleNewMessage = (text) => {
    scope.append(attribute, {
      text,
      sender: {
        id: player.id,
        name: player.get("name") || player.id,
        avatar: player.get("avatar")
      }
    });
  };
  const msgs = scope.getAttribute(attribute)?.items || [];
  return /* @__PURE__ */ import_react16.default.createElement("div", { className: "h-full w-full flex flex-col" }, /* @__PURE__ */ import_react16.default.createElement(Messages, { msgs }), /* @__PURE__ */ import_react16.default.createElement(Input, { onNewMessage: handleNewMessage }));
}
function Messages(props) {
  const { msgs } = props;
  const scroller = (0, import_react16.useRef)(null);
  const [msgCount, setMsgCount] = (0, import_react16.useState)(0);
  (0, import_react16.useEffect)(() => {
    if (!scroller.current) {
      return;
    }
    if (msgCount !== msgs.length) {
      setMsgCount(msgs.length);
      scroller.current.scrollTop = scroller.current.scrollHeight;
    }
  }, [scroller, props, msgCount]);
  if (msgs.length === 0) {
    return /* @__PURE__ */ import_react16.default.createElement("div", { className: "h-full w-full flex justify-center items-center" }, /* @__PURE__ */ import_react16.default.createElement("div", { className: "flex flex-col justify-center items-center w-2/3 space-y-2" }, /* @__PURE__ */ import_react16.default.createElement("div", { className: "w-24 h-24 text-gray-200" }, /* @__PURE__ */ import_react16.default.createElement(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        className: "h-full w-full fill-current",
        viewBox: "0 0 512 512"
      },
      /* @__PURE__ */ import_react16.default.createElement("path", { d: "M123.6 391.3c12.9-9.4 29.6-11.8 44.6-6.4c26.5 9.6 56.2 15.1 87.8 15.1c124.7 0 208-80.5 208-160s-83.3-160-208-160S48 160.5 48 240c0 32 12.4 62.8 35.7 89.2c8.6 9.7 12.8 22.5 11.8 35.5c-1.4 18.1-5.7 34.7-11.3 49.4c17-7.9 31.1-16.7 39.4-22.7zM21.2 431.9c1.8-2.7 3.5-5.4 5.1-8.1c10-16.6 19.5-38.4 21.4-62.9C17.7 326.8 0 285.1 0 240C0 125.1 114.6 32 256 32s256 93.1 256 208s-114.6 208-256 208c-37.1 0-72.3-6.4-104.1-17.9c-11.9 8.7-31.3 20.6-54.3 30.6c-15.1 6.6-32.3 12.6-50.1 16.1c-.8 .2-1.6 .3-2.4 .5c-4.4 .8-8.7 1.5-13.2 1.9c-.2 0-.5 .1-.7 .1c-5.1 .5-10.2 .8-15.3 .8c-6.5 0-12.3-3.9-14.8-9.9c-2.5-6-1.1-12.8 3.4-17.4c4.1-4.2 7.8-8.7 11.3-13.5c1.7-2.3 3.3-4.6 4.8-6.9c.1-.2 .2-.3 .3-.5z" })
    )), /* @__PURE__ */ import_react16.default.createElement("h4", { className: "text-gray-700 font-semibold" }, "No chat yet"), /* @__PURE__ */ import_react16.default.createElement("p", { className: "text-gray-500 text-center" }, "Send a message to start the conversation.")));
  }
  return /* @__PURE__ */ import_react16.default.createElement("div", { className: "h-full overflow-auto pl-2 pr-4 pb-2", ref: scroller }, msgs.map((msg) => /* @__PURE__ */ import_react16.default.createElement(MessageComp, { key: msg.id, attribute: msg })));
}
function MessageComp({ attribute }) {
  const msg = attribute.value;
  const ts = attribute.createdAt;
  let avatar = msg.sender.avatar;
  if (!avatar) {
    avatar = `https://avatars.dicebear.com/api/identicon/${msg.sender.id}.svg`;
  }
  let avatarImage = /* @__PURE__ */ import_react16.default.createElement(
    "img",
    {
      className: "inline-block h-9 w-9 rounded-full",
      src: avatar,
      alt: msg.sender.id
    }
  );
  if (!avatar.startsWith("http")) {
    avatarImage = /* @__PURE__ */ import_react16.default.createElement("div", { className: "inline-block h-9 w-9 rounded-full" }, avatar);
  }
  return /* @__PURE__ */ import_react16.default.createElement("div", { className: "flex items-start my-2" }, /* @__PURE__ */ import_react16.default.createElement("div", { className: "flex-shrink-0" }, avatarImage), /* @__PURE__ */ import_react16.default.createElement("div", { className: "ml-3 text-sm" }, /* @__PURE__ */ import_react16.default.createElement("p", null, /* @__PURE__ */ import_react16.default.createElement("span", { className: "font-semibold text-gray-900 group-hover:text-gray-800" }, msg.sender.name), /* @__PURE__ */ import_react16.default.createElement("span", { className: "pl-2 text-gray-400" }, ts && relTime(ts))), /* @__PURE__ */ import_react16.default.createElement("p", { className: "text-gray-900 group-hover:text-gray-800" }, msg.text)));
}
function Input({ onNewMessage }) {
  const [text, setText] = (0, import_react16.useState)("");
  const resize = (e) => {
    const target = e.target;
    target.style.height = "inherit";
    target.style.height = `${Math.min(target.scrollHeight, 200)}px`;
  };
  const handleSubmit = (e) => {
    e.preventDefault();
    const txt = text.trim();
    if (txt === "") {
      return;
    }
    if (txt.length > 1024) {
      e.preventDefault();
      alert("Max message length is 1024");
      return;
    }
    onNewMessage(txt);
    setText("");
  };
  const handleKeyDown = (e) => {
    if (e.key === "Enter" && e.shiftKey === false) {
      handleSubmit(e);
      resize(e);
    }
  };
  const handleKeyUp = (e) => {
    resize(e);
  };
  return /* @__PURE__ */ import_react16.default.createElement(
    "form",
    {
      className: "p-2 flex items-strech gap-2 border-t",
      onSubmit: handleSubmit
    },
    /* @__PURE__ */ import_react16.default.createElement(
      "textarea",
      {
        name: "message",
        id: "message",
        rows: 1,
        className: "peer resize-none bg-transparent block w-full rounded-md border-0 py-1.5 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-200 placeholder:text-gray-300 focus:ring-2 focus:ring-inset focus:ring-empirica-500 sm:text-sm sm:leading-6",
        placeholder: "Say something",
        onKeyDown: handleKeyDown,
        onKeyUp: handleKeyUp,
        value: text,
        onChange: (e) => setText(e.target.value)
      }
    ),
    /* @__PURE__ */ import_react16.default.createElement(
      "button",
      {
        type: "button",
        className: "rounded-md bg-gray-100 w-9 h-9 p-2 text-sm font-semibold text-gray-500 shadow-sm hover:bg-gray-200 hover:text-empirica-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-empirica-500",
        onClick: handleSubmit
      },
      /* @__PURE__ */ import_react16.default.createElement(
        "svg",
        {
          xmlns: "http://www.w3.org/2000/svg",
          className: "h-full w-full fill-current",
          viewBox: "0 0 512 512"
        },
        /* @__PURE__ */ import_react16.default.createElement("path", { d: "M498.1 5.6c10.1 7 15.4 19.1 13.5 31.2l-64 416c-1.5 9.7-7.4 18.2-16 23s-18.9 5.4-28 1.6L284 427.7l-68.5 74.1c-8.9 9.7-22.9 12.9-35.2 8.1S160 493.2 160 480V396.4c0-4 1.5-7.8 4.2-10.7L331.8 202.8c5.8-6.3 5.6-16-.4-22s-15.7-6.4-22-.7L106 360.8 17.7 316.6C7.1 311.3 .3 300.7 0 288.9s5.9-22.8 16.1-28.7l448-256c10.7-6.1 23.9-5.5 34 1.4z" })
      )
    )
  );
}
function relTime(date) {
  const difference = ((/* @__PURE__ */ new Date()).getTime() - date.getTime()) / 1e3;
  if (difference < 60) {
    return `now`;
  } else if (difference < 3600) {
    return `${Math.floor(difference / 60)}m`;
  } else if (difference < 86400) {
    return `${Math.floor(difference / 3600)}h`;
  } else if (difference < 2620800) {
    return `${Math.floor(difference / 86400)} days ago`;
  } else if (difference < 31449600) {
    return `${Math.floor(difference / 2620800)} months ago`;
  } else {
    return `${Math.floor(difference / 31449600)} years ago`;
  }
}

// src/player/classic/react/examples/Sweeper.tsx
var import_react18 = __toESM(require("react"), 1);
var buttonStyle = {
  width: 40,
  height: 40,
  backgroundColor: "#888",
  color: "black",
  verticalAlign: "top",
  fontSize: "32px",
  borderLeft: "5px solid rgb(220,220,220)",
  borderTop: "5px solid rgb(220,220,220)",
  borderBottom: "5px solid #333",
  borderRight: "5px solid #333",
  display: "inline-block"
};
var visitStyle = {
  width: 40,
  height: 40,
  itemsAlign: "center",
  backgroundColor: "#555",
  color: "white",
  fontWeight: "bold",
  border: "1px solid black",
  verticalAlign: "top",
  fontSize: "24px",
  display: "inline-block"
};
function Sweeper() {
  const round = useRound();
  if (!round) {
    return null;
  }
  const player = usePlayer();
  if (!player) {
    return null;
  }
  const visited = round.get("visited");
  const bombs = round.get("bombs");
  const lost = round.get("lost");
  (0, import_react18.useEffect)(function() {
    generateBombs();
  }, []);
  function generateBombs() {
    if (bombs || !round) {
      return;
    }
    let bombArr = new Array(10).fill(0).map(() => new Array(10).fill(0));
    for (let i = 0; i < bombArr.length; i++) {
      let bombPos = Math.floor(Math.random() * 10);
      bombArr[i][bombPos] = "X";
    }
    for (let i = 0; i < bombArr.length; i++) {
      for (let j = 0; j < bombArr[i].length; j++) {
        if (bombArr[i][j] !== "X") {
          let sum = 0;
          if (i > 0 && bombArr[i - 1][j] == "X")
            sum++;
          if (i < bombArr.length - 1 && bombArr[i + 1][j] == "X")
            sum++;
          if (j < bombArr.length - 1 && bombArr[i][j + 1] == "X")
            sum++;
          if (j > 0 && bombArr[i][j - 1] == "X")
            sum++;
          if (i < bombArr.length - 1 && j > 0 && bombArr[i + 1][j - 1] == "X")
            sum++;
          if (i < bombArr.length - 1 && j < bombArr.length - 1 && bombArr[i + 1][j + 1] == "X")
            sum++;
          if (i > 0 && j > 0 && bombArr[i - 1][j - 1] == "X")
            sum++;
          if (i > 0 && j < bombArr.length - 1 && bombArr[i - 1][j + 1] == "X")
            sum++;
          bombArr[i][j] = sum;
        }
      }
    }
    round.set("bombs", bombArr);
    let cover = Array(10).fill(0).map(() => Array(10).fill(0));
    round.set("visited", cover);
  }
  const visitCell = (i, j) => {
    if (lost || !bombs || !visited) {
      return;
    }
    if (bombs[i][j] === "X") {
      round.set("lost", true);
    }
    dfsCells(i, j);
    visited[i][j] = 1;
    round.set("visited", [...visited]);
  };
  function dfsCells(i, j) {
    if (!round || !bombs || !visited) {
      return;
    }
    if (i < 0 || i > visited.length - 1 || j < 0 || j > visited[0].length - 1 || visited[i][j] == 1 || bombs[i][j] == "X")
      return;
    visited[i][j] = 1;
    round.set("visited", [...visited]);
    const cell = bombs[i][j];
    if (typeof cell === "number" && cell < 1) {
      dfsCells(i + 1, j);
      dfsCells(i - 1, j);
      dfsCells(i, j + 1);
      dfsCells(i, j - 1);
    }
  }
  if (!bombs) {
    return null;
  }
  return /* @__PURE__ */ import_react18.default.createElement("div", { className: "text-sm relative" }, lost ? /* @__PURE__ */ import_react18.default.createElement(import_react18.default.Fragment, null, /* @__PURE__ */ import_react18.default.createElement("div", { className: "absolute h-full w-full flex items-center justify-center text-6xl white font-black bg-opacity-50 bg-gray-300" }, "YOU LOST"), /* @__PURE__ */ import_react18.default.createElement("div", { className: "absolute h-full w-full flex items-center justify-center text-6xl white font-black mt-1 ml-1 text-white" }, "YOU LOST")) : "", bombs.map((arr, index) => /* @__PURE__ */ import_react18.default.createElement("div", { key: index }, arr.map((_, i) => /* @__PURE__ */ import_react18.default.createElement(
    "div",
    {
      key: i,
      onClick: () => visitCell(index, i),
      style: visited[index][i] == 0 ? buttonStyle : visitStyle
    },
    /* @__PURE__ */ import_react18.default.createElement("div", { className: "h-full w-full flex items-center justify-center" }, visited[index][i] == 0 ? null : bombs[index][i] == 0 ? "" : bombs[index][i])
  )))));
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Attribute,
  Attributes,
  Chat,
  Classic,
  ClassicListenersCollector,
  ClassicLoader,
  Consent,
  EmpiricaClassic,
  EmpiricaContext,
  EmpiricaMenu,
  EmpiricaParticipant,
  Finished,
  Game,
  Globals,
  ListenersCollector,
  Loading,
  Lobby,
  Logo,
  LogsMock,
  NoGames,
  ParticipantContext,
  Player,
  PlayerCreate,
  PlayerGame,
  PlayerRound,
  PlayerStage,
  Quiz,
  Round,
  Scope,
  Scopes,
  Slider,
  Stage,
  Step,
  Steps,
  Sweeper,
  TajribaConnection,
  TajribaProvider,
  captureLogs,
  captureLogsAsync,
  classicKinds,
  createNewParticipant,
  debug,
  error,
  info,
  isDevelopment,
  isProduction,
  isTest,
  levels,
  log,
  mockLogging,
  setLogLevel,
  stopMockLogging,
  trace,
  useConsent,
  useGame,
  useGlobal,
  usePartModeCtx,
  usePartModeCtxKey,
  useParticipantContext,
  usePlayer,
  usePlayerID,
  usePlayers,
  useRound,
  useStage,
  useStageTimer,
  useTajriba,
  useTajribaConnected,
  useTajribaConnecting,
  warn
});
/*! Bundled license information:

tmp/lib/tmp.js:
  (*!
   * Tmp
   *
   * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
   *
   * MIT Licensed
   *)
*/
//# sourceMappingURL=index.cjs.map