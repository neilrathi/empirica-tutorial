{"version":3,"sources":["../src/admin/attributes.ts","../src/admin/connection.ts","../src/admin/events.ts","../src/admin/participants.ts","../src/admin/promises.ts","../src/admin/scopes.ts","../src/admin/subscriptions.ts","../src/admin/transitions.ts"],"sourcesContent":["import { Observable, ReplaySubject } from \"rxjs\";\nimport {\n  Attribute,\n  AttributeChange,\n  Attributes as SharedAttributes,\n} from \"../shared/attributes\";\nimport { warn } from \"../utils/console\";\n\nexport type AttributeMsg = {\n  attribute?: Attribute;\n  done: boolean;\n};\n\nexport class Attributes extends SharedAttributes {\n  protected attrsByKind = new Map<\n    string,\n    Map<string, Map<string, Attribute>>\n  >();\n  private attribSubs = new Map<\n    string,\n    Map<string, ReplaySubject<AttributeMsg>>\n  >();\n\n  subscribeAttribute(kind: string, key: string): Observable<AttributeMsg> {\n    if (!this.attribSubs.has(kind)) {\n      this.attribSubs.set(kind, new Map<string, ReplaySubject<AttributeMsg>>());\n    }\n\n    const keyMap = this.attribSubs.get(kind)!;\n    let sub = keyMap.get(key);\n    if (!sub) {\n      sub = new ReplaySubject<AttributeMsg>();\n      keyMap.set(key, sub);\n\n      const attrByScopeID = this.attrsByKind.get(kind);\n\n      setTimeout(() => {\n        if (!attrByScopeID) {\n          sub!.next({ done: true });\n          return;\n        }\n\n        let attrs = [];\n        for (const [_, attrByKey] of attrByScopeID?.entries()) {\n          for (const [_, attr] of attrByKey) {\n            if (attr.key === key) {\n              attrs.push(attr);\n            }\n          }\n        }\n\n        if (attrs.length > 0) {\n          let count = 0;\n          for (const attr of attrs) {\n            count++;\n            sub!.next({ attribute: attr, done: count == attrs.length });\n          }\n        } else {\n          sub!.next({ done: true });\n        }\n      }, 0);\n    }\n\n    return sub!;\n  }\n\n  protected next(scopeIDs: string[]) {\n    const byKind = new Map<string, AttributeChange[]>();\n\n    for (const [scopeID, attrs] of this.updates) {\n      if (!scopeIDs.includes(scopeID)) {\n        continue;\n      }\n\n      for (const [_, attr] of attrs) {\n        if (typeof attr === \"boolean\") {\n          continue;\n        }\n\n        const kind = attr.node?.kind;\n        if (kind) {\n          let kindAttrs = byKind.get(kind);\n          if (!kindAttrs) {\n            kindAttrs = [];\n            byKind.set(kind, kindAttrs);\n          }\n\n          kindAttrs.push(attr);\n        }\n      }\n    }\n\n    const updates: [string, string, AttributeChange][] = [];\n    for (const [kind, attrs] of byKind) {\n      for (const attr of attrs) {\n        // This is very difficult to reproduce in tests since this.updates\n        // cannot contain an AttributeChange that would satisfy this.\n        /* c8 ignore next 4 */\n        if (!attr.nodeID && !attr.node?.id) {\n          warn(`found attribute change without node ID`);\n          continue;\n        }\n\n        if (!scopeIDs.includes(attr.nodeID || attr.node!.id)) {\n          continue;\n        }\n\n        updates.push([kind, attr.key, attr]);\n      }\n    }\n\n    super.next(scopeIDs);\n\n    for (const [kind, key, attrChange] of updates) {\n      // Forcing nodeID because we already tested it above.\n      const nodeID = attrChange.nodeID || attrChange.node!.id;\n\n      if (!scopeIDs.includes(nodeID)) {\n        continue;\n      }\n\n      const attr = this.attrs.get(nodeID)!.get(key)!;\n      const sub = this.attribSubs.get(kind)?.get(key);\n      if (sub) {\n        sub.next({ attribute: attr, done: true });\n      } else {\n        let kAttrs = this.attrsByKind.get(kind);\n        if (!kAttrs) {\n          kAttrs = new Map<string, Map<string, Attribute>>();\n          this.attrsByKind.set(kind, kAttrs);\n        }\n\n        let kkAttrs = kAttrs!.get(nodeID);\n        if (!kkAttrs) {\n          kkAttrs = new Map<string, Attribute>();\n          kAttrs!.set(nodeID, kkAttrs);\n        }\n\n        kkAttrs.set(key, attr);\n      }\n    }\n  }\n}\n","import { TajribaAdmin } from \"@empirica/tajriba\";\nimport { BehaviorSubject, merge, SubscriptionLike } from \"rxjs\";\nimport {\n  ErrNotConnected,\n  TajribaConnection,\n} from \"../shared/tajriba_connection\";\nimport { bs, bsu } from \"../utils/object\";\nimport { subscribeAsync } from \"./observables\";\n\nexport class AdminConnection {\n  private _tajriba = bsu<TajribaAdmin>();\n  private _connected = bs(false);\n  private _connecting = bs(false);\n  private _stopped = bs(false);\n  private sub: SubscriptionLike;\n\n  constructor(\n    taj: TajribaConnection,\n    tokens: BehaviorSubject<string | null | undefined>,\n    private resetToken: () => void\n  ) {\n    let token: string | null | undefined;\n    let connected = false;\n\n    this.sub = subscribeAsync(\n      merge(taj.connected, tokens),\n      async (tokenOrConnected) => {\n        if (typeof tokenOrConnected === \"boolean\") {\n          connected = tokenOrConnected;\n        } else {\n          token = tokenOrConnected;\n        }\n\n        if (!token || !connected) {\n          return;\n        }\n\n        if (this._connected.getValue()) {\n          return;\n        }\n\n        this._connecting.next(true);\n\n        try {\n          const tajAdmin = await taj.sessionAdmin(token);\n\n          this._tajriba.next(tajAdmin);\n          this._connected.next(true);\n\n          tajAdmin.on(\"connected\", () => {\n            if (!this._connected.getValue()) {\n              this._connected.next(true);\n            }\n          });\n          tajAdmin.on(\"disconnected\", () => {\n            if (this._connected.getValue()) {\n              this._connected.next(false);\n            }\n          });\n          tajAdmin.on(\"accessDenied\", () => {\n            if (this._connected.getValue()) {\n              this._connected.next(false);\n            }\n            this.resetToken();\n          });\n        } catch (error) {\n          if (error !== ErrNotConnected) {\n            this.resetToken();\n          }\n        }\n\n        this._connecting.next(false);\n      }\n    );\n  }\n\n  stop() {\n    if (this._stopped.getValue()) {\n      return;\n    }\n\n    const taj = this._tajriba.getValue();\n    if (taj) {\n      taj.removeAllListeners(\"connected\");\n      taj.removeAllListeners(\"disconnected\");\n      taj.stop();\n      this._tajriba.next(undefined);\n    }\n\n    this.sub.unsubscribe();\n\n    this._connecting.next(false);\n    this._connected.next(false);\n    this._stopped.next(true);\n  }\n\n  get connecting() {\n    return this._connecting;\n  }\n\n  get connected() {\n    return this._connected;\n  }\n\n  get stopped() {\n    return this._stopped;\n  }\n\n  get admin() {\n    return this._tajriba;\n  }\n}\n","import {\n  AddGroupInput,\n  AddScopeInput,\n  AddStepInput,\n  LinkInput,\n  TransitionInput,\n} from \"@empirica/tajriba\";\nimport { Attribute } from \"../shared/attributes\";\nimport { ScopeConstructor } from \"../shared/scopes\";\nimport { Finalizer, TajribaAdminAccess } from \"./context\";\nimport { Scope, Scopes } from \"./scopes\";\nimport { ScopeSubscriptionInput } from \"./subscriptions\";\n\nexport type Subscriber<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> = (subs: ListenersCollector<Context, Kinds>) => void;\n\nexport enum TajribaEvent {\n  TransitionAdd = \"TRANSITION_ADD\",\n  ParticipantConnect = \"PARTICIPANT_CONNECT\",\n  ParticipantDisconnect = \"PARTICIPANT_DISCONNECT\",\n}\n\nexport enum ListernerPlacement {\n  Before,\n  None, // Not before or after\n  After,\n}\n\nconst placementString = new Map<ListernerPlacement, string>();\nplacementString.set(ListernerPlacement.Before, \"before\");\nplacementString.set(ListernerPlacement.None, \"on\");\nplacementString.set(ListernerPlacement.After, \"after\");\n\nexport function PlacementString(placement: ListernerPlacement): string {\n  return placementString.get(placement)!;\n}\n\nexport type SimpleListener<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> = {\n  placement: ListernerPlacement;\n  callback: (ctx: EventContext<Context, Kinds>) => void;\n};\n\nexport type TajEventListener<Callback extends Function> = {\n  placement: ListernerPlacement;\n  event: TajribaEvent;\n  callback: Callback;\n};\n\nexport type KindEventListener<Callback extends Function> = {\n  placement: ListernerPlacement;\n  kind: string;\n  callback: Callback;\n};\n\nexport type AttributeEventListener<Callback extends Function> = {\n  placement: ListernerPlacement;\n  kind: string;\n  key: string;\n  callback: Callback;\n};\n\nexport type EvtCtxCallback<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> = (ctx: EventContext<Context, Kinds>, props: any) => void;\n\nfunction unique<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> },\n  K extends keyof Kinds\n>(\n  kind: K,\n  placement: ListernerPlacement,\n  callback: EvtCtxCallback<Context, Kinds>\n) {\n  return async (ctx: EventContext<Context, Kinds>, props: any) => {\n    const attr = props.attribute as Attribute;\n    const scope = props[kind] as Scope<Context, Kinds>;\n    if (!attr.id || scope.get(`ran-${PlacementString(placement)}-${attr.id}`)) {\n      return;\n    }\n\n    await callback(ctx, props);\n\n    scope.set(`ran-${PlacementString(placement)}-${attr.id}`, true);\n  };\n}\n\n// Collects event listeners.\nexport class ListenersCollector<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> {\n  /** @internal */\n  readonly starts: SimpleListener<Context, Kinds>[] = [];\n  /** @internal */\n  readonly readys: SimpleListener<Context, Kinds>[] = [];\n  /** @internal */\n  readonly tajEvents: TajEventListener<EvtCtxCallback<Context, Kinds>>[] = [];\n  /** @internal */\n  readonly kindListeners: KindEventListener<EvtCtxCallback<Context, Kinds>>[] =\n    [];\n  /** @internal */\n  readonly attributeListeners: AttributeEventListener<\n    EvtCtxCallback<Context, Kinds>\n  >[] = [];\n\n  get unique() {\n    return new ListenersCollectorProxy<Context, Kinds>(this);\n  }\n\n  // start: first callback called.\n  // ready: callback called when initial loading is finished.\n  on(\n    kind: \"start\" | \"ready\",\n    callback: (ctx: EventContext<Context, Kinds>) => void\n  ): void;\n\n  // Attach to Tajriba Hooks.\n  on(event: TajribaEvent, callback: EvtCtxCallback<Context, Kinds>): void;\n\n  // Receive Scopes by Kind as they are fetched.\n  on<Kind extends string>(\n    kind: Kind,\n    callback: EvtCtxCallback<Context, Kinds>\n  ): void;\n\n  // Receive Scope attributes as they are fetched.\n  on<Kind extends keyof Kinds>(\n    kind: Kind,\n    key: string,\n    callback: EvtCtxCallback<Context, Kinds>,\n    uniqueCall?: boolean\n  ): void;\n\n  on(\n    kindOrEvent: string,\n    keyOrNodeIDOrEventOrCallback?:\n      | string\n      | TajribaEvent\n      | EvtCtxCallback<Context, Kinds>\n      | ((ctx: EventContext<Context, Kinds>) => void),\n    callback?: EvtCtxCallback<Context, Kinds>\n  ): void {\n    this.registerListerner(\n      ListernerPlacement.None,\n      kindOrEvent,\n      keyOrNodeIDOrEventOrCallback,\n      callback\n    );\n  }\n\n  before(\n    kindOrEvent: string,\n    keyOrNodeIDOrEventOrCallback?:\n      | string\n      | TajribaEvent\n      | EvtCtxCallback<Context, Kinds>\n      | ((ctx: EventContext<Context, Kinds>) => void),\n    callback?: EvtCtxCallback<Context, Kinds>,\n    uniqueCall?: boolean\n  ): void {\n    this.registerListerner(\n      ListernerPlacement.Before,\n      kindOrEvent,\n      keyOrNodeIDOrEventOrCallback,\n      callback,\n      uniqueCall\n    );\n  }\n\n  after(\n    kindOrEvent: string,\n    keyOrNodeIDOrEventOrCallback?:\n      | string\n      | TajribaEvent\n      | EvtCtxCallback<Context, Kinds>\n      | ((ctx: EventContext<Context, Kinds>) => void),\n    callback?: EvtCtxCallback<Context, Kinds>,\n    uniqueCall?: boolean\n  ): void {\n    this.registerListerner(\n      ListernerPlacement.After,\n      kindOrEvent,\n      keyOrNodeIDOrEventOrCallback,\n      callback,\n      uniqueCall\n    );\n  }\n\n  protected registerListerner(\n    placement: ListernerPlacement,\n    kindOrEvent: string,\n    keyOrNodeIDOrEventOrCallback?:\n      | string\n      | TajribaEvent\n      | EvtCtxCallback<Context, Kinds>\n      | ((ctx: EventContext<Context, Kinds>) => void),\n    callback?: EvtCtxCallback<Context, Kinds>,\n    uniqueCall = false\n  ): void {\n    if (kindOrEvent === \"start\") {\n      if (callback) {\n        throw new Error(\"start event only accepts 2 arguments\");\n      }\n\n      if (typeof keyOrNodeIDOrEventOrCallback !== \"function\") {\n        throw new Error(\"second argument expected to be a callback\");\n      }\n\n      this.starts.push({\n        placement,\n        callback: keyOrNodeIDOrEventOrCallback as (\n          ctx: EventContext<Context, Kinds>\n        ) => void,\n      });\n\n      return;\n    }\n\n    if (kindOrEvent === \"ready\") {\n      if (callback) {\n        throw new Error(\"ready event only accepts 2 arguments\");\n      }\n\n      if (typeof keyOrNodeIDOrEventOrCallback !== \"function\") {\n        throw new Error(\"second argument expected to be a callback\");\n      }\n\n      this.readys.push({\n        placement,\n        callback: keyOrNodeIDOrEventOrCallback as (\n          ctx: EventContext<Context, Kinds>\n        ) => void,\n      });\n\n      return;\n    }\n\n    if (Object.values(TajribaEvent).includes(kindOrEvent as any)) {\n      if (typeof keyOrNodeIDOrEventOrCallback !== \"function\") {\n        throw new Error(\"second argument expected to be a callback\");\n      }\n\n      this.tajEvents.push({\n        placement,\n        event: <TajribaEvent>kindOrEvent,\n        callback: keyOrNodeIDOrEventOrCallback,\n      });\n\n      return;\n    }\n\n    if (typeof keyOrNodeIDOrEventOrCallback === \"function\") {\n      this.kindListeners.push({\n        placement,\n        kind: kindOrEvent,\n        callback: keyOrNodeIDOrEventOrCallback,\n      });\n    } else {\n      if (typeof keyOrNodeIDOrEventOrCallback !== \"string\") {\n        throw new Error(\"second argument expected to be an attribute key\");\n      }\n      if (typeof callback !== \"function\") {\n        throw new Error(\"third argument expected to be a callback\");\n      }\n\n      if (uniqueCall) {\n        callback = unique(kindOrEvent, placement, callback);\n      }\n\n      this.attributeListeners.push({\n        placement,\n        kind: kindOrEvent,\n        key: keyOrNodeIDOrEventOrCallback,\n        callback,\n      });\n    }\n  }\n}\n\n// Collects event listeners.\nexport class ListenersCollectorProxy<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> extends ListenersCollector<Context, Kinds> {\n  constructor(private coll: ListenersCollector<Context, Kinds>) {\n    super();\n  }\n\n  protected registerListerner(\n    placement: ListernerPlacement,\n    kindOrEvent: string,\n    keyOrNodeIDOrEventOrCallback?:\n      | string\n      | TajribaEvent\n      | EvtCtxCallback<Context, Kinds>\n      | ((ctx: EventContext<Context, Kinds>) => void),\n    callback?: EvtCtxCallback<Context, Kinds>\n  ): void {\n    if (\n      kindOrEvent === \"start\" ||\n      kindOrEvent === \"ready\" ||\n      Object.values(TajribaEvent).includes(kindOrEvent as any) ||\n      typeof keyOrNodeIDOrEventOrCallback === \"function\"\n    ) {\n      throw new Error(\"only attribute listeners can be unique\");\n    }\n\n    super.registerListerner(\n      placement,\n      kindOrEvent,\n      keyOrNodeIDOrEventOrCallback,\n      callback,\n      true\n    );\n\n    while (true) {\n      const listener = this.attributeListeners.pop();\n      if (!listener) {\n        break;\n      }\n\n      this.coll.attributeListeners.push(listener);\n    }\n  }\n}\n\n// Context passed to listerners on new event allowing to subscrive to more data\n// and access data.\nexport interface SubscriptionCollector {\n  scopeSub: (...inputs: Partial<ScopeSubscriptionInput>[]) => void;\n  participantsSub: () => void;\n  transitionsSub: (stepID: string) => void;\n}\n\n// Context passed to listerners on new event allowing to subscrive to more data\n// and access data.\nexport class EventContext<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> {\n  constructor(\n    /** @internal */\n    private subs: SubscriptionCollector,\n    /** @internal */\n    private taj: TajribaAdminAccess,\n    /** @internal */\n    private scopes: Scopes<Context, Kinds>\n  ) {}\n\n  scopesByKind<T extends Scope<Context, Kinds>>(kind: keyof Kinds) {\n    return this.scopes.byKind<T>(kind) as Map<string, T>;\n  }\n\n  scopesByKindID<T extends Scope<Context, Kinds>>(\n    kind: keyof Kinds,\n    id: string\n  ) {\n    return this.scopes.byKind<T>(kind).get(id);\n  }\n\n  scopesByKindMatching<T extends Scope<Context, Kinds>>(\n    kind: keyof Kinds,\n    key: string,\n    val: string\n  ): T[] {\n    const scopes = Array.from(this.scopes.byKind(kind).values());\n    return scopes.filter((s) => s.get(key) === val) as T[];\n  }\n\n  scopeSub(...inputs: Partial<ScopeSubscriptionInput>[]) {\n    for (const input of inputs) {\n      this.subs.scopeSub(input);\n    }\n  }\n\n  participantsSub() {\n    this.subs.participantsSub();\n  }\n\n  transitionsSub(stepID: string) {\n    this.subs.transitionsSub(stepID);\n  }\n\n  // c8 ignore: the TajribaAdminAccess proxy functions are tested elswhere\n  /* c8 ignore next 3 */\n  addScopes(input: AddScopeInput[]) {\n    return this.taj.addScopes(input);\n  }\n\n  /* c8 ignore next 3 */\n  addGroups(input: AddGroupInput[]) {\n    return this.taj.addGroups(input);\n  }\n\n  /* c8 ignore next 3 */\n  addLinks(input: LinkInput[]) {\n    return this.taj.addLinks(input);\n  }\n\n  /* c8 ignore next 3 */\n  addSteps(input: AddStepInput[]) {\n    return this.taj.addSteps(input);\n  }\n\n  /* c8 ignore next 3 */\n  addTransitions(input: TransitionInput[]) {\n    return this.taj.addTransitions(input);\n  }\n\n  protected addFinalizer(cb: Finalizer) {\n    this.taj.addFinalizer(cb);\n  }\n\n  /* c8 ignore next 3 */\n  get globals() {\n    return this.taj.globals;\n  }\n}\n","import { EventType, TajribaAdmin } from \"@empirica/tajriba\";\nimport { Subject } from \"rxjs\";\nimport { error } from \"../utils/console\";\nimport { PromiseHandle, promiseHandle } from \"./promises\";\n\nexport interface Participant {\n  id: string;\n  identifier: string;\n}\n\nexport interface Connection {\n  participant: Participant;\n  connected: boolean;\n}\n\nexport interface ConnectionMsg {\n  connection?: Connection;\n  done: boolean;\n}\n\nexport async function participantsSub(\n  taj: TajribaAdmin,\n  connections: Subject<ConnectionMsg>,\n  participants: Map<string, Participant>\n) {\n  let handle: PromiseHandle | undefined = promiseHandle();\n  taj.onEvent({ eventTypes: [EventType.ParticipantConnected] }).subscribe({\n    next({ node, done }) {\n      if (!node) {\n        if (done) {\n          if (handle) {\n            handle?.result();\n\n            connections.next({ done: true });\n          }\n\n          return;\n        }\n        error(`received no participant on connected`);\n\n        return;\n      }\n\n      if (node.__typename !== \"Participant\") {\n        error(`received non-participant on connected`);\n\n        return;\n      }\n\n      const part = {\n        id: node.id,\n        identifier: node.identifier,\n      };\n\n      participants.set(node.id, part);\n\n      connections.next({\n        connection: {\n          participant: part,\n          connected: true,\n        },\n        done,\n      });\n\n      if (handle && done) {\n        handle.result();\n      }\n    },\n  });\n\n  taj.onEvent({ eventTypes: [EventType.ParticipantDisconnect] }).subscribe({\n    next({ node }) {\n      if (!node) {\n        error(`received no participant on disconnect`);\n\n        return;\n      }\n\n      if (node.__typename !== \"Participant\") {\n        error(`received non-participant on disconnect`);\n\n        return;\n      }\n\n      participants.delete(node.id);\n\n      connections.next({\n        connection: {\n          participant: {\n            id: node.id,\n            identifier: node.identifier,\n          },\n          connected: false,\n        },\n        done: true,\n      });\n    },\n  });\n\n  await handle.promise;\n  handle = undefined;\n}\n","export interface PromiseHandle<T = void> {\n  promise: Promise<T>;\n  result: (value: T) => void;\n}\n\nexport function promiseHandle<T = void>(): PromiseHandle<T> {\n  let ret = {} as PromiseHandle<T>;\n  ret.promise = new Promise<T>((r) => {\n    ret.result = r;\n  });\n\n  return ret;\n}\n","import {\n  AddGroupInput,\n  AddScopeInput,\n  AddStepInput,\n  LinkInput,\n  TransitionInput,\n} from \"@empirica/tajriba\";\nimport { Observable, ReplaySubject } from \"rxjs\";\nimport {\n  Scope as SharedScope,\n  ScopeConstructor,\n  ScopeIdent,\n  Scopes as SharedScopes,\n  ScopeUpdate,\n} from \"../shared/scopes\";\nimport { Attributes } from \"./attributes\";\nimport { Finalizer, TajribaAdminAccess } from \"./context\";\n\nexport type ScopeMsg<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> = {\n  scope?: Scope<Context, Kinds>;\n  done: boolean;\n};\n\nexport class Scopes<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> extends SharedScopes<Context, Kinds, Scope<Context, Kinds>> {\n  private kindSubs = new Map<\n    keyof Kinds,\n    ReplaySubject<ScopeMsg<Context, Kinds>>\n  >();\n\n  constructor(\n    scopesObs: Observable<ScopeUpdate>,\n    donesObs: Observable<string[]>,\n    ctx: Context,\n    kinds: Kinds,\n    attributes: Attributes,\n    readonly taj: TajribaAdminAccess\n  ) {\n    super(scopesObs, donesObs, ctx, kinds, attributes);\n  }\n\n  /** @internal */\n  subscribeKind(kind: keyof Kinds): Observable<ScopeMsg<Context, Kinds>> {\n    let sub = this.kindSubs.get(kind);\n    if (!sub) {\n      sub = new ReplaySubject<ScopeMsg<Context, Kinds>>();\n      this.kindSubs.set(kind, sub);\n\n      const scopes = this.byKind(kind);\n\n      setTimeout(() => {\n        if (scopes.size === 0) {\n          sub!.next({ done: true });\n\n          return;\n        }\n\n        let count = 0;\n        for (const [_, scope] of scopes) {\n          count++;\n          sub!.next({ scope, done: scopes.size === count });\n        }\n      }, 0);\n    }\n\n    return sub!;\n  }\n\n  protected next(scopeIDs: string[]) {\n    for (const [_, scopeReplaySubject] of this.scopes) {\n      const scope = scopeReplaySubject.getValue();\n      if (this.newScopes.get(scope.id) && scopeIDs.includes(scope.id)) {\n        const kindSub = this.kindSubs.get(scope.kind);\n        if (kindSub) {\n          kindSub.next({ scope, done: true });\n        }\n        this.newScopes.set(scope.id, false);\n      }\n    }\n\n    super.next(scopeIDs);\n  }\n\n  protected create(\n    scopeClass: ScopeConstructor<Context, Kinds>,\n    scope: ScopeIdent\n  ) {\n    return new scopeClass!(this.ctx, scope, this, this.attributes) as Scope<\n      Context,\n      Kinds\n    >;\n  }\n}\n\nexport class Scope<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> extends SharedScope<Context, Kinds> {\n  /**\n   * @internal\n   */\n  readonly taj: TajribaAdminAccess;\n\n  constructor(\n    ctx: Context,\n    scope: ScopeIdent,\n    private scopes: Scopes<Context, Kinds>,\n    attributes: Attributes\n  ) {\n    super(ctx, scope, attributes);\n    this.taj = scopes.taj;\n  }\n\n  protected scopeByID<T extends Scope<Context, Kinds>>(\n    id: string\n  ): T | undefined {\n    return this.scopes.scope(id) as T | undefined;\n  }\n\n  protected scopeByKey<T extends Scope<Context, Kinds>>(\n    key: string\n  ): T | undefined {\n    const id = this.get(key);\n    if (!id || typeof id !== \"string\") {\n      return;\n    }\n\n    return this.scopes.scope(id) as T | undefined;\n  }\n\n  protected scopesByKind<T extends Scope<Context, Kinds>>(\n    kind: keyof Kinds\n  ): Map<string, T> {\n    return this.scopes.byKind<T>(kind) as Map<string, T>;\n  }\n\n  protected scopesByKindID<T extends Scope<Context, Kinds>>(\n    kind: keyof Kinds,\n    id: string\n  ): T | undefined {\n    return this.scopes.byKind<T>(kind).get(id);\n  }\n\n  protected scopesByKindMatching<T extends Scope<Context, Kinds>>(\n    kind: keyof Kinds,\n    key: string,\n    val: string\n  ): T[] {\n    const scopes = Array.from(this.scopes.byKind(kind).values());\n    return scopes.filter((s) => s.get(key) === val) as T[];\n  }\n\n  protected addScopes(input: AddScopeInput[]) {\n    return this.taj.addScopes(input);\n  }\n\n  protected addGroups(input: AddGroupInput[]) {\n    return this.taj.addGroups(input);\n  }\n\n  protected addLinks(input: LinkInput[]) {\n    return this.taj.addLinks(input);\n  }\n\n  protected addSteps(input: AddStepInput[]) {\n    return this.taj.addSteps(input);\n  }\n\n  protected addTransitions(input: TransitionInput[]) {\n    return this.taj.addTransitions(input);\n  }\n\n  protected addFinalizer(cb: Finalizer) {\n    this.taj.addFinalizer(cb);\n  }\n\n  /**\n   * @internal\n   */\n  get globals() {\n    return this.taj.globals;\n  }\n}\n","import { ScopeConstructor } from \"../shared/scopes\";\n\nexport type KV = {\n  key: string;\n  val: string;\n};\n\nfunction kvstr(kv: KV) {\n  return kv.key + \"-\" + kv.val;\n}\n\nexport interface ScopeSubscriptionInput {\n  /** ids of the matching Scopes. */\n  ids: string[];\n  /** kinds of the matching Scopes. */\n  kinds: string[];\n  /** keys to Attributes in matching Scope. */\n  keys: string[];\n  /** kvs to Attributes in matching Scope. */\n  kvs: KV[];\n  /** names of the matching Scopes. */\n  names: string[];\n}\n\nexport interface Subs {\n  participants: boolean;\n  scopes: {\n    ids: string[];\n    kinds: string[];\n    names: string[];\n    keys: string[];\n    kvs: KV[];\n  };\n  transitions: string[];\n}\n\n// Tracks what data should be subscribed to.\nexport class Subscriptions<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> {\n  private scopeKinds = new Set<string>();\n  private scopeIDs = new Set<string>();\n  private scopeNames = new Set<string>();\n  private scopeKeys = new Set<string>();\n  private scopeKVSet = new Set<string>();\n  private scopeKVs: KV[] = [];\n  private participantSub = false;\n  private transitionsSubs = new Set<string>();\n  private dirty = false;\n  public last: Subs = {\n    participants: false,\n    scopes: {\n      ids: [],\n      kinds: [],\n      names: [],\n      keys: [],\n      kvs: [],\n    },\n    transitions: [],\n  };\n\n  get subs(): Subs {\n    return {\n      participants: this.participantSub,\n      scopes: {\n        kinds: Array.from(this.scopeKinds.values()),\n        ids: Array.from(this.scopeIDs.values()),\n        names: Array.from(this.scopeNames.values()),\n        keys: Array.from(this.scopeKeys.values()),\n        kvs: [...this.scopeKVs],\n      },\n      transitions: Array.from(this.transitionsSubs.values()),\n    };\n  }\n\n  // newSubs will return only new subs since the last call.\n  newSubs(): Subs | undefined {\n    if (!this.dirty) {\n      return;\n    }\n\n    const current = this.subs;\n    const {\n      scopes: { ids, kinds, names, keys, kvs },\n      participants,\n      transitions,\n    } = this.last;\n\n    const kvsstrs = kvs.map((kv) => kvstr(kv));\n\n    const next = {\n      participants: this.participantSub && !participants,\n      scopes: {\n        ids: current.scopes.ids.filter((id) => !ids.includes(id)),\n        kinds: current.scopes.kinds.filter((kind) => !kinds.includes(kind)),\n        names: current.scopes.names.filter((name) => !names.includes(name)),\n        keys: current.scopes.keys.filter((key) => !keys.includes(key)),\n        kvs: current.scopes.kvs.filter((kv) => !kvsstrs.includes(kvstr(kv))),\n      },\n      transitions: current.transitions.filter(\n        (id) => !transitions.includes(id)\n      ),\n    };\n\n    this.last = current;\n    this.dirty = false;\n\n    return next;\n  }\n\n  scopeSub(input: Partial<ScopeSubscriptionInput>) {\n    if (input.ids) {\n      for (const id of input.ids) {\n        if (!this.scopeIDs.has(id)) {\n          this.scopeIDs.add(id);\n          this.dirty = true;\n        }\n      }\n    }\n\n    if (input.kinds) {\n      for (const id of input.kinds) {\n        if (!this.scopeKinds.has(id)) {\n          this.scopeKinds.add(id);\n          this.dirty = true;\n        }\n      }\n    }\n\n    if (input.names) {\n      for (const name of input.names) {\n        if (!this.scopeNames.has(name)) {\n          this.scopeNames.add(name);\n          this.dirty = true;\n        }\n      }\n    }\n\n    if (input.keys) {\n      for (const key of input.keys) {\n        if (!this.scopeKeys.has(key)) {\n          this.scopeKeys.add(key);\n          this.dirty = true;\n        }\n      }\n    }\n\n    if (input.kvs) {\n      for (const kv of input.kvs) {\n        const kvKey = kvstr(kv);\n        if (!this.scopeKVSet.has(kvKey)) {\n          this.scopeKVSet.add(kvKey);\n          this.scopeKVs.push(kv);\n          this.dirty = true;\n        }\n      }\n    }\n  }\n\n  participantsSub() {\n    if (!this.participantSub) {\n      this.dirty = true;\n      this.participantSub = true;\n    }\n  }\n\n  transitionsSub(nodeID: string) {\n    if (!this.transitionsSubs.has(nodeID)) {\n      this.transitionsSubs.add(nodeID);\n      this.dirty = true;\n    }\n  }\n}\n","import { EventType, State, TajribaAdmin } from \"@empirica/tajriba\";\nimport { Subject } from \"rxjs\";\nimport { error } from \"../utils/console\";\n\nexport interface Step {\n  id: string;\n  state: State;\n  duration: number;\n  startedAt?: number;\n  endedAt?: number;\n}\n\nexport interface Transition {\n  id: string;\n  from: State;\n  to: State;\n  step: Step;\n}\n\nexport function transitionsSub(\n  taj: TajribaAdmin,\n  transitions: Subject<Transition>,\n  nodeID: string\n) {\n  taj.onEvent({ eventTypes: [EventType.TransitionAdd], nodeID }).subscribe({\n    next({ node }) {\n      if (!node) {\n        return;\n      }\n\n      if (node.__typename !== \"Transition\") {\n        error(`received non-transition`);\n\n        return;\n      }\n\n      if (node.node.__typename !== \"Step\") {\n        error(`received non-step transition`, node.node);\n\n        return;\n      }\n\n      transitions.next({\n        id: node.id,\n        to: node.to,\n        from: node.from,\n        step: {\n          id: node.node.id,\n          duration: node.node.duration,\n          state: node.node.state,\n        },\n      });\n    },\n  });\n}\n"],"mappings":"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","names":["Attributes","_","error","TajribaEvent","ReplaySubject","Scopes","ReplaySubject","Scope","EventType","EventType"]}