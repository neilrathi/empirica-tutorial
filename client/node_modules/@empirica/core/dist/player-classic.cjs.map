{"version":3,"sources":["../src/player/classic/index.ts","../src/shared/attributes.ts","../src/utils/console.ts","../src/shared/globals.ts","../src/player/provider.ts","../src/shared/scopes.ts","../src/player/scopes.ts","../src/player/steps.ts","../src/player/utils.ts","../src/player/classic/classic.ts"],"sourcesContent":["export { Attribute, Attributes } from \"../../shared/attributes\";\nexport type {\n  AttributeChange,\n  AttributeOptions,\n  AttributeUpdate,\n} from \"../../shared/attributes\";\nexport { Globals } from \"../../shared/globals\";\nexport type { Constructor } from \"../../shared/helpers\";\nexport type {\n  AttributeInput,\n  ScopeConstructor,\n  ScopeIdent,\n  ScopeUpdate,\n  Scope as SharedScope,\n} from \"../../shared/scopes\";\nexport type { Json, JsonArray, JsonValue } from \"../../utils/json\";\nexport { TajribaProvider } from \"../provider\";\nexport type { ParticipantUpdate } from \"../provider\";\nexport { Scope, Scopes } from \"../scopes\";\nexport { Step, Steps } from \"../steps\";\nexport type { Epoch, StepChange, StepTick, StepUpdate } from \"../steps\";\nexport {\n  createNewParticipant,\n  isDevelopment,\n  isProduction,\n  isTest,\n} from \"../utils\";\nexport {\n  EmpiricaClassic,\n  Game,\n  Player,\n  PlayerGame,\n  PlayerRound,\n  PlayerStage,\n  Round,\n  Stage,\n} from \"./classic\";\nexport type {\n  Context,\n  EmpiricaClassicContext,\n  EmpiricaClassicKinds,\n} from \"./classic\";\nimport \"../index.css\";\n","import { SetAttributeInput } from \"@empirica/tajriba\";\nimport { BehaviorSubject, Observable } from \"rxjs\";\nimport { error, trace } from \"../utils/console\";\nimport { JsonValue } from \"../utils/json\";\n\nexport interface AttributeChange {\n  /** deleted is true with the attribute was deleted. */\n  deleted?: boolean;\n  /** deletedAt is the time when the Attribute was deleted. int64 Date + Time\n   * value given in Epoch with ns precision */\n  deletedAt?: number;\n  /** createdAt is the time the Attribute was created. int64 Date + Time\n   * value given in Epoch with ns precision */\n  createdAt?: string;\n  /** id is the identifier for the Attribute. */\n  id: string;\n  /** index is the index of the attribute if the value is a vector. */\n  index?: number | null;\n  /** isNew is true if the Attribute was just created. */\n  isNew?: boolean;\n  /** key is the attribute key being updated. */\n  key: string;\n  /** nodeID is the identifier for the Attribute's Node. */\n  nodeID?: string;\n  /** node is the Attribute's Node. */\n  node?: {\n    __typename: \"Scope\";\n    id: string;\n    kind?: string;\n    name?: string;\n  };\n  /** value is the value of the updated attribute. */\n  val?: string | null;\n  /** vector indicates whether the value is a vector. */\n  vector: boolean;\n  /** version is the version number of this Attribute, starting at 1. */\n  version: number;\n}\n\nexport interface AttributeUpdate {\n  attribute: AttributeChange;\n  removed: boolean;\n}\n\nexport class Attributes {\n  protected attrs = new Map<string, Map<string, Attribute>>();\n  protected updates = new Map<string, Map<string, AttributeChange | boolean>>();\n\n  constructor(\n    attributesObs: Observable<AttributeUpdate>,\n    donesObs: Observable<string[]>,\n    readonly setAttributes: (input: SetAttributeInput[]) => Promise<unknown>\n  ) {\n    attributesObs.subscribe({\n      next: ({ attribute, removed }) => {\n        this.update(attribute, removed);\n      },\n    });\n\n    donesObs.subscribe({\n      next: (scopeIDs) => {\n        this.next(scopeIDs);\n      },\n    });\n  }\n\n  attribute(scopeID: string, key: string): Attribute {\n    let scopeMap = this.attrs.get(scopeID);\n    if (!scopeMap) {\n      scopeMap = new Map();\n      this.attrs.set(scopeID, scopeMap);\n    }\n\n    let attr = scopeMap.get(key);\n    if (!attr) {\n      attr = new Attribute(this.setAttributes, scopeID, key);\n      scopeMap.set(key, attr);\n    }\n\n    return attr;\n  }\n\n  attributes(scopeID: string): Attribute[] {\n    let scopeMap = this.attrs.get(scopeID);\n    if (!scopeMap) {\n      scopeMap = new Map();\n      this.attrs.set(scopeID, scopeMap);\n    }\n\n    return Array.from(scopeMap.values());\n  }\n\n  attributePeek(scopeID: string, key: string): Attribute | undefined {\n    let scopeUpdateMap = this.updates.get(scopeID);\n    if (scopeUpdateMap) {\n      const updated = scopeUpdateMap.get(key);\n      if (updated) {\n        if (typeof updated === \"boolean\") {\n          return;\n        } else {\n          if (!updated.val) {\n            return;\n          } else {\n            const attr = new Attribute(this.setAttributes, scopeID, key);\n            attr._update(updated);\n            return attr;\n          }\n        }\n      }\n    }\n\n    let scopeMap = this.attrs.get(scopeID);\n    if (!scopeMap) {\n      return;\n    }\n\n    let attr = scopeMap.get(key);\n    if (!attr) {\n      return;\n    }\n\n    if (attr.value === undefined) {\n      return;\n    }\n\n    return attr;\n  }\n\n  nextAttributeValue(scopeID: string, key: string): JsonValue | undefined {\n    const attr = this.attributePeek(scopeID, key);\n    if (!attr) {\n      return;\n    }\n\n    return attr.value;\n  }\n\n  private update(attr: AttributeChange, removed: boolean) {\n    let nodeID = attr.nodeID;\n    if (!nodeID) {\n      if (!attr.node?.id) {\n        error(`new attribute without node ID`);\n        return;\n      }\n      nodeID = attr.node.id;\n    }\n\n    let scopeMap = this.updates.get(nodeID);\n    if (!scopeMap) {\n      scopeMap = new Map();\n      this.updates.set(nodeID, scopeMap);\n    }\n\n    if (removed) {\n      scopeMap.set(attr.key, true);\n    } else {\n      let key = attr.key;\n      if (attr.index !== undefined && attr.index !== null) {\n        key = `${key}[${attr.index}]`;\n      }\n      scopeMap.set(key, attr);\n    }\n  }\n\n  scopeWasUpdated(scopeID?: string): boolean {\n    if (!scopeID) {\n      return false;\n    }\n\n    return this.updates.has(scopeID);\n  }\n\n  protected next(scopeIDs: string[]) {\n    for (const [scopeID, attrs] of this.updates) {\n      if (!scopeIDs.includes(scopeID)) {\n        continue;\n      }\n\n      let scopeMap = this.attrs.get(scopeID);\n\n      if (!scopeMap) {\n        scopeMap = new Map();\n        this.attrs.set(scopeID, scopeMap);\n      }\n\n      for (const [key, attrOrDel] of attrs) {\n        if (typeof attrOrDel === \"boolean\") {\n          let attr = scopeMap.get(key);\n          if (attr) {\n            attr._update(undefined);\n          }\n        } else {\n          let attr = scopeMap.get(attrOrDel.key);\n          if (!attr) {\n            attr = new Attribute(this.setAttributes, scopeID, attrOrDel.key);\n            scopeMap.set(attrOrDel.key, attr);\n          }\n\n          attr._update(attrOrDel);\n        }\n      }\n    }\n\n    for (const scopeID of scopeIDs) {\n      this.updates.delete(scopeID);\n    }\n  }\n}\n\nexport interface AttributeOptions {\n  /**\n   * Private indicates the attribute will not be visible to other Participants.\n   */\n  private: boolean;\n  /**\n   * Protected indicates the attribute will not be updatable by other\n   * Participants.\n   */\n  protected: boolean;\n  /** Immutable creates an Attribute that cannot be updated. */\n  immutable: boolean;\n  /**\n   * Index, only used if the Attribute is a vector, indicates which index to\n   * update the value at.\n   */\n  index: number | null;\n  /**\n   * Append, only used if the Attribute is a vector, indicates to append the\n   * attribute to the vector.\n   */\n  append: boolean | null;\n}\n\nexport class Attribute {\n  private attr?: AttributeChange;\n  private attrs?: Attribute[];\n\n  private val = new BehaviorSubject<JsonValue | undefined>(undefined);\n\n  constructor(\n    private setAttributes: (input: SetAttributeInput[]) => Promise<unknown>,\n    readonly scopeID: string,\n    readonly key: string\n  ) {}\n\n  get id() {\n    return this.attr?.id;\n  }\n\n  get createdAt() {\n    return this.attr ? new Date(this.attr!.createdAt!) : null;\n  }\n\n  get obs(): Observable<JsonValue | undefined> {\n    return this.val;\n  }\n\n  get value() {\n    return this.val.getValue();\n  }\n\n  get nodeID() {\n    return this.attr?.nodeID || this.attr?.node?.id;\n  }\n\n  // items returns the attribute changes for the current attribute, if it is a\n  // vector. Otherwise it returns null;\n  get items() {\n    if (!this.attrs) {\n      return null;\n    }\n\n    return this.attrs;\n  }\n\n  set(value: JsonValue, ao?: Partial<AttributeOptions>) {\n    const attrProps = this._prepSet(value, ao);\n    this.setAttributes([attrProps]);\n    trace(`SET ${this.key} = ${value} (${this.scopeID})`);\n  }\n\n  _prepSet(\n    value: JsonValue,\n    ao?: Partial<AttributeOptions>,\n    item?: boolean\n  ): SetAttributeInput {\n    if (!item && ao?.index !== undefined) {\n      const index = ao!.index!;\n\n      if (!this.attrs) {\n        this.attrs = [];\n      }\n\n      if (index + 1 > (this.attrs?.length || 0)) {\n        this.attrs.length = index! + 1;\n      }\n\n      if (!this.attrs[index]) {\n        this.attrs[index] = new Attribute(\n          this.setAttributes,\n          this.scopeID,\n          this.key\n        );\n      }\n\n      this.attrs![index]!._prepSet(value, ao, true);\n      const v = this._recalcVectorVal();\n      this.val.next(v);\n    } else {\n      this.val.next(value);\n    }\n\n    const attrProps: SetAttributeInput = {\n      key: this.key,\n      nodeID: this.scopeID,\n      val: JSON.stringify(value),\n    };\n\n    if (ao) {\n      // TODO Fix this. Should check if compatible with existing attribute and\n      // only set fields set on ao.\n      attrProps.private = ao.private;\n      attrProps.protected = ao.protected;\n      attrProps.immutable = ao.immutable;\n      attrProps.append = ao.append;\n      attrProps.index = ao.index;\n    }\n\n    return attrProps;\n  }\n\n  private _recalcVectorVal(): JsonValue {\n    return this.attrs!.map((a) =>\n      !a || a.val == undefined ? null : a.value || null\n    );\n  }\n\n  // internal only\n  _update(attr?: AttributeChange, item?: boolean) {\n    if (attr && this.attr && this.attr.id === attr.id) {\n      return;\n    }\n\n    if (attr && attr.vector && !item) {\n      // TODO check if is vector\n\n      if (attr.index === undefined) {\n        error(`vector attribute missing index`);\n        return;\n      }\n\n      if (this.attrs == undefined) {\n        this.attrs = [];\n      }\n\n      while (this.attrs.length < attr.index! + 1) {\n        const newAttr = new Attribute(\n          this.setAttributes,\n          this.scopeID,\n          this.key\n        );\n        this.attrs.push(newAttr);\n      }\n\n      const newAttr = new Attribute(this.setAttributes, this.scopeID, this.key);\n      newAttr._update(attr, true);\n      this.attrs[attr.index!] = newAttr;\n      const value = this._recalcVectorVal();\n      this.val.next(value);\n\n      return;\n    }\n\n    this.attr = attr;\n    let value: JsonValue | undefined = undefined;\n    if (this.attr?.val) {\n      value = JSON.parse(this.attr.val);\n    }\n    this.val.next(value);\n  }\n}\n","/* c8 ignore start */\n\nconst isBrowser =\n  typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\n\nenum Color {\n  Bold = 1,\n\n  Black = 30,\n  Red,\n  Green,\n  Yellow,\n  Blue,\n  Magenta,\n  Cyan,\n  White,\n\n  DarkGray = 90,\n}\n\nexport type LogLine = { level: string; args: any[] };\nexport class LogsMock {\n  public logs: LogLine[] = [];\n\n  log(line: LogLine) {\n    this.logs.push(line);\n  }\n\n  clear() {\n    this.logs = [];\n  }\n}\n\nlet logsMock: LogsMock | undefined;\nexport function captureLogs(cb: () => void): LogLine[] {\n  const lm = mockLogging();\n  cb();\n  const ret = lm.logs;\n  stopMockLogging();\n\n  return ret;\n}\n\nexport async function captureLogsAsync(\n  cb: () => Promise<void>\n): Promise<LogLine[]> {\n  const lm = mockLogging();\n  await cb();\n  const ret = lm.logs;\n  stopMockLogging();\n\n  return ret;\n}\n\nexport function mockLogging() {\n  if (!logsMock) {\n    logsMock = new LogsMock();\n  }\n\n  return logsMock;\n}\n\nexport function stopMockLogging() {\n  logsMock = undefined;\n}\n\nconst colorHex = {\n  [Color.Bold]: \"font-weight: bold\",\n  [Color.Black]: \"color: #000000\",\n  [Color.Red]: \"color: #cc0000\",\n  [Color.Green]: \"color: #4e9a06\",\n  [Color.Yellow]: \"color: #c4a000\",\n  [Color.Blue]: \"color: #729fcf\",\n  [Color.Magenta]: \"color: #75507b\",\n  [Color.Cyan]: \"color: #06989a\",\n  [Color.White]: \"color: #d3d7cf\",\n  [Color.DarkGray]: \"color: #555753\",\n};\n\nexport const levels: { [key: string]: number } = {\n  trace: 0,\n  debug: 1,\n  log: 2,\n  info: 2,\n  warn: 3,\n  error: 4,\n};\n\nconst reversLevels: { [key: number]: string } = {};\nfor (const key in levels) {\n  reversLevels[levels[key]!] = key;\n}\n\nlet currentLevel = 2;\n\nexport function setLogLevel(level: keyof typeof levels) {\n  const lvl = levels[level];\n  if (lvl === undefined) {\n    return;\n  }\n\n  currentLevel = lvl;\n}\n\nfunction formatConsoleDate(date: Date, level: string[]) {\n  var hour = date.getHours();\n  var minutes = date.getMinutes();\n  var seconds = date.getSeconds();\n  var milliseconds = date.getMilliseconds();\n\n  const str =\n    (hour < 10 ? \"0\" + hour : hour) +\n    \":\" +\n    (minutes < 10 ? \"0\" + minutes : minutes) +\n    \":\" +\n    (seconds < 10 ? \"0\" + seconds : seconds) +\n    \".\" +\n    (\"00\" + milliseconds).slice(-3);\n\n  if (isBrowser) {\n    const ts = colorize(str, Color.DarkGray).concat(level);\n    return [ts[0] + \" \" + level[0], ts[1], level[1]];\n  }\n\n  return colorize(str, Color.DarkGray).concat(level);\n}\n\nconst createLogger = (lvl: number, level: string[]) => {\n  return (...args: any[]) => {\n    if (lvl < currentLevel) {\n      return;\n    }\n\n    if (logsMock) {\n      logsMock.log({ level: reversLevels[lvl]!, args: args });\n\n      return;\n    }\n\n    if (args.length === 1) {\n      switch (typeof args[0]) {\n        case \"string\":\n          for (const line of args[0].split(\"\\n\")) {\n            console.log(...formatConsoleDate(new Date(), level).concat(line));\n          }\n          return;\n\n        case \"object\":\n          if (args[0] instanceof Error) {\n            const error = args[0] as Error;\n            const prettyErr =\n              error.name +\n              \": \" +\n              error.message.replace(new RegExp(`^${error.name}[: ]*`), \"\") +\n              \"\\n\" +\n              (error.stack || \"\")\n                .split(\"\\n\")\n                .map((line) => line.trim())\n                .map((line) => {\n                  if (line.startsWith(error.name + \": \" + error.message))\n                    return null;\n\n                  if (line.startsWith(\"at\")) {\n                    return \"  \" + line;\n                  }\n\n                  return line;\n                })\n                .filter(Boolean)\n                .join(\"\\n\");\n\n            for (const line of prettyErr.split(\"\\n\")) {\n              console.log(...formatConsoleDate(new Date(), level).concat(line));\n            }\n\n            return;\n          }\n      }\n    }\n\n    console.log(...formatConsoleDate(new Date(), level).concat(args));\n  };\n};\n\nfunction colorize(s: string, ...cc: Color[]): string[] {\n  if (isBrowser) {\n    const attr = [];\n    for (const c of cc) {\n      attr.push(colorHex[c]);\n    }\n\n    return [`%c${s}`, attr.join(\"; \")];\n  }\n\n  let out = \"\";\n  for (const c of cc) {\n    out += `\\x1b[${c}m`;\n  }\n  out += `${s}\\x1b[0m`;\n\n  return [out];\n}\n\nexport const trace = createLogger(0, colorize(\"TRC\", Color.Magenta));\nexport const debug = createLogger(1, colorize(\"DBG\", Color.Yellow));\nexport const log = createLogger(2, colorize(\"LOG\", Color.Yellow));\nexport const info = createLogger(2, colorize(\"INF\", Color.Green));\nexport const warn = createLogger(3, colorize(\"WRN\", Color.Cyan));\nexport const error = createLogger(4, colorize(\"ERR\", Color.Red, Color.Bold));\n\n// export {\n//   trace,\n//   debug,\n//   log,\n//   info,\n//   warn,\n//   error,\n// };\n\n// export function warn(...args: string[]) {}\n","import { SubAttributesPayload } from \"@empirica/tajriba\";\nimport { BehaviorSubject, Observable } from \"rxjs\";\nimport { JsonValue } from \"../utils/json\";\n\nexport class Globals {\n  protected attrs = new Map<string, BehaviorSubject<JsonValue | undefined>>();\n  private updates = new Map<string, JsonValue | undefined>();\n  public self: BehaviorSubject<Globals | undefined>;\n\n  constructor(globals: Observable<SubAttributesPayload>) {\n    this.self = new BehaviorSubject<Globals | undefined>(undefined);\n\n    globals.subscribe({\n      next: ({ attribute, done }) => {\n        if (attribute) {\n          let val = undefined;\n          if (attribute.val) {\n            val = JSON.parse(attribute.val);\n          }\n\n          this.updates.set(attribute.key, val);\n        }\n\n        if (done) {\n          for (const [key, val] of this.updates) {\n            this.obs(key).next(val);\n          }\n\n          this.updates.clear();\n\n          if (this.self) {\n            this.self.next(this);\n          }\n        }\n      },\n    });\n  }\n\n  get(key: string): JsonValue | undefined {\n    const o = this.attrs.get(key);\n    if (o) {\n      return o.getValue();\n    }\n\n    return undefined;\n  }\n\n  obs(key: string) {\n    let o = this.attrs.get(key);\n    if (!o) {\n      o = new BehaviorSubject<JsonValue | undefined>(undefined);\n      this.attrs.set(key, o);\n    }\n\n    return o;\n  }\n}\n","import {\n  ChangePayload,\n  ParticipantChange,\n  SetAttributeInput,\n  SubAttributesPayload,\n} from \"@empirica/tajriba\";\nimport { Observable, Subject, groupBy } from \"rxjs\";\nimport { AttributeChange, AttributeUpdate } from \"../shared/attributes\";\nimport { ScopeIdent, ScopeUpdate } from \"../shared/scopes\";\nimport { trace } from \"../utils/console\";\nimport { StepChange, StepUpdate } from \"./steps\";\n\nexport interface ParticipantUpdate {\n  participant: ParticipantChange;\n  removed: boolean;\n}\n\nexport class TajribaProvider {\n  public scopes = new Subject<ScopeUpdate>();\n  public attributes = new Subject<AttributeUpdate>();\n  public participants = new Subject<ParticipantUpdate>();\n  public steps = new Subject<StepUpdate>();\n  public dones = new Subject<string[]>();\n\n  constructor(\n    changes: Observable<ChangePayload>,\n    readonly globals: Observable<SubAttributesPayload>,\n    readonly setAttributes: (input: SetAttributeInput[]) => Promise<any>\n  ) {\n    let scopeIDs: string[] = [];\n    changes.pipe(groupBy((chg) => chg?.change?.__typename)).subscribe({\n      next: (group) => {\n        switch (group.key) {\n          case \"ScopeChange\":\n            group.subscribe({\n              next: (msg) => {\n                if (\n                  !msg.change ||\n                  msg.removed === null ||\n                  msg.removed === undefined\n                ) {\n                  trace(\"AttributeChange empty\");\n                } else {\n                  this.scopes.next({\n                    scope: <ScopeIdent>msg.change,\n                    removed: msg.removed,\n                  });\n                }\n\n                if (msg.done) {\n                  this.dones.next(scopeIDs);\n                }\n              },\n            });\n\n            break;\n          case \"AttributeChange\":\n            group.subscribe({\n              next: (msg) => {\n                if (\n                  !msg.change ||\n                  msg.removed === null ||\n                  msg.removed === undefined\n                ) {\n                  trace(\"AttributeChange empty\");\n                } else {\n                  const atChange = <AttributeChange>msg.change;\n                  scopeIDs.push(atChange.nodeID || atChange.node!.id);\n                  this.attributes.next({\n                    attribute: atChange,\n                    removed: msg.removed,\n                  });\n                }\n\n                if (msg.done) {\n                  this.dones.next(scopeIDs);\n                  scopeIDs = [];\n                }\n              },\n            });\n\n            break;\n          case \"ParticipantChange\":\n            group.subscribe({\n              next: (msg) => {\n                if (\n                  !msg.change ||\n                  msg.removed === null ||\n                  msg.removed === undefined\n                ) {\n                  trace(\"ParticipantChange empty\");\n                } else {\n                  this.participants.next({\n                    participant: <ParticipantChange>msg.change,\n                    removed: msg.removed,\n                  });\n                }\n\n                if (msg.done) {\n                  this.dones.next([]);\n                }\n              },\n            });\n\n            break;\n          case \"StepChange\":\n            group.subscribe({\n              next: (msg) => {\n                if (\n                  !msg.change ||\n                  msg.removed === null ||\n                  msg.removed === undefined\n                ) {\n                  trace(\"StepChange empty\");\n                } else {\n                  this.steps.next({\n                    step: <StepChange>msg.change,\n                    removed: msg.removed,\n                  });\n                }\n\n                if (msg.done) {\n                  this.dones.next([]);\n                }\n              },\n            });\n\n            break;\n          default:\n            group.subscribe({\n              next: (change) => {\n                if (change.done) {\n                  this.dones.next([]);\n                }\n              },\n            });\n\n            break;\n        }\n      },\n    });\n  }\n}\n","import { BehaviorSubject, Observable } from \"rxjs\";\nimport { Attribute, AttributeOptions, Attributes } from \"../shared/attributes\";\nimport { Constructor } from \"../shared/helpers\";\nimport { warn } from \"../utils/console\";\nimport { JsonValue } from \"../utils/json\";\n\nexport type Attributable = {\n  get: (key: string) => JsonValue | undefined;\n  getAttribute: (key: string) => Attribute | undefined;\n  set: (key: string, value: JsonValue, ao?: Partial<AttributeOptions>) => void;\n  append: (\n    key: string,\n    value: JsonValue,\n    ao?: Partial<AttributeOptions>\n  ) => void;\n};\n\nexport interface ScopeIdent {\n  id: string;\n  kind: string;\n}\n\nexport interface ScopeUpdate {\n  scope: ScopeIdent;\n  removed: boolean;\n}\n\nexport type ScopeConstructor<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> = Constructor<Scope<Context, Kinds>>;\n\nexport class Scopes<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> },\n  Skope extends Scope<Context, Kinds> = Scope<Context, Kinds>\n> {\n  protected scopes = new Map<string, BehaviorSubject<Skope>>();\n  // newScopes is used to track scopes that have appeared for the first time.\n  protected newScopes = new Map<string, boolean>();\n  protected scopesByKind = new Map<keyof Kinds, Map<string, Skope>>();\n  protected kindUpdated = new Set<keyof Kinds>();\n\n  constructor(\n    scopesObs: Observable<ScopeUpdate>,\n    donesObs: Observable<string[]>,\n    protected ctx: Context,\n    protected kinds: Kinds,\n    protected attributes: Attributes\n  ) {\n    scopesObs.subscribe({\n      next: ({ scope, removed }) => {\n        this.update(scope, removed);\n      },\n    });\n\n    donesObs.subscribe({\n      next: (scopeIDs) => {\n        this.next(scopeIDs);\n      },\n    });\n  }\n\n  scope(id: string): Skope | undefined {\n    return this.scopes.get(id)?.getValue();\n  }\n\n  scopeObs(id: string): Observable<Skope> | undefined {\n    return this.scopes.get(id);\n  }\n\n  byKind<T extends Skope>(kind: keyof Kinds) {\n    let map = this.scopesByKind.get(kind);\n    if (!map) {\n      map = new Map();\n      this.scopesByKind.set(kind, map);\n    }\n\n    return map! as Map<string, T>;\n  }\n\n  kindWasUpdated(kind: keyof Kinds): boolean {\n    return this.kindUpdated.has(kind);\n  }\n\n  protected next(scopeIDs: string[]) {\n    this.kindUpdated.clear();\n    for (const [_, scopeSubject] of this.scopes) {\n      const scope = scopeSubject.getValue();\n      if (\n        (scope._updated || this.attributes.scopeWasUpdated(scope.id)) &&\n        scopeIDs.includes(scope.id)\n      ) {\n        scope._updated = false;\n        scopeSubject.next(scope);\n      }\n    }\n  }\n\n  protected update(scope: ScopeIdent, removed: boolean) {\n    const existing = this.scopes.get(scope.id)?.getValue();\n\n    if (removed) {\n      if (!existing) {\n        warn(\"scopes: missing scope on removal\", scope.id, scope.kind);\n\n        return;\n      }\n\n      existing._deleted = true;\n      existing._updated = true;\n      this.scopes.delete(scope.id);\n\n      if (!scope.kind) {\n        warn(\"scopes: scope missing kind on scope on removal\");\n\n        return;\n      }\n\n      const kind = scope.kind as keyof Kinds;\n\n      // Using ! because scopes by kind must exist, since this scope was found.\n      this.scopesByKind.get(kind)!.delete(scope.id);\n\n      this.kindUpdated.add(kind);\n\n      return;\n    }\n\n    if (existing) {\n      existing._deleted = false;\n      return;\n    }\n\n    if (!scope.kind) {\n      warn(\"scopes: scope missing kind on scope\");\n\n      return;\n    }\n\n    const kind = scope.kind as keyof Kinds;\n    const scopeClass = this.kinds[kind];\n    if (!scopeClass) {\n      warn(`scopes: unknown scope kind: ${scope.kind}`);\n\n      return;\n    }\n\n    const obj = this.create(scopeClass, scope);\n    const subj = new BehaviorSubject(obj);\n    this.scopes.set(scope.id, subj);\n    this.newScopes.set(scope.id, true);\n\n    let skm = this.scopesByKind.get(kind);\n    if (!skm) {\n      skm = new Map();\n      this.scopesByKind.set(kind, skm);\n    }\n\n    skm.set(scope.id, obj);\n\n    obj._updated = true;\n    this.kindUpdated.add(kind);\n  }\n\n  protected create(\n    scopeClass: ScopeConstructor<Context, Kinds>,\n    scope: ScopeIdent\n  ) {\n    return new scopeClass!(this.ctx, scope, this.attributes) as Skope;\n  }\n}\n\nexport type AttributeInput = {\n  key: string;\n  value: JsonValue;\n  ao?: Partial<AttributeOptions>;\n};\n\nexport class Scope<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> {\n  /**\n   * @internal\n   */\n  _deleted = false;\n\n  /**\n   * @internal\n   */\n  _updated = false;\n\n  constructor(\n    /**\n     * @internal\n     */\n    readonly ctx: Context,\n    /**\n     * @internal\n     */\n    readonly scope: ScopeIdent,\n    /**\n     * @internal\n     */\n    protected attributes: Attributes\n  ) {}\n\n  get id() {\n    return this.scope.id;\n  }\n\n  /**\n   * @internal\n   */\n  get kind() {\n    // Using ! because we don't allow scopes without kind\n    return this.scope.kind!;\n  }\n\n  get(key: string): JsonValue | undefined {\n    return this.attributes.attribute(this.scope.id, key).value;\n  }\n\n  getAttribute(key: string): Attribute | undefined {\n    return this.attributes.attribute(this.scope.id, key);\n  }\n\n  obs(key: string): Observable<JsonValue | undefined> {\n    return this.attributes.attribute(this.scope.id, key).obs;\n  }\n\n  set(values: AttributeInput[]): void;\n  set(key: string, value: JsonValue, ao?: Partial<AttributeOptions>): void;\n  set(\n    keyOrAttributes: string | AttributeInput[],\n    value?: JsonValue,\n    ao?: Partial<AttributeOptions>\n  ) {\n    if (typeof keyOrAttributes === \"string\") {\n      if (value === undefined) {\n        value = null;\n      }\n\n      return this.attributes\n        .attribute(this.scope.id, keyOrAttributes)\n        .set(value, ao);\n    }\n\n    const nextProps = [];\n    for (const attr of keyOrAttributes) {\n      nextProps.push(\n        this.attributes\n          .attribute(this.scope.id, attr.key)\n          ._prepSet(attr.value, attr.ao)\n      );\n    }\n\n    this.attributes.setAttributes(nextProps);\n  }\n\n  append(key: string, value: JsonValue, ao?: Partial<AttributeOptions>) {\n    if (!ao) {\n      ao = {};\n    }\n    ao.append = true;\n\n    return this.attributes.attribute(this.scope.id, key).set(value, ao);\n  }\n\n  inspect() {\n    const attrs = this.attributes.attributes(this.scope.id);\n\n    const out: { [key: string]: JsonValue | undefined } = {};\n    for (const attr of attrs) {\n      out[attr.key] = attr.value;\n    }\n\n    return out;\n  }\n\n  /**\n   * @internal\n   */\n  hasUpdated() {\n    return this._updated || this.attributes.scopeWasUpdated(this.id);\n  }\n}\n","import { Observable } from \"rxjs\";\nimport { Attributes } from \"../shared/attributes\";\nimport {\n  Scope as SharedScope,\n  ScopeConstructor,\n  ScopeIdent,\n  Scopes as SharedScopes,\n  ScopeUpdate,\n} from \"../shared/scopes\";\nimport { Steps } from \"./steps\";\n\nexport class Scopes<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> extends SharedScopes<Context, Kinds, Scope<Context, Kinds>> {\n  constructor(\n    scopesObs: Observable<ScopeUpdate>,\n    donesObs: Observable<string[]>,\n    ctx: Context,\n    kinds: Kinds,\n    attributes: Attributes,\n    private steps: Steps\n  ) {\n    super(scopesObs, donesObs, ctx, kinds, attributes);\n  }\n\n  protected create(\n    scopeClass: ScopeConstructor<Context, Kinds>,\n    scope: ScopeIdent\n  ) {\n    return new scopeClass!(\n      this.ctx,\n      scope,\n      this,\n      this.attributes,\n      this.steps\n    ) as Scope<Context, Kinds>;\n  }\n}\n\nexport class Scope<\n  Context,\n  Kinds extends { [key: string]: ScopeConstructor<Context, Kinds> }\n> extends SharedScope<Context, Kinds> {\n  constructor(\n    ctx: Context,\n    scope: ScopeIdent,\n    readonly scopes: Scopes<Context, Kinds>,\n    attributes: Attributes,\n    private steps: Steps\n  ) {\n    super(ctx, scope, attributes);\n  }\n\n  scopeByKey(key: string) {\n    const id = this.get(key);\n    if (!id || typeof id !== \"string\") {\n      return;\n    }\n\n    return this.scopes.scope(id);\n  }\n\n  protected ticker(id: string) {\n    return this.steps.step(id);\n  }\n\n  protected tickerByKey(key: string) {\n    const id = this.get(key);\n    if (!id || typeof id !== \"string\") {\n      return;\n    }\n\n    return this.ticker(id);\n  }\n}\n","import { BehaviorSubject, map, Observable } from \"rxjs\";\n\nexport interface StepChange {\n  id: string;\n  running: boolean;\n  elapsed?: number;\n  remaining?: number;\n}\n\nexport interface StepUpdate {\n  step: StepChange;\n  removed: boolean;\n}\n\nexport interface StepTick {\n  started: boolean;\n  ended: boolean;\n  elapsed: number;\n  remaining: number;\n  duration: number;\n}\n\ntype schds = {\n  cb: (args: void) => void;\n  from: number;\n  dur: number;\n};\n\nlet scheduled: schds[] = [];\n\nexport let mockNow: number | null = null;\nexport function setNow(now: number) {\n  if (mockNow && mockNow > now) {\n    if (now === 0) {\n      // This is a reset scheduled should be empty\n      scheduled = [];\n      /* c8 ignore next 3 */\n    } else {\n      throw \"time must move forward\";\n    }\n  }\n\n  mockNow = now;\n\n  const rescheduled: schds[] = [];\n  for (const s of scheduled) {\n    if (mockNow >= s.from + s.dur) {\n      s.cb();\n    } else {\n      rescheduled.push(s);\n    }\n  }\n\n  scheduled = rescheduled;\n}\n\nfunction pnow() {\n  if (mockNow !== null) {\n    return mockNow;\n  } else {\n    // TODO sync time\n    return performance.now();\n  }\n}\n\nfunction timeout(callback: (args: void) => void, ms: number) {\n  if (mockNow !== null) {\n    const schd = {\n      cb: callback,\n      from: mockNow,\n      dur: ms,\n    };\n    scheduled.push(schd);\n  } else {\n    setTimeout(callback, ms);\n  }\n}\n\n// The number of milliseconds elapsed since January 1, 1970 00:00:00 UTC, with\n// leap seconds ignored.\nexport type Epoch = number;\n\nexport class Step {\n  private running = false;\n  private ticker = new BehaviorSubject<StepTick | undefined>(undefined);\n  private startAt: number = 0;\n  private endAt: number = 0;\n\n  constructor(step: StepChange, ticker: Observable<DOMHighResTimeStamp>) {\n    ticker.pipe(map(this.recalc.bind(this))).subscribe({\n      next: (val) => {\n        this.ticker.next(val);\n      },\n    });\n\n    this._update(step);\n  }\n\n  private recalc(t: DOMHighResTimeStamp) {\n    if (!this.running) {\n      return undefined;\n    }\n\n    return {\n      started: t >= this.startAt,\n      ended: t >= this.endAt,\n      elapsed: Math.round(t - this.startAt),\n      remaining: Math.round(this.endAt - t),\n      duration: this.endAt - this.startAt,\n    } as StepTick;\n  }\n\n  obs(): Observable<StepTick | undefined> {\n    return this.ticker;\n  }\n\n  get current() {\n    return this.recalc(pnow());\n  }\n\n  // internal only\n  _update(step: StepChange) {\n    if (!step.running) {\n      this.running = false;\n      this.ticker.next(undefined);\n\n      return;\n    }\n\n    if (\n      step.elapsed === null ||\n      step.remaining === null ||\n      step.elapsed === undefined ||\n      step.remaining === undefined\n    ) {\n      this.running = false;\n\n      return;\n    }\n\n    const now = pnow();\n\n    this.startAt = now - step.elapsed * 1000;\n    this.endAt = now + step.remaining * 1000;\n    this.running = step.elapsed >= 0 && step.remaining >= 0;\n\n    this.ticker.next(this.recalc(now));\n  }\n\n  // internal only\n  _stop() {\n    this.running = false;\n    this.ticker.next(undefined);\n  }\n}\n\nexport class Steps {\n  private steps = new Map<string, Step>();\n  private updates = new Map<string, StepChange | boolean>();\n  private _hadUpdates = false;\n\n  private ticker: BehaviorSubject<Epoch>;\n\n  constructor(stepsObs: Observable<StepUpdate>, donesObs: Observable<void>) {\n    stepsObs.subscribe({\n      next: ({ step, removed }) => {\n        this.update(step, removed);\n      },\n    });\n\n    donesObs.subscribe({\n      next: () => {\n        this.next();\n      },\n    });\n\n    this.ticker = new BehaviorSubject<Epoch>(Math.floor(pnow()));\n    const controller = new AbortController();\n    timerInterval(1000, controller.signal, (t) => {\n      this.ticker.next(t);\n    });\n  }\n\n  step(stepID: string): Step | undefined {\n    return this.steps.get(stepID);\n  }\n\n  hadUpdates() {\n    const hadUpdates = this._hadUpdates;\n    this._hadUpdates = false;\n\n    return hadUpdates;\n  }\n\n  private update(step: StepChange, removed: boolean) {\n    if (removed) {\n      this.updates.set(step.id, true);\n    } else {\n      this.updates.set(step.id, step);\n    }\n\n    this._hadUpdates = true;\n  }\n\n  private next() {\n    for (const [id, stepOrDel] of this.updates) {\n      let step = this.steps.get(id);\n      if (typeof stepOrDel === \"boolean\") {\n        if (step) {\n          step._stop();\n          this.steps.delete(id);\n        }\n      } else {\n        if (!step) {\n          step = new Step(stepOrDel, this.ticker);\n          this.steps.set(id, step);\n        }\n\n        step._update(stepOrDel);\n      }\n    }\n\n    this.updates.clear();\n  }\n}\n\n/* c8 ignore next 6 */\nexport const root: any =\n  typeof self === \"object\" && self.self == self\n    ? self\n    : typeof global === \"object\" && global.global == global\n    ? global\n    : {};\n\n// nodejs support\nif (!root[\"requestAnimationFrame\"]) {\n  type timecb = (t: DOMHighResTimeStamp) => void;\n  root[\"requestAnimationFrame\"] = (cb: timecb) => cb(pnow());\n}\n\n// Inspiration:\n// https://www.youtube.com/watch?v=MCi6AZMkxcU\n// https://gist.github.com/jakearchibald/cb03f15670817001b1157e62a076fe95\nfunction timerInterval(\n  ms: number = 1000,\n  signal: AbortSignal,\n  callback: (time: number) => void\n) {\n  // Performance should be available in Nodejs 10+.\n  // Get the last rounded second, which will go negative, but that's fine, since\n  // it will immediately send out its first tick, then be on the second.\n  const start = Math.floor(pnow() / 1000) * 1000;\n\n  function frame(time: number) {\n    /* c8 ignore next */\n    if (signal.aborted) return;\n    callback(time);\n    scheduleFrame(time);\n  }\n\n  function scheduleFrame(time: number) {\n    const elapsed = time - start;\n    const roundedElapsed = Math.round(elapsed / ms) * ms;\n    const targetNext = start + roundedElapsed + ms;\n    const delay = targetNext - pnow();\n    timeout(() => requestAnimationFrame(frame), delay);\n  }\n\n  scheduleFrame(start);\n}\n\n// export function useAnimationInterval(\n//   ms: number,\n//   callback: (time: number) => void\n// ) {\n//   const callbackRef = React.useRef(callback);\n//   React.useEffect(() => {\n//     callbackRef.current = callback;\n//   }, [callback]);\n\n//   React.useEffect(() => {\n//     const controller = new AbortController();\n//     animationInterval(ms, controller.signal, callbackRef.current);\n//     return () => controller.abort();\n//   }, [ms]);\n// }\n","export const isDevelopment = process.env.NODE_ENV === \"development\";\nexport const isProduction = process.env.NODE_ENV === \"production\";\nexport const isTest = process.env.NODE_ENV === \"test\";\n\nexport const createNewParticipant = (key = \"participantKey\") => {\n  const url = new URL(document.location.href);\n  url.searchParams.set(key, new Date().getTime().toString());\n  window.open(url.href, \"_blank\")?.focus();\n};\n","import { BehaviorSubject, Observable, Subject } from \"rxjs\";\nimport { Attributes } from \"../../shared/attributes\";\nimport { Globals } from \"../../shared/globals\";\nimport { Constructor } from \"../../shared/helpers\";\nimport { TajribaProvider } from \"../provider\";\nimport { Scope, Scopes } from \"../scopes\";\nimport { Steps } from \"../steps\";\n\nexport const endedStatuses = [\"ended\", \"terminated\", \"failed\"];\nexport type EndedStatuses = typeof endedStatuses[number];\n\nexport class Game extends Scope<Context, EmpiricaClassicKinds> {\n  get hasEnded() {\n    return endedStatuses.includes(this.get(\"status\") as EndedStatuses);\n  }\n\n  get stage() {\n    return this.scopeByKey(\"stageID\") as Stage | undefined;\n  }\n\n  get round() {\n    return this.stage?.round;\n  }\n}\n\nexport class Player extends Scope<Context, EmpiricaClassicKinds> {\n  get game() {\n    const { game } = this.ctx;\n    if (!game) {\n      return;\n    }\n\n    const key = `playerGameID-${game.id}`;\n    return this.scopeByKey(key) as PlayerGame | undefined;\n  }\n\n  get round() {\n    const { stage } = this.ctx;\n    if (!stage) {\n      return;\n    }\n\n    const { round } = stage;\n    if (!round) {\n      return;\n    }\n\n    const key = `playerRoundID-${round.id}`;\n    return this.scopeByKey(key) as PlayerRound | undefined;\n  }\n\n  get stage() {\n    const { stage } = this.ctx;\n    if (!stage) {\n      return;\n    }\n\n    const key = `playerStageID-${stage.id}`;\n    return this.scopeByKey(key) as PlayerStage | undefined;\n  }\n\n  hasUpdated() {\n    if (super.hasUpdated()) {\n      return true;\n    }\n\n    return Boolean(\n      this.round?.hasUpdated() ||\n        this.stage?.hasUpdated() ||\n        this.game?.hasUpdated()\n    );\n  }\n}\n\nexport class PlayerGame extends Scope<Context, EmpiricaClassicKinds> {}\n\nexport class PlayerRound extends Scope<Context, EmpiricaClassicKinds> {}\n\nexport class PlayerStage extends Scope<Context, EmpiricaClassicKinds> {}\n\nexport class Round extends Scope<Context, EmpiricaClassicKinds> {}\n\nexport class Stage extends Scope<Context, EmpiricaClassicKinds> {\n  get round() {\n    return this.scopeByKey(\"roundID\") as Round | undefined;\n  }\n\n  get timer() {\n    return this.tickerByKey(\"timerID\");\n  }\n}\n\n// TODO update context\nexport class Context {\n  public game?: Game | null;\n  public stage?: Stage | null;\n}\n\nexport type EmpiricaClassicKinds = {\n  game: Constructor<Game>;\n  player: Constructor<Player>;\n  playerGame: Constructor<PlayerGame>;\n  playerRound: Constructor<PlayerRound>;\n  playerStage: Constructor<PlayerStage>;\n  round: Constructor<Round>;\n  stage: Constructor<Stage>;\n};\n\nexport const kinds = {\n  game: Game,\n  player: Player,\n  playerGame: PlayerGame,\n  playerRound: PlayerRound,\n  playerStage: PlayerStage,\n  round: Round,\n  stage: Stage,\n};\n\nexport type EmpiricaClassicContext = {\n  game: BehaviorSubject<Game | null | undefined>;\n  player: BehaviorSubject<Player | null | undefined>;\n  players: BehaviorSubject<Player[] | undefined>;\n  round: BehaviorSubject<Round | null | undefined>;\n  stage: BehaviorSubject<Stage | null | undefined>;\n  globals: BehaviorSubject<Globals | undefined>;\n};\n\nexport function EmpiricaClassic(\n  participantID: string,\n  provider: TajribaProvider\n): EmpiricaClassicContext {\n  const attributesDones = new Subject<string[]>();\n  const scopesDones = new Subject<string[]>();\n\n  const ctx = new Context();\n  const attributes = new Attributes(\n    provider.attributes,\n    attributesDones,\n    provider.setAttributes\n  );\n  const steps = new Steps(\n    provider.steps,\n    provider.dones as unknown as Observable<void>\n  );\n  const scopes = new Scopes(\n    provider.scopes,\n    scopesDones,\n    ctx,\n    kinds,\n    attributes,\n    steps\n  );\n  const participantIDs = new Set<string>();\n\n  const glob = new Globals(provider.globals);\n\n  const ret = {\n    game: new BehaviorSubject<Game | null | undefined>(undefined),\n    player: new BehaviorSubject<Player | null | undefined>(undefined),\n    players: new BehaviorSubject<Player[] | undefined>(undefined),\n    round: new BehaviorSubject<Round | null | undefined>(undefined),\n    stage: new BehaviorSubject<Stage | null | undefined>(undefined),\n    globals: glob.self,\n  };\n\n  provider.participants.subscribe({\n    next: ({ participant, removed }) => {\n      if (removed) {\n        if (participantIDs.has(participant.id)) {\n          participantIDs.delete(participant.id);\n        }\n      } else {\n        if (!participantIDs.has(participant.id)) {\n          participantIDs.add(participant.id);\n        }\n      }\n    },\n  });\n\n  let scopesUpdated = new Set<string>();\n  provider.attributes.subscribe({\n    next: (attr) => {\n      const nodeID = attr.attribute.node?.id || attr.attribute.nodeID;\n      if (!nodeID) {\n        return;\n      }\n\n      scopesUpdated.add(nodeID);\n    },\n  });\n\n  provider.dones.subscribe({\n    next: () => {\n      const current = getCurrent(ret);\n      const updated = getMainObjects(participantID, scopes, attributes);\n      ctx.game = updated.game;\n      ctx.stage = updated.stage;\n\n      if (scopeChanged(current.game, updated.game)) {\n        ret.game.next(updated.game);\n      }\n\n      if (scopeChanged(current.player, updated.player)) {\n        ret.player.next(updated.player);\n      }\n\n      if (scopeChanged(current.round, updated.round)) {\n        ret.round.next(updated.round);\n      }\n\n      if (scopeChanged(current.stage, updated.stage) || steps.hadUpdates()) {\n        ret.stage.next(updated.stage);\n      }\n\n      let playersChanged = false;\n      const players: Player[] = [];\n      for (let i = 0; i < (updated.players || []).length; i++) {\n        let p = updated.players![i];\n\n        if (p) {\n          const partID = attributes.nextAttributeValue(\n            p.id,\n            \"participantID\"\n          ) as string;\n          if (!participantIDs.has(partID)) {\n            p = undefined;\n          }\n        }\n\n        if (!playersChanged && scopeChanged(p, (current.players || [])[i])) {\n          playersChanged = true;\n        }\n\n        if (p) {\n          players.push(p);\n        }\n      }\n      if (playersChanged) {\n        ret.players.next(players);\n      }\n\n      const scopeIDs = Array.from(scopesUpdated);\n      scopesDones.next(scopeIDs);\n      attributesDones.next(scopeIDs);\n      scopesUpdated.clear();\n    },\n  });\n\n  return ret;\n}\n\ntype mainObjects = {\n  game?: Game | null;\n  player?: Player | null;\n  round?: Round | null;\n  stage?: Stage | null;\n  players?: Player[];\n};\n\nfunction scopeChanged(\n  current?: Scope<Context, EmpiricaClassicKinds> | null,\n  updated?: Scope<Context, EmpiricaClassicKinds> | null\n): boolean {\n  if (!current && !updated) {\n    if (current === undefined && updated === null) {\n      return true;\n    }\n\n    return false;\n  }\n\n  if (!current || !updated) {\n    return true;\n  }\n\n  return current.id !== updated.id || updated.hasUpdated();\n}\n\nfunction getCurrent(ctx: EmpiricaClassicContext): mainObjects {\n  return {\n    game: ctx.game.getValue(),\n    player: ctx.player.getValue(),\n    round: ctx.round.getValue(),\n    stage: ctx.stage.getValue(),\n    players: ctx.players.getValue(),\n  };\n}\n\nfunction getMainObjects(\n  participantID: string,\n  scopes: Scopes<Context, EmpiricaClassicKinds>,\n  attributes: Attributes\n): mainObjects {\n  const players = scopes.byKind(\"player\");\n\n  const res: mainObjects = {\n    players: Array.from(players.values()) as Player[],\n    game: null,\n    player: null,\n    round: null,\n    stage: null,\n  };\n\n  if (players.size === 0) {\n    return res;\n  }\n\n  res.player = Array.from(players.values()).find((p) => {\n    const pID = attributes.nextAttributeValue(p.id, \"participantID\") as string;\n    return pID === participantID;\n  }) as Player;\n\n  if (!res.player) {\n    return res;\n  }\n\n  res.game = nextScopeByKey(scopes, attributes, res.player, \"gameID\") as Game;\n  if (!res.game) {\n    return res;\n  }\n\n  for (const player of res.players || []) {\n    const key = `playerGameID-${res.game.id}`;\n    if (!nextScopeByKey(scopes, attributes, player, key)) {\n      return res;\n    }\n  }\n\n  res.stage = nextScopeByKey(scopes, attributes, res.game, \"stageID\") as Stage;\n  if (!res.stage) {\n    return res;\n  }\n\n  for (const player of res.players || []) {\n    const key = `playerStageID-${res.stage.id}`;\n    if (!nextScopeByKey(scopes, attributes, player, key)) {\n      delete res.stage;\n      return res;\n    }\n  }\n\n  res.round = nextScopeByKey(scopes, attributes, res.stage, \"roundID\") as Round;\n  if (!res.round) {\n    return res;\n  }\n\n  for (const player of res.players || []) {\n    const key = `playerRoundID-${res.round.id}`;\n    if (!nextScopeByKey(scopes, attributes, player, key)) {\n      delete res.stage;\n      delete res.round;\n      return res;\n    }\n  }\n\n  return res;\n}\n\nfunction nextScopeByKey(\n  scopes: Scopes<Context, EmpiricaClassicKinds>,\n  attributes: Attributes,\n  scope: Scope<Context, EmpiricaClassicKinds>,\n  key: string\n) {\n  const id = attributes.nextAttributeValue(scope.id, key);\n  if (!id || typeof id !== \"string\") {\n    return null;\n  }\n\n  return scopes.scope(id) || null;\n}\n"],"mappings":"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","names":["Scope","Scopes","error","attr","newAttr","value","import_rxjs","import_rxjs","import_rxjs","kinds","map","kind","Scopes","kinds","Scope","import_rxjs","import_rxjs","Scope","Scopes"]}