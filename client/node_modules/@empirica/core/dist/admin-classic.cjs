"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../../node_modules/fs.realpath/old.js
var require_old = __commonJS({
  "../../../node_modules/fs.realpath/old.js"(exports) {
    var pathModule = require("path");
    var isWindows = process.platform === "win32";
    var fs3 = require("fs");
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    var normalize = pathModule.normalize;
    if (isWindows) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports.realpathSync = function realpathSync(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs3.lstatSync(base);
          knownHard[base] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          resolvedLink = cache[base];
        } else {
          var stat = fs3.lstatSync(base);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            continue;
          }
          var linkTarget = null;
          if (!isWindows) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs3.statSync(base);
            linkTarget = fs3.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base] = resolvedLink;
          if (!isWindows)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    exports.realpath = function realpath(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs3.lstat(base, function(err) {
            if (err)
              return cb(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          return gotResolvedLink(cache[base]);
        }
        return fs3.lstat(base, gotStat);
      }
      function gotStat(err, stat) {
        if (err)
          return cb(err);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          return process.nextTick(LOOP);
        }
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs3.stat(base, function(err2) {
          if (err2)
            return cb(err2);
          fs3.readlink(base, function(err3, target) {
            if (!isWindows)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base2) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base2] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
  }
});

// ../../../node_modules/fs.realpath/index.js
var require_fs = __commonJS({
  "../../../node_modules/fs.realpath/index.js"(exports, module2) {
    module2.exports = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync;
    realpath.realpathSync = realpathSync;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs3 = require("fs");
    var origRealpath = fs3.realpath;
    var origRealpathSync = fs3.realpathSync;
    var version = process.version;
    var ok = /^v[0-5]\./.test(version);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs3.realpath = realpath;
      fs3.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs3.realpath = origRealpath;
      fs3.realpathSync = origRealpathSync;
    }
  }
});

// ../../../node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "../../../node_modules/concat-map/index.js"(exports, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// ../../../node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "../../../node_modules/balanced-match/index.js"(exports, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// ../../../node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "../../../node_modules/brace-expansion/index.js"(exports, module2) {
    var concatMap2 = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z6 = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z6 + c.slice(1);
                else
                  c = z6 + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap2(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// ../../../node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "../../../node_modules/minimatch/minimatch.js"(exports, module2) {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path = function() {
      try {
        return require("path");
      } catch (e) {
      }
    }() || {
      sep: "/"
    };
    minimatch.sep = path.sep;
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      b = b || {};
      var t = {};
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      m.Minimatch.defaults = function defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      };
      m.filter = function filter2(pattern, options) {
        return orig.filter(pattern, ext(def, options));
      };
      m.defaults = function defaults(options) {
        return orig.defaults(ext(def, options));
      };
      m.makeRe = function makeRe2(pattern, options) {
        return orig.makeRe(pattern, ext(def, options));
      };
      m.braceExpand = function braceExpand2(pattern, options) {
        return orig.braceExpand(pattern, ext(def, options));
      };
      m.match = function(list, pattern, options) {
        return orig.match(list, pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      assertValidPattern(pattern);
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      assertValidPattern(pattern);
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (!options.allowWindowsEscape && path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = function debug2() {
          console.error.apply(console, arguments);
        };
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    }
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = function(pattern) {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    Minimatch.prototype.parse = parse;
    var SUBPARSE = {};
    function parse(pattern, isSub) {
      assertValidPattern(pattern);
      var options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/": {
            return false;
          }
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case "[":
        case ".":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = function match(f, partial) {
      if (typeof partial === "undefined")
        partial = this.partial;
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path.sep !== "/") {
        f = f.split(path.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    };
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// ../../../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../../../node_modules/inherits/inherits_browser.js"(exports, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../../../node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "../../../node_modules/inherits/inherits.js"(exports, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// ../../../node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS({
  "../../../node_modules/path-is-absolute/index.js"(exports, module2) {
    "use strict";
    function posix(path) {
      return path.charAt(0) === "/";
    }
    function win32(path) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  }
});

// ../../../node_modules/glob/common.js
var require_common = __commonJS({
  "../../../node_modules/glob/common.js"(exports) {
    exports.setopts = setopts;
    exports.ownProp = ownProp;
    exports.makeAbs = makeAbs;
    exports.finish = finish;
    exports.mark = mark;
    exports.isIgnored = isIgnored;
    exports.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var fs3 = require("fs");
    var path = require("path");
    var minimatch = require_minimatch();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasort(a, b) {
      return a.localeCompare(b, "en");
    }
    function setupIgnores(self, options) {
      self.ignore = options.ignore || [];
      if (!Array.isArray(self.ignore))
        self.ignore = [self.ignore];
      if (self.ignore.length) {
        self.ignore = self.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self.silent = !!options.silent;
      self.pattern = pattern;
      self.strict = options.strict !== false;
      self.realpath = !!options.realpath;
      self.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
      self.follow = !!options.follow;
      self.dot = !!options.dot;
      self.mark = !!options.mark;
      self.nodir = !!options.nodir;
      if (self.nodir)
        self.mark = true;
      self.sync = !!options.sync;
      self.nounique = !!options.nounique;
      self.nonull = !!options.nonull;
      self.nosort = !!options.nosort;
      self.nocase = !!options.nocase;
      self.stat = !!options.stat;
      self.noprocess = !!options.noprocess;
      self.absolute = !!options.absolute;
      self.fs = options.fs || fs3;
      self.maxLength = options.maxLength || Infinity;
      self.cache = options.cache || /* @__PURE__ */ Object.create(null);
      self.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
      self.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self, options);
      self.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self.cwd = cwd;
      else {
        self.cwd = path.resolve(options.cwd);
        self.changedCwd = self.cwd !== cwd;
      }
      self.root = options.root || path.resolve(self.cwd, "/");
      self.root = path.resolve(self.root);
      if (process.platform === "win32")
        self.root = self.root.replace(/\\/g, "/");
      self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd);
      if (process.platform === "win32")
        self.cwdAbs = self.cwdAbs.replace(/\\/g, "/");
      self.nomount = !!options.nomount;
      options.nonegate = true;
      options.nocomment = true;
      options.allowWindowsEscape = false;
      self.minimatch = new Minimatch(pattern, options);
      self.options = self.minimatch.options;
    }
    function finish(self) {
      var nou = self.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i = 0, l = self.matches.length; i < l; i++) {
        var matches = self.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self.nonull) {
            var literal = self.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self.nosort)
        all = all.sort(alphasort);
      if (self.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self._mark(all[i]);
        }
        if (self.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self.cache[e] || self.cache[makeAbs(self, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self, m2);
        });
      self.found = all;
    }
    function mark(self, p) {
      var abs = makeAbs(self, p);
      var c = self.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self, m);
          self.statCache[mabs] = self.statCache[abs];
          self.cache[mabs] = self.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path.join(self.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self.changedCwd) {
        abs = path.resolve(self.cwd, f);
      } else {
        abs = path.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self, path2) {
      if (!self.ignore.length)
        return false;
      return self.ignore.some(function(item) {
        return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
    function childrenIgnored(self, path2) {
      if (!self.ignore.length)
        return false;
      return self.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
  }
});

// ../../../node_modules/glob/sync.js
var require_sync = __commonJS({
  "../../../node_modules/glob/sync.js"(exports, module2) {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob().Glob;
    var util = require("util");
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert.ok(this instanceof GlobSync);
      if (this.realpath) {
        var self = this;
        this.matches.forEach(function(matchset, index) {
          var set = self.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var p in matchset) {
            try {
              p = self._makeAbs(p);
              var real = rp.realpathSync(p, self.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert.ok(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      if (isIgnored(this, e))
        return;
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs;
      }
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error2 = new Error(er.code + " invalid cwd " + this.cwd);
            error2.path = this.cwd;
            error2.code = er.code;
            throw error2;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = this.fs.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat = this.fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});

// ../../../node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "../../../node_modules/wrappy/wrappy.js"(exports, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// ../../../node_modules/once/once.js
var require_once = __commonJS({
  "../../../node_modules/once/once.js"(exports, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// ../../../node_modules/inflight/inflight.js
var require_inflight = __commonJS({
  "../../../node_modules/inflight/inflight.js"(exports, module2) {
    var wrappy = require_wrappy();
    var reqs = /* @__PURE__ */ Object.create(null);
    var once = require_once();
    module2.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array = [];
      for (var i = 0; i < length; i++)
        array[i] = args[i];
      return array;
    }
  }
});

// ../../../node_modules/glob/glob.js
var require_glob = __commonJS({
  "../../../node_modules/glob/glob.js"(exports, module2) {
    module2.exports = glob;
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var inherits = require_inherits();
    var EE = require("events").EventEmitter;
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self._processing;
        if (self._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self._finish();
            });
          } else {
            self._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
      found.forEach(function(p, i) {
        p = self._makeAbs(p);
        rp.realpath(p, self.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self.emit("error", er);
          if (--n === 0) {
            self.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs;
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        self.fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self.cache[abs] = "FILE";
          cb();
        } else
          self._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self = this;
      self.fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self, abs, cb) {
      return function(er, entries) {
        if (er)
          self._readdirError(abs, er, cb);
        else
          self._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error2 = new Error(er.code + " invalid cwd " + this.cwd);
            error2.path = this.cwd;
            error2.code = er.code;
            this.emit("error", error2);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self = this;
      this._stat(prefix, function(er, exists) {
        self._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat);
        }
      }
      var self = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        self.fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return self.fs.stat(abs, function(er2, stat2) {
            if (er2)
              self._stat2(f, abs, null, lstat, cb);
            else
              self._stat2(f, abs, er2, stat2, cb);
          });
        } else {
          self._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
        return cb(null, false, stat);
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat);
    };
  }
});

// ../../../node_modules/rimraf/rimraf.js
var require_rimraf = __commonJS({
  "../../../node_modules/rimraf/rimraf.js"(exports, module2) {
    var assert = require("assert");
    var path = require("path");
    var fs3 = require("fs");
    var glob = void 0;
    try {
      glob = require_glob();
    } catch (_err) {
    }
    var defaultGlobOpts = {
      nosort: true,
      silent: true
    };
    var timeout = 0;
    var isWindows = process.platform === "win32";
    var defaults = (options) => {
      const methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach((m) => {
        options[m] = options[m] || fs3[m];
        m = m + "Sync";
        options[m] = options[m] || fs3[m];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
      options.emfileWait = options.emfileWait || 1e3;
      if (options.glob === false) {
        options.disableGlob = true;
      }
      if (options.disableGlob !== true && glob === void 0) {
        throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
      }
      options.disableGlob = options.disableGlob || false;
      options.glob = options.glob || defaultGlobOpts;
    };
    var rimraf = (p, options, cb) => {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert.equal(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      defaults(options);
      let busyTries = 0;
      let errState = null;
      let n = 0;
      const next = (er) => {
        errState = errState || er;
        if (--n === 0)
          cb(errState);
      };
      const afterGlob = (er, results) => {
        if (er)
          return cb(er);
        n = results.length;
        if (n === 0)
          return cb();
        results.forEach((p2) => {
          const CB = (er2) => {
            if (er2) {
              if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
                busyTries++;
                return setTimeout(() => rimraf_(p2, options, CB), busyTries * 100);
              }
              if (er2.code === "EMFILE" && timeout < options.emfileWait) {
                return setTimeout(() => rimraf_(p2, options, CB), timeout++);
              }
              if (er2.code === "ENOENT")
                er2 = null;
            }
            timeout = 0;
            next(er2);
          };
          rimraf_(p2, options, CB);
        });
      };
      if (options.disableGlob || !glob.hasMagic(p))
        return afterGlob(null, [p]);
      options.lstat(p, (er, stat) => {
        if (!er)
          return afterGlob(null, [p]);
        glob(p, options.glob, afterGlob);
      });
    };
    var rimraf_ = (p, options, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p, (er, st) => {
        if (er && er.code === "ENOENT")
          return cb(null);
        if (er && er.code === "EPERM" && isWindows)
          fixWinEPERM(p, options, er, cb);
        if (st && st.isDirectory())
          return rmdir(p, options, er, cb);
        options.unlink(p, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT")
              return cb(null);
            if (er2.code === "EPERM")
              return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
            if (er2.code === "EISDIR")
              return rmdir(p, options, er2, cb);
          }
          return cb(er2);
        });
      });
    };
    var fixWinEPERM = (p, options, er, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.chmod(p, 438, (er2) => {
        if (er2)
          cb(er2.code === "ENOENT" ? null : er);
        else
          options.stat(p, (er3, stats) => {
            if (er3)
              cb(er3.code === "ENOENT" ? null : er);
            else if (stats.isDirectory())
              rmdir(p, options, er, cb);
            else
              options.unlink(p, cb);
          });
      });
    };
    var fixWinEPERMSync = (p, options, er) => {
      assert(p);
      assert(options);
      try {
        options.chmodSync(p, 438);
      } catch (er2) {
        if (er2.code === "ENOENT")
          return;
        else
          throw er;
      }
      let stats;
      try {
        stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT")
          return;
        else
          throw er;
      }
      if (stats.isDirectory())
        rmdirSync(p, options, er);
      else
        options.unlinkSync(p);
    };
    var rmdir = (p, options, originalEr, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.rmdir(p, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
          rmkids(p, options, cb);
        else if (er && er.code === "ENOTDIR")
          cb(originalEr);
        else
          cb(er);
      });
    };
    var rmkids = (p, options, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        if (n === 0)
          return options.rmdir(p, cb);
        let errState;
        files.forEach((f) => {
          rimraf(path.join(p, f), options, (er2) => {
            if (errState)
              return;
            if (er2)
              return cb(errState = er2);
            if (--n === 0)
              options.rmdir(p, cb);
          });
        });
      });
    };
    var rimrafSync = (p, options) => {
      options = options || {};
      defaults(options);
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      let results;
      if (options.disableGlob || !glob.hasMagic(p)) {
        results = [p];
      } else {
        try {
          options.lstatSync(p);
          results = [p];
        } catch (er) {
          results = glob.sync(p, options.glob);
        }
      }
      if (!results.length)
        return;
      for (let i = 0; i < results.length; i++) {
        const p2 = results[i];
        let st;
        try {
          st = options.lstatSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM" && isWindows)
            fixWinEPERMSync(p2, options, er);
        }
        try {
          if (st && st.isDirectory())
            rmdirSync(p2, options, null);
          else
            options.unlinkSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM")
            return isWindows ? fixWinEPERMSync(p2, options, er) : rmdirSync(p2, options, er);
          if (er.code !== "EISDIR")
            throw er;
          rmdirSync(p2, options, er);
        }
      }
    };
    var rmdirSync = (p, options, originalEr) => {
      assert(p);
      assert(options);
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "ENOTDIR")
          throw originalEr;
        if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
          rmkidsSync(p, options);
      }
    };
    var rmkidsSync = (p, options) => {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach((f) => rimrafSync(path.join(p, f), options));
      const retries = isWindows ? 100 : 1;
      let i = 0;
      do {
        let threw = true;
        try {
          const ret = options.rmdirSync(p, options);
          threw = false;
          return ret;
        } finally {
          if (++i < retries && threw)
            continue;
        }
      } while (true);
    };
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
  }
});

// node_modules/tmp/lib/tmp.js
var require_tmp = __commonJS({
  "node_modules/tmp/lib/tmp.js"(exports, module2) {
    var fs3 = require("fs");
    var os = require("os");
    var path = require("path");
    var crypto = require("crypto");
    var _c = { fs: fs3.constants, os: os.constants };
    var rimraf = require_rimraf();
    var RANDOM_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    var TEMPLATE_PATTERN = /XXXXXX/;
    var DEFAULT_TRIES = 3;
    var CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR);
    var IS_WIN32 = os.platform() === "win32";
    var EBADF = _c.EBADF || _c.os.errno.EBADF;
    var ENOENT = _c.ENOENT || _c.os.errno.ENOENT;
    var DIR_MODE = 448;
    var FILE_MODE = 384;
    var EXIT = "exit";
    var _removeObjects = [];
    var FN_RMDIR_SYNC = fs3.rmdirSync.bind(fs3);
    var FN_RIMRAF_SYNC = rimraf.sync;
    var _gracefulCleanup = false;
    function tmpName(options, callback) {
      const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
      try {
        _assertAndSanitizeOptions(opts);
      } catch (err) {
        return cb(err);
      }
      let tries = opts.tries;
      (function _getUniqueName() {
        try {
          const name = _generateTmpName(opts);
          fs3.stat(name, function(err) {
            if (!err) {
              if (tries-- > 0)
                return _getUniqueName();
              return cb(new Error("Could not get a unique tmp filename, max tries reached " + name));
            }
            cb(null, name);
          });
        } catch (err) {
          cb(err);
        }
      })();
    }
    function tmpNameSync(options) {
      const args = _parseArguments(options), opts = args[0];
      _assertAndSanitizeOptions(opts);
      let tries = opts.tries;
      do {
        const name = _generateTmpName(opts);
        try {
          fs3.statSync(name);
        } catch (e) {
          return name;
        }
      } while (tries-- > 0);
      throw new Error("Could not get a unique tmp filename, max tries reached");
    }
    function file(options, callback) {
      const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
      tmpName(opts, function _tmpNameCreated(err, name) {
        if (err)
          return cb(err);
        fs3.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err2, fd) {
          if (err2)
            return cb(err2);
          if (opts.discardDescriptor) {
            return fs3.close(fd, function _discardCallback(possibleErr) {
              return cb(possibleErr, name, void 0, _prepareTmpFileRemoveCallback(name, -1, opts, false));
            });
          } else {
            const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
            cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));
          }
        });
      });
    }
    function fileSync(options) {
      const args = _parseArguments(options), opts = args[0];
      const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
      const name = tmpNameSync(opts);
      var fd = fs3.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
      if (opts.discardDescriptor) {
        fs3.closeSync(fd);
        fd = void 0;
      }
      return {
        name,
        fd,
        removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)
      };
    }
    function dir(options, callback) {
      const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
      tmpName(opts, function _tmpNameCreated(err, name) {
        if (err)
          return cb(err);
        fs3.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err2) {
          if (err2)
            return cb(err2);
          cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));
        });
      });
    }
    function dirSync(options) {
      const args = _parseArguments(options), opts = args[0];
      const name = tmpNameSync(opts);
      fs3.mkdirSync(name, opts.mode || DIR_MODE);
      return {
        name,
        removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)
      };
    }
    function _removeFileAsync(fdPath, next) {
      const _handler = function(err) {
        if (err && !_isENOENT(err)) {
          return next(err);
        }
        next();
      };
      if (0 <= fdPath[0])
        fs3.close(fdPath[0], function() {
          fs3.unlink(fdPath[1], _handler);
        });
      else
        fs3.unlink(fdPath[1], _handler);
    }
    function _removeFileSync(fdPath) {
      let rethrownException = null;
      try {
        if (0 <= fdPath[0])
          fs3.closeSync(fdPath[0]);
      } catch (e) {
        if (!_isEBADF(e) && !_isENOENT(e))
          throw e;
      } finally {
        try {
          fs3.unlinkSync(fdPath[1]);
        } catch (e) {
          if (!_isENOENT(e))
            rethrownException = e;
        }
      }
      if (rethrownException !== null) {
        throw rethrownException;
      }
    }
    function _prepareTmpFileRemoveCallback(name, fd, opts, sync) {
      const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync);
      const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync, removeCallbackSync);
      if (!opts.keep)
        _removeObjects.unshift(removeCallbackSync);
      return sync ? removeCallbackSync : removeCallback;
    }
    function _prepareTmpDirRemoveCallback(name, opts, sync) {
      const removeFunction = opts.unsafeCleanup ? rimraf : fs3.rmdir.bind(fs3);
      const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;
      const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);
      const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);
      if (!opts.keep)
        _removeObjects.unshift(removeCallbackSync);
      return sync ? removeCallbackSync : removeCallback;
    }
    function _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {
      let called = false;
      return function _cleanupCallback(next) {
        if (!called) {
          const toRemove = cleanupCallbackSync || _cleanupCallback;
          const index = _removeObjects.indexOf(toRemove);
          if (index >= 0)
            _removeObjects.splice(index, 1);
          called = true;
          if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {
            return removeFunction(fileOrDirName);
          } else {
            return removeFunction(fileOrDirName, next || function() {
            });
          }
        }
      };
    }
    function _garbageCollector() {
      if (!_gracefulCleanup)
        return;
      while (_removeObjects.length) {
        try {
          _removeObjects[0]();
        } catch (e) {
        }
      }
    }
    function _randomChars(howMany) {
      let value = [], rnd = null;
      try {
        rnd = crypto.randomBytes(howMany);
      } catch (e) {
        rnd = crypto.pseudoRandomBytes(howMany);
      }
      for (var i = 0; i < howMany; i++) {
        value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);
      }
      return value.join("");
    }
    function _isBlank(s) {
      return s === null || _isUndefined(s) || !s.trim();
    }
    function _isUndefined(obj) {
      return typeof obj === "undefined";
    }
    function _parseArguments(options, callback) {
      if (typeof options === "function") {
        return [{}, options];
      }
      if (_isUndefined(options)) {
        return [{}, callback];
      }
      const actualOptions = {};
      for (const key of Object.getOwnPropertyNames(options)) {
        actualOptions[key] = options[key];
      }
      return [actualOptions, callback];
    }
    function _generateTmpName(opts) {
      const tmpDir = opts.tmpdir;
      if (!_isUndefined(opts.name))
        return path.join(tmpDir, opts.dir, opts.name);
      if (!_isUndefined(opts.template))
        return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));
      const name = [
        opts.prefix ? opts.prefix : "tmp",
        "-",
        process.pid,
        "-",
        _randomChars(12),
        opts.postfix ? "-" + opts.postfix : ""
      ].join("");
      return path.join(tmpDir, opts.dir, name);
    }
    function _assertAndSanitizeOptions(options) {
      options.tmpdir = _getTmpDir(options);
      const tmpDir = options.tmpdir;
      if (!_isUndefined(options.name))
        _assertIsRelative(options.name, "name", tmpDir);
      if (!_isUndefined(options.dir))
        _assertIsRelative(options.dir, "dir", tmpDir);
      if (!_isUndefined(options.template)) {
        _assertIsRelative(options.template, "template", tmpDir);
        if (!options.template.match(TEMPLATE_PATTERN))
          throw new Error(`Invalid template, found "${options.template}".`);
      }
      if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0)
        throw new Error(`Invalid tries, found "${options.tries}".`);
      options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;
      options.keep = !!options.keep;
      options.detachDescriptor = !!options.detachDescriptor;
      options.discardDescriptor = !!options.discardDescriptor;
      options.unsafeCleanup = !!options.unsafeCleanup;
      options.dir = _isUndefined(options.dir) ? "" : path.relative(tmpDir, _resolvePath(options.dir, tmpDir));
      options.template = _isUndefined(options.template) ? void 0 : path.relative(tmpDir, _resolvePath(options.template, tmpDir));
      options.template = _isBlank(options.template) ? void 0 : path.relative(options.dir, options.template);
      options.name = _isUndefined(options.name) ? void 0 : _sanitizeName(options.name);
      options.prefix = _isUndefined(options.prefix) ? "" : options.prefix;
      options.postfix = _isUndefined(options.postfix) ? "" : options.postfix;
    }
    function _resolvePath(name, tmpDir) {
      const sanitizedName = _sanitizeName(name);
      if (sanitizedName.startsWith(tmpDir)) {
        return path.resolve(sanitizedName);
      } else {
        return path.resolve(path.join(tmpDir, sanitizedName));
      }
    }
    function _sanitizeName(name) {
      if (_isBlank(name)) {
        return name;
      }
      return name.replace(/["']/g, "");
    }
    function _assertIsRelative(name, option, tmpDir) {
      if (option === "name") {
        if (path.isAbsolute(name))
          throw new Error(`${option} option must not contain an absolute path, found "${name}".`);
        let basename = path.basename(name);
        if (basename === ".." || basename === "." || basename !== name)
          throw new Error(`${option} option must not contain a path, found "${name}".`);
      } else {
        if (path.isAbsolute(name) && !name.startsWith(tmpDir)) {
          throw new Error(`${option} option must be relative to "${tmpDir}", found "${name}".`);
        }
        let resolvedPath = _resolvePath(name, tmpDir);
        if (!resolvedPath.startsWith(tmpDir))
          throw new Error(`${option} option must be relative to "${tmpDir}", found "${resolvedPath}".`);
      }
    }
    function _isEBADF(error2) {
      return _isExpectedError(error2, -EBADF, "EBADF");
    }
    function _isENOENT(error2) {
      return _isExpectedError(error2, -ENOENT, "ENOENT");
    }
    function _isExpectedError(error2, errno, code) {
      return IS_WIN32 ? error2.code === code : error2.code === code && error2.errno === errno;
    }
    function setGracefulCleanup() {
      _gracefulCleanup = true;
    }
    function _getTmpDir(options) {
      return path.resolve(_sanitizeName(options && options.tmpdir || os.tmpdir()));
    }
    process.addListener(EXIT, _garbageCollector);
    Object.defineProperty(module2.exports, "tmpdir", {
      enumerable: true,
      configurable: false,
      get: function() {
        return _getTmpDir();
      }
    });
    module2.exports.dir = dir;
    module2.exports.dirSync = dirSync;
    module2.exports.file = file;
    module2.exports.fileSync = fileSync;
    module2.exports.tmpName = tmpName;
    module2.exports.tmpNameSync = tmpNameSync;
    module2.exports.setGracefulCleanup = setGracefulCleanup;
  }
});

// src/admin/classic/index.ts
var classic_exports = {};
__export(classic_exports, {
  Attributes: () => Attributes2,
  Batch: () => Batch,
  Classic: () => Classic,
  ClassicListenersCollector: () => ClassicListenersCollector,
  ClassicLoader: () => ClassicLoader,
  Context: () => Context,
  EventContext: () => EventContext,
  ExportFormat: () => ExportFormat,
  Game: () => Game,
  Globals: () => Globals2,
  ListenersCollector: () => ListenersCollector,
  ListenersCollectorProxy: () => ListenersCollectorProxy,
  Lobby: () => Lobby,
  Player: () => Player,
  PlayerGame: () => PlayerGame,
  PlayerRound: () => PlayerRound,
  PlayerStage: () => PlayerStage,
  Round: () => Round,
  Scope: () => Scope2,
  Scopes: () => Scopes2,
  SharedGlobals: () => Globals,
  Stage: () => Stage,
  TajribaAdminAccess: () => TajribaAdminAccess,
  TajribaEvent: () => TajribaEvent,
  classicKinds: () => classicKinds,
  evt: () => evt,
  runExport: () => runExport,
  withTajriba: () => withTajriba
});
module.exports = __toCommonJS(classic_exports);

// src/shared/globals.ts
var import_rxjs = require("rxjs");
var Globals = class {
  constructor(globals) {
    this.attrs = /* @__PURE__ */ new Map();
    this.updates = /* @__PURE__ */ new Map();
    this.self = new import_rxjs.BehaviorSubject(void 0);
    globals.subscribe({
      next: ({ attribute, done }) => {
        if (attribute) {
          let val = void 0;
          if (attribute.val) {
            val = JSON.parse(attribute.val);
          }
          this.updates.set(attribute.key, val);
        }
        if (done) {
          for (const [key, val] of this.updates) {
            this.obs(key).next(val);
          }
          this.updates.clear();
          if (this.self) {
            this.self.next(this);
          }
        }
      }
    });
  }
  get(key) {
    const o = this.attrs.get(key);
    if (o) {
      return o.getValue();
    }
    return void 0;
  }
  obs(key) {
    let o = this.attrs.get(key);
    if (!o) {
      o = new import_rxjs.BehaviorSubject(void 0);
      this.attrs.set(key, o);
    }
    return o;
  }
};

// src/admin/attributes.ts
var import_rxjs3 = require("rxjs");

// src/shared/attributes.ts
var import_rxjs2 = require("rxjs");

// src/utils/console.ts
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
var logsMock;
var colorHex = {
  [1 /* Bold */]: "font-weight: bold",
  [30 /* Black */]: "color: #000000",
  [31 /* Red */]: "color: #cc0000",
  [32 /* Green */]: "color: #4e9a06",
  [33 /* Yellow */]: "color: #c4a000",
  [34 /* Blue */]: "color: #729fcf",
  [35 /* Magenta */]: "color: #75507b",
  [36 /* Cyan */]: "color: #06989a",
  [37 /* White */]: "color: #d3d7cf",
  [90 /* DarkGray */]: "color: #555753"
};
var levels = {
  trace: 0,
  debug: 1,
  log: 2,
  info: 2,
  warn: 3,
  error: 4
};
var reversLevels = {};
for (const key in levels) {
  reversLevels[levels[key]] = key;
}
var currentLevel = 2;
function formatConsoleDate(date, level) {
  var hour = date.getHours();
  var minutes = date.getMinutes();
  var seconds = date.getSeconds();
  var milliseconds = date.getMilliseconds();
  const str = (hour < 10 ? "0" + hour : hour) + ":" + (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds) + "." + ("00" + milliseconds).slice(-3);
  if (isBrowser) {
    const ts = colorize(str, 90 /* DarkGray */).concat(level);
    return [ts[0] + " " + level[0], ts[1], level[1]];
  }
  return colorize(str, 90 /* DarkGray */).concat(level);
}
var createLogger = (lvl, level) => {
  return (...args) => {
    if (lvl < currentLevel) {
      return;
    }
    if (logsMock) {
      logsMock.log({ level: reversLevels[lvl], args });
      return;
    }
    if (args.length === 1) {
      switch (typeof args[0]) {
        case "string":
          for (const line of args[0].split("\n")) {
            console.log(...formatConsoleDate(/* @__PURE__ */ new Date(), level).concat(line));
          }
          return;
        case "object":
          if (args[0] instanceof Error) {
            const error2 = args[0];
            const prettyErr = error2.name + ": " + error2.message.replace(new RegExp(`^${error2.name}[: ]*`), "") + "\n" + (error2.stack || "").split("\n").map((line) => line.trim()).map((line) => {
              if (line.startsWith(error2.name + ": " + error2.message))
                return null;
              if (line.startsWith("at")) {
                return "  " + line;
              }
              return line;
            }).filter(Boolean).join("\n");
            for (const line of prettyErr.split("\n")) {
              console.log(...formatConsoleDate(/* @__PURE__ */ new Date(), level).concat(line));
            }
            return;
          }
      }
    }
    console.log(...formatConsoleDate(/* @__PURE__ */ new Date(), level).concat(args));
  };
};
function colorize(s, ...cc) {
  if (isBrowser) {
    const attr = [];
    for (const c of cc) {
      attr.push(colorHex[c]);
    }
    return [`%c${s}`, attr.join("; ")];
  }
  let out = "";
  for (const c of cc) {
    out += `\x1B[${c}m`;
  }
  out += `${s}\x1B[0m`;
  return [out];
}
var trace = createLogger(0, colorize("TRC", 35 /* Magenta */));
var debug = createLogger(1, colorize("DBG", 33 /* Yellow */));
var log = createLogger(2, colorize("LOG", 33 /* Yellow */));
var info = createLogger(2, colorize("INF", 32 /* Green */));
var warn = createLogger(3, colorize("WRN", 36 /* Cyan */));
var error = createLogger(4, colorize("ERR", 31 /* Red */, 1 /* Bold */));

// src/shared/attributes.ts
var Attributes = class {
  constructor(attributesObs, donesObs, setAttributes) {
    this.setAttributes = setAttributes;
    this.attrs = /* @__PURE__ */ new Map();
    this.updates = /* @__PURE__ */ new Map();
    attributesObs.subscribe({
      next: ({ attribute, removed }) => {
        this.update(attribute, removed);
      }
    });
    donesObs.subscribe({
      next: (scopeIDs) => {
        this.next(scopeIDs);
      }
    });
  }
  attribute(scopeID, key) {
    let scopeMap = this.attrs.get(scopeID);
    if (!scopeMap) {
      scopeMap = /* @__PURE__ */ new Map();
      this.attrs.set(scopeID, scopeMap);
    }
    let attr = scopeMap.get(key);
    if (!attr) {
      attr = new Attribute(this.setAttributes, scopeID, key);
      scopeMap.set(key, attr);
    }
    return attr;
  }
  attributes(scopeID) {
    let scopeMap = this.attrs.get(scopeID);
    if (!scopeMap) {
      scopeMap = /* @__PURE__ */ new Map();
      this.attrs.set(scopeID, scopeMap);
    }
    return Array.from(scopeMap.values());
  }
  attributePeek(scopeID, key) {
    let scopeUpdateMap = this.updates.get(scopeID);
    if (scopeUpdateMap) {
      const updated = scopeUpdateMap.get(key);
      if (updated) {
        if (typeof updated === "boolean") {
          return;
        } else {
          if (!updated.val) {
            return;
          } else {
            const attr2 = new Attribute(this.setAttributes, scopeID, key);
            attr2._update(updated);
            return attr2;
          }
        }
      }
    }
    let scopeMap = this.attrs.get(scopeID);
    if (!scopeMap) {
      return;
    }
    let attr = scopeMap.get(key);
    if (!attr) {
      return;
    }
    if (attr.value === void 0) {
      return;
    }
    return attr;
  }
  nextAttributeValue(scopeID, key) {
    const attr = this.attributePeek(scopeID, key);
    if (!attr) {
      return;
    }
    return attr.value;
  }
  update(attr, removed) {
    let nodeID = attr.nodeID;
    if (!nodeID) {
      if (!attr.node?.id) {
        error(`new attribute without node ID`);
        return;
      }
      nodeID = attr.node.id;
    }
    let scopeMap = this.updates.get(nodeID);
    if (!scopeMap) {
      scopeMap = /* @__PURE__ */ new Map();
      this.updates.set(nodeID, scopeMap);
    }
    if (removed) {
      scopeMap.set(attr.key, true);
    } else {
      let key = attr.key;
      if (attr.index !== void 0 && attr.index !== null) {
        key = `${key}[${attr.index}]`;
      }
      scopeMap.set(key, attr);
    }
  }
  scopeWasUpdated(scopeID) {
    if (!scopeID) {
      return false;
    }
    return this.updates.has(scopeID);
  }
  next(scopeIDs) {
    for (const [scopeID, attrs2] of this.updates) {
      if (!scopeIDs.includes(scopeID)) {
        continue;
      }
      let scopeMap = this.attrs.get(scopeID);
      if (!scopeMap) {
        scopeMap = /* @__PURE__ */ new Map();
        this.attrs.set(scopeID, scopeMap);
      }
      for (const [key, attrOrDel] of attrs2) {
        if (typeof attrOrDel === "boolean") {
          let attr = scopeMap.get(key);
          if (attr) {
            attr._update(void 0);
          }
        } else {
          let attr = scopeMap.get(attrOrDel.key);
          if (!attr) {
            attr = new Attribute(this.setAttributes, scopeID, attrOrDel.key);
            scopeMap.set(attrOrDel.key, attr);
          }
          attr._update(attrOrDel);
        }
      }
    }
    for (const scopeID of scopeIDs) {
      this.updates.delete(scopeID);
    }
  }
};
var Attribute = class {
  constructor(setAttributes, scopeID, key) {
    this.setAttributes = setAttributes;
    this.scopeID = scopeID;
    this.key = key;
    this.val = new import_rxjs2.BehaviorSubject(void 0);
  }
  get id() {
    return this.attr?.id;
  }
  get createdAt() {
    return this.attr ? new Date(this.attr.createdAt) : null;
  }
  get obs() {
    return this.val;
  }
  get value() {
    return this.val.getValue();
  }
  get nodeID() {
    return this.attr?.nodeID || this.attr?.node?.id;
  }
  // items returns the attribute changes for the current attribute, if it is a
  // vector. Otherwise it returns null;
  get items() {
    if (!this.attrs) {
      return null;
    }
    return this.attrs;
  }
  set(value, ao) {
    const attrProps = this._prepSet(value, ao);
    this.setAttributes([attrProps]);
    trace(`SET ${this.key} = ${value} (${this.scopeID})`);
  }
  _prepSet(value, ao, item) {
    if (!item && ao?.index !== void 0) {
      const index = ao.index;
      if (!this.attrs) {
        this.attrs = [];
      }
      if (index + 1 > (this.attrs?.length || 0)) {
        this.attrs.length = index + 1;
      }
      if (!this.attrs[index]) {
        this.attrs[index] = new Attribute(
          this.setAttributes,
          this.scopeID,
          this.key
        );
      }
      this.attrs[index]._prepSet(value, ao, true);
      const v = this._recalcVectorVal();
      this.val.next(v);
    } else {
      this.val.next(value);
    }
    const attrProps = {
      key: this.key,
      nodeID: this.scopeID,
      val: JSON.stringify(value)
    };
    if (ao) {
      attrProps.private = ao.private;
      attrProps.protected = ao.protected;
      attrProps.immutable = ao.immutable;
      attrProps.append = ao.append;
      attrProps.index = ao.index;
    }
    return attrProps;
  }
  _recalcVectorVal() {
    return this.attrs.map(
      (a) => !a || a.val == void 0 ? null : a.value || null
    );
  }
  // internal only
  _update(attr, item) {
    if (attr && this.attr && this.attr.id === attr.id) {
      return;
    }
    if (attr && attr.vector && !item) {
      if (attr.index === void 0) {
        error(`vector attribute missing index`);
        return;
      }
      if (this.attrs == void 0) {
        this.attrs = [];
      }
      while (this.attrs.length < attr.index + 1) {
        const newAttr2 = new Attribute(
          this.setAttributes,
          this.scopeID,
          this.key
        );
        this.attrs.push(newAttr2);
      }
      const newAttr = new Attribute(this.setAttributes, this.scopeID, this.key);
      newAttr._update(attr, true);
      this.attrs[attr.index] = newAttr;
      const value2 = this._recalcVectorVal();
      this.val.next(value2);
      return;
    }
    this.attr = attr;
    let value = void 0;
    if (this.attr?.val) {
      value = JSON.parse(this.attr.val);
    }
    this.val.next(value);
  }
};

// src/admin/attributes.ts
var Attributes2 = class extends Attributes {
  constructor() {
    super(...arguments);
    this.attrsByKind = /* @__PURE__ */ new Map();
    this.attribSubs = /* @__PURE__ */ new Map();
  }
  subscribeAttribute(kind, key) {
    if (!this.attribSubs.has(kind)) {
      this.attribSubs.set(kind, /* @__PURE__ */ new Map());
    }
    const keyMap = this.attribSubs.get(kind);
    let sub = keyMap.get(key);
    if (!sub) {
      sub = new import_rxjs3.ReplaySubject();
      keyMap.set(key, sub);
      const attrByScopeID = this.attrsByKind.get(kind);
      setTimeout(() => {
        if (!attrByScopeID) {
          sub.next({ done: true });
          return;
        }
        let attrs2 = [];
        for (const [_, attrByKey] of attrByScopeID?.entries()) {
          for (const [_2, attr] of attrByKey) {
            if (attr.key === key) {
              attrs2.push(attr);
            }
          }
        }
        if (attrs2.length > 0) {
          let count = 0;
          for (const attr of attrs2) {
            count++;
            sub.next({ attribute: attr, done: count == attrs2.length });
          }
        } else {
          sub.next({ done: true });
        }
      }, 0);
    }
    return sub;
  }
  next(scopeIDs) {
    const byKind = /* @__PURE__ */ new Map();
    for (const [scopeID, attrs2] of this.updates) {
      if (!scopeIDs.includes(scopeID)) {
        continue;
      }
      for (const [_, attr] of attrs2) {
        if (typeof attr === "boolean") {
          continue;
        }
        const kind = attr.node?.kind;
        if (kind) {
          let kindAttrs = byKind.get(kind);
          if (!kindAttrs) {
            kindAttrs = [];
            byKind.set(kind, kindAttrs);
          }
          kindAttrs.push(attr);
        }
      }
    }
    const updates = [];
    for (const [kind, attrs2] of byKind) {
      for (const attr of attrs2) {
        if (!attr.nodeID && !attr.node?.id) {
          warn(`found attribute change without node ID`);
          continue;
        }
        if (!scopeIDs.includes(attr.nodeID || attr.node.id)) {
          continue;
        }
        updates.push([kind, attr.key, attr]);
      }
    }
    super.next(scopeIDs);
    for (const [kind, key, attrChange] of updates) {
      const nodeID = attrChange.nodeID || attrChange.node.id;
      if (!scopeIDs.includes(nodeID)) {
        continue;
      }
      const attr = this.attrs.get(nodeID).get(key);
      const sub = this.attribSubs.get(kind)?.get(key);
      if (sub) {
        sub.next({ attribute: attr, done: true });
      } else {
        let kAttrs = this.attrsByKind.get(kind);
        if (!kAttrs) {
          kAttrs = /* @__PURE__ */ new Map();
          this.attrsByKind.set(kind, kAttrs);
        }
        let kkAttrs = kAttrs.get(nodeID);
        if (!kkAttrs) {
          kkAttrs = /* @__PURE__ */ new Map();
          kAttrs.set(nodeID, kkAttrs);
        }
        kkAttrs.set(key, attr);
      }
    }
  }
};

// src/admin/context.ts
var import_rxjs11 = require("rxjs");

// src/shared/tajriba_connection.ts
var import_tajriba = require("@empirica/tajriba");

// src/utils/object.ts
var import_rxjs4 = require("rxjs");
function bsu(init = void 0) {
  return new import_rxjs4.BehaviorSubject(init);
}
function deepEqual(obj1, obj2) {
  if (obj1 === obj2)
    return true;
  if (isPrimitive(obj1) && isPrimitive(obj2))
    return obj1 === obj2;
  if (Object.keys(obj1).length !== Object.keys(obj2).length)
    return false;
  for (let key in obj1) {
    if (!(key in obj2))
      return false;
    if (!deepEqual(obj1[key], obj2[key]))
      return false;
  }
  return true;
}
function isPrimitive(obj) {
  return obj !== Object(obj);
}

// src/shared/tajriba_connection.ts
var ErrNotConnected = new Error("not connected");

// src/admin/connection.ts
var import_rxjs6 = require("rxjs");

// src/admin/observables.ts
var import_rxjs5 = require("rxjs");

// src/admin/runloop.ts
var import_rxjs9 = require("rxjs");

// src/admin/events.ts
var TajribaEvent = /* @__PURE__ */ ((TajribaEvent2) => {
  TajribaEvent2["TransitionAdd"] = "TRANSITION_ADD";
  TajribaEvent2["ParticipantConnect"] = "PARTICIPANT_CONNECT";
  TajribaEvent2["ParticipantDisconnect"] = "PARTICIPANT_DISCONNECT";
  return TajribaEvent2;
})(TajribaEvent || {});
var placementString = /* @__PURE__ */ new Map();
placementString.set(0 /* Before */, "before");
placementString.set(1 /* None */, "on");
placementString.set(2 /* After */, "after");
function PlacementString(placement) {
  return placementString.get(placement);
}
function unique(kind, placement, callback) {
  return async (ctx, props) => {
    const attr = props.attribute;
    const scope = props[kind];
    if (!attr.id || scope.get(`ran-${PlacementString(placement)}-${attr.id}`)) {
      return;
    }
    await callback(ctx, props);
    scope.set(`ran-${PlacementString(placement)}-${attr.id}`, true);
  };
}
var ListenersCollector = class {
  constructor() {
    /** @internal */
    this.starts = [];
    /** @internal */
    this.readys = [];
    /** @internal */
    this.tajEvents = [];
    /** @internal */
    this.kindListeners = [];
    /** @internal */
    this.attributeListeners = [];
  }
  get unique() {
    return new ListenersCollectorProxy(this);
  }
  on(kindOrEvent, keyOrNodeIDOrEventOrCallback, callback) {
    this.registerListerner(
      1 /* None */,
      kindOrEvent,
      keyOrNodeIDOrEventOrCallback,
      callback
    );
  }
  before(kindOrEvent, keyOrNodeIDOrEventOrCallback, callback, uniqueCall) {
    this.registerListerner(
      0 /* Before */,
      kindOrEvent,
      keyOrNodeIDOrEventOrCallback,
      callback,
      uniqueCall
    );
  }
  after(kindOrEvent, keyOrNodeIDOrEventOrCallback, callback, uniqueCall) {
    this.registerListerner(
      2 /* After */,
      kindOrEvent,
      keyOrNodeIDOrEventOrCallback,
      callback,
      uniqueCall
    );
  }
  registerListerner(placement, kindOrEvent, keyOrNodeIDOrEventOrCallback, callback, uniqueCall = false) {
    if (kindOrEvent === "start") {
      if (callback) {
        throw new Error("start event only accepts 2 arguments");
      }
      if (typeof keyOrNodeIDOrEventOrCallback !== "function") {
        throw new Error("second argument expected to be a callback");
      }
      this.starts.push({
        placement,
        callback: keyOrNodeIDOrEventOrCallback
      });
      return;
    }
    if (kindOrEvent === "ready") {
      if (callback) {
        throw new Error("ready event only accepts 2 arguments");
      }
      if (typeof keyOrNodeIDOrEventOrCallback !== "function") {
        throw new Error("second argument expected to be a callback");
      }
      this.readys.push({
        placement,
        callback: keyOrNodeIDOrEventOrCallback
      });
      return;
    }
    if (Object.values(TajribaEvent).includes(kindOrEvent)) {
      if (typeof keyOrNodeIDOrEventOrCallback !== "function") {
        throw new Error("second argument expected to be a callback");
      }
      this.tajEvents.push({
        placement,
        event: kindOrEvent,
        callback: keyOrNodeIDOrEventOrCallback
      });
      return;
    }
    if (typeof keyOrNodeIDOrEventOrCallback === "function") {
      this.kindListeners.push({
        placement,
        kind: kindOrEvent,
        callback: keyOrNodeIDOrEventOrCallback
      });
    } else {
      if (typeof keyOrNodeIDOrEventOrCallback !== "string") {
        throw new Error("second argument expected to be an attribute key");
      }
      if (typeof callback !== "function") {
        throw new Error("third argument expected to be a callback");
      }
      if (uniqueCall) {
        callback = unique(kindOrEvent, placement, callback);
      }
      this.attributeListeners.push({
        placement,
        kind: kindOrEvent,
        key: keyOrNodeIDOrEventOrCallback,
        callback
      });
    }
  }
};
var ListenersCollectorProxy = class extends ListenersCollector {
  constructor(coll) {
    super();
    this.coll = coll;
  }
  registerListerner(placement, kindOrEvent, keyOrNodeIDOrEventOrCallback, callback) {
    if (kindOrEvent === "start" || kindOrEvent === "ready" || Object.values(TajribaEvent).includes(kindOrEvent) || typeof keyOrNodeIDOrEventOrCallback === "function") {
      throw new Error("only attribute listeners can be unique");
    }
    super.registerListerner(
      placement,
      kindOrEvent,
      keyOrNodeIDOrEventOrCallback,
      callback,
      true
    );
    while (true) {
      const listener = this.attributeListeners.pop();
      if (!listener) {
        break;
      }
      this.coll.attributeListeners.push(listener);
    }
  }
};
var EventContext = class {
  constructor(subs, taj, scopes) {
    this.subs = subs;
    this.taj = taj;
    this.scopes = scopes;
  }
  scopesByKind(kind) {
    return this.scopes.byKind(kind);
  }
  scopesByKindID(kind, id) {
    return this.scopes.byKind(kind).get(id);
  }
  scopesByKindMatching(kind, key, val) {
    const scopes = Array.from(this.scopes.byKind(kind).values());
    return scopes.filter((s) => s.get(key) === val);
  }
  scopeSub(...inputs) {
    for (const input of inputs) {
      this.subs.scopeSub(input);
    }
  }
  participantsSub() {
    this.subs.participantsSub();
  }
  transitionsSub(stepID) {
    this.subs.transitionsSub(stepID);
  }
  // c8 ignore: the TajribaAdminAccess proxy functions are tested elswhere
  /* c8 ignore next 3 */
  addScopes(input) {
    return this.taj.addScopes(input);
  }
  /* c8 ignore next 3 */
  addGroups(input) {
    return this.taj.addGroups(input);
  }
  /* c8 ignore next 3 */
  addLinks(input) {
    return this.taj.addLinks(input);
  }
  /* c8 ignore next 3 */
  addSteps(input) {
    return this.taj.addSteps(input);
  }
  /* c8 ignore next 3 */
  addTransitions(input) {
    return this.taj.addTransitions(input);
  }
  addFinalizer(cb) {
    this.taj.addFinalizer(cb);
  }
  /* c8 ignore next 3 */
  get globals() {
    return this.taj.globals;
  }
};

// src/admin/promises.ts
function promiseHandle() {
  let ret = {};
  ret.promise = new Promise((r) => {
    ret.result = r;
  });
  return ret;
}

// src/admin/globals.ts
var Globals2 = class extends Globals {
  constructor(globals, globalScopeID, setAttributes) {
    super(globals);
    this.globalScopeID = globalScopeID;
    this.setAttributes = setAttributes;
  }
  set(key, value, ao) {
    let attr = this.attrs.get(key);
    if (!attr) {
      attr = bsu();
      this.attrs.set(key, attr);
    }
    attr.next(value);
    const attrProps = {
      key,
      nodeID: this.globalScopeID,
      val: JSON.stringify(value)
    };
    if (ao) {
      attrProps.private = ao.private;
      attrProps.protected = ao.protected;
      attrProps.immutable = ao.immutable;
      attrProps.append = ao.append;
      attrProps.index = ao.index;
    }
    this.setAttributes([attrProps]);
  }
};

// src/admin/participants.ts
var import_tajriba2 = require("@empirica/tajriba");

// src/admin/scopes.ts
var import_rxjs8 = require("rxjs");

// src/shared/scopes.ts
var import_rxjs7 = require("rxjs");
var Scopes = class {
  constructor(scopesObs, donesObs, ctx, kinds, attributes) {
    this.ctx = ctx;
    this.kinds = kinds;
    this.attributes = attributes;
    this.scopes = /* @__PURE__ */ new Map();
    // newScopes is used to track scopes that have appeared for the first time.
    this.newScopes = /* @__PURE__ */ new Map();
    this.scopesByKind = /* @__PURE__ */ new Map();
    this.kindUpdated = /* @__PURE__ */ new Set();
    scopesObs.subscribe({
      next: ({ scope, removed }) => {
        this.update(scope, removed);
      }
    });
    donesObs.subscribe({
      next: (scopeIDs) => {
        this.next(scopeIDs);
      }
    });
  }
  scope(id) {
    return this.scopes.get(id)?.getValue();
  }
  scopeObs(id) {
    return this.scopes.get(id);
  }
  byKind(kind) {
    let map = this.scopesByKind.get(kind);
    if (!map) {
      map = /* @__PURE__ */ new Map();
      this.scopesByKind.set(kind, map);
    }
    return map;
  }
  kindWasUpdated(kind) {
    return this.kindUpdated.has(kind);
  }
  next(scopeIDs) {
    this.kindUpdated.clear();
    for (const [_, scopeSubject] of this.scopes) {
      const scope = scopeSubject.getValue();
      if ((scope._updated || this.attributes.scopeWasUpdated(scope.id)) && scopeIDs.includes(scope.id)) {
        scope._updated = false;
        scopeSubject.next(scope);
      }
    }
  }
  update(scope, removed) {
    const existing = this.scopes.get(scope.id)?.getValue();
    if (removed) {
      if (!existing) {
        warn("scopes: missing scope on removal", scope.id, scope.kind);
        return;
      }
      existing._deleted = true;
      existing._updated = true;
      this.scopes.delete(scope.id);
      if (!scope.kind) {
        warn("scopes: scope missing kind on scope on removal");
        return;
      }
      const kind2 = scope.kind;
      this.scopesByKind.get(kind2).delete(scope.id);
      this.kindUpdated.add(kind2);
      return;
    }
    if (existing) {
      existing._deleted = false;
      return;
    }
    if (!scope.kind) {
      warn("scopes: scope missing kind on scope");
      return;
    }
    const kind = scope.kind;
    const scopeClass = this.kinds[kind];
    if (!scopeClass) {
      warn(`scopes: unknown scope kind: ${scope.kind}`);
      return;
    }
    const obj = this.create(scopeClass, scope);
    const subj = new import_rxjs7.BehaviorSubject(obj);
    this.scopes.set(scope.id, subj);
    this.newScopes.set(scope.id, true);
    let skm = this.scopesByKind.get(kind);
    if (!skm) {
      skm = /* @__PURE__ */ new Map();
      this.scopesByKind.set(kind, skm);
    }
    skm.set(scope.id, obj);
    obj._updated = true;
    this.kindUpdated.add(kind);
  }
  create(scopeClass, scope) {
    return new scopeClass(this.ctx, scope, this.attributes);
  }
};
var Scope = class {
  constructor(ctx, scope, attributes) {
    this.ctx = ctx;
    this.scope = scope;
    this.attributes = attributes;
    /**
     * @internal
     */
    this._deleted = false;
    /**
     * @internal
     */
    this._updated = false;
  }
  get id() {
    return this.scope.id;
  }
  /**
   * @internal
   */
  get kind() {
    return this.scope.kind;
  }
  get(key) {
    return this.attributes.attribute(this.scope.id, key).value;
  }
  getAttribute(key) {
    return this.attributes.attribute(this.scope.id, key);
  }
  obs(key) {
    return this.attributes.attribute(this.scope.id, key).obs;
  }
  set(keyOrAttributes, value, ao) {
    if (typeof keyOrAttributes === "string") {
      if (value === void 0) {
        value = null;
      }
      return this.attributes.attribute(this.scope.id, keyOrAttributes).set(value, ao);
    }
    const nextProps = [];
    for (const attr of keyOrAttributes) {
      nextProps.push(
        this.attributes.attribute(this.scope.id, attr.key)._prepSet(attr.value, attr.ao)
      );
    }
    this.attributes.setAttributes(nextProps);
  }
  append(key, value, ao) {
    if (!ao) {
      ao = {};
    }
    ao.append = true;
    return this.attributes.attribute(this.scope.id, key).set(value, ao);
  }
  inspect() {
    const attrs2 = this.attributes.attributes(this.scope.id);
    const out = {};
    for (const attr of attrs2) {
      out[attr.key] = attr.value;
    }
    return out;
  }
  /**
   * @internal
   */
  hasUpdated() {
    return this._updated || this.attributes.scopeWasUpdated(this.id);
  }
};

// src/admin/scopes.ts
var Scopes2 = class extends Scopes {
  constructor(scopesObs, donesObs, ctx, kinds, attributes, taj) {
    super(scopesObs, donesObs, ctx, kinds, attributes);
    this.taj = taj;
    this.kindSubs = /* @__PURE__ */ new Map();
  }
  /** @internal */
  subscribeKind(kind) {
    let sub = this.kindSubs.get(kind);
    if (!sub) {
      sub = new import_rxjs8.ReplaySubject();
      this.kindSubs.set(kind, sub);
      const scopes = this.byKind(kind);
      setTimeout(() => {
        if (scopes.size === 0) {
          sub.next({ done: true });
          return;
        }
        let count = 0;
        for (const [_, scope] of scopes) {
          count++;
          sub.next({ scope, done: scopes.size === count });
        }
      }, 0);
    }
    return sub;
  }
  next(scopeIDs) {
    for (const [_, scopeReplaySubject] of this.scopes) {
      const scope = scopeReplaySubject.getValue();
      if (this.newScopes.get(scope.id) && scopeIDs.includes(scope.id)) {
        const kindSub = this.kindSubs.get(scope.kind);
        if (kindSub) {
          kindSub.next({ scope, done: true });
        }
        this.newScopes.set(scope.id, false);
      }
    }
    super.next(scopeIDs);
  }
  create(scopeClass, scope) {
    return new scopeClass(this.ctx, scope, this, this.attributes);
  }
};
var Scope2 = class extends Scope {
  constructor(ctx, scope, scopes, attributes) {
    super(ctx, scope, attributes);
    this.scopes = scopes;
    this.taj = scopes.taj;
  }
  scopeByID(id) {
    return this.scopes.scope(id);
  }
  scopeByKey(key) {
    const id = this.get(key);
    if (!id || typeof id !== "string") {
      return;
    }
    return this.scopes.scope(id);
  }
  scopesByKind(kind) {
    return this.scopes.byKind(kind);
  }
  scopesByKindID(kind, id) {
    return this.scopes.byKind(kind).get(id);
  }
  scopesByKindMatching(kind, key, val) {
    const scopes = Array.from(this.scopes.byKind(kind).values());
    return scopes.filter((s) => s.get(key) === val);
  }
  addScopes(input) {
    return this.taj.addScopes(input);
  }
  addGroups(input) {
    return this.taj.addGroups(input);
  }
  addLinks(input) {
    return this.taj.addLinks(input);
  }
  addSteps(input) {
    return this.taj.addSteps(input);
  }
  addTransitions(input) {
    return this.taj.addTransitions(input);
  }
  addFinalizer(cb) {
    this.taj.addFinalizer(cb);
  }
  /**
   * @internal
   */
  get globals() {
    return this.taj.globals;
  }
};

// src/admin/transitions.ts
var import_tajriba3 = require("@empirica/tajriba");

// src/admin/token_file.ts
var import_rxjs10 = require("rxjs");

// src/admin/context.ts
var TajribaAdminAccess = class {
  constructor(addFinalizer, addScopes, addGroups, addLinks, addSteps, addTransitions, globals) {
    this.addFinalizer = addFinalizer;
    this.addScopes = addScopes;
    this.addGroups = addGroups;
    this.addLinks = addLinks;
    this.addSteps = addSteps;
    this.addTransitions = addTransitions;
    this.globals = globals;
  }
};

// src/admin/classic/api/connection_test_helper.ts
var import_child_process = require("child_process");
var import_fs = __toESM(require("fs"), 1);
var import_readline = __toESM(require("readline"), 1);
var import_tmp = __toESM(require_tmp(), 1);
var VERBOSE = false;
import_tmp.default.setGracefulCleanup();
var config = (username = "username", password = "password", srtoken = "0123456789123456") => `[tajriba.auth]
srtoken = "` + srtoken + `"

[[tajriba.auth.users]]
name = "Nicolas"
username = "` + username + `"
password = "` + password + `"
`;
function createTajribaConfigFile(config2) {
  const { name } = import_tmp.default.fileSync({ discardDescriptor: true, postfix: ".toml" });
  import_fs.default.writeFileSync(name, config2);
  return name;
}
async function startTajriba(options = {}) {
  let port;
  const logLevel = options.logLevel ?? "trace";
  let configFile = options.configFile ?? createTajribaConfigFile(
    config(options.username, options.password, options.srtoken)
  );
  const args = [
    "tajriba",
    "--config",
    configFile,
    "--log.level",
    logLevel,
    "--log.json",
    "--tajriba.log.level",
    logLevel,
    "--tajriba.log.json",
    "--tajriba.server.addr",
    ":0"
  ];
  if (options.tajFile) {
    args.push("--tajriba.store.file", options.tajFile);
  } else {
    args.push("--tajriba.store.mem");
  }
  const taj = (0, import_child_process.spawn)("empirica", args);
  import_readline.default.createInterface({ input: taj.stdout }).on("line", (data) => {
    console.log(`stdout: ${data}`);
  });
  const portProm = promiseHandle();
  import_readline.default.createInterface({ input: taj.stderr }).on("line", (data) => {
    try {
      const dat = JSON.parse(data);
      if (dat["message"] && dat["message"] === "Started Tajriba server") {
        portProm.result(dat["port"]);
      }
      if (VERBOSE || options.printLogs || dat["level"] && dat["level"] === "error") {
        console.log(`stderr: ${data}`);
      }
    } catch (e) {
      console.error(data.toString());
    }
  });
  taj.on("error", (error2) => {
    console.error(`error: ${error2.message}`);
  });
  taj.on("close", (code) => {
    if (code) {
      console.log(`child process exited with code ${code}`);
    }
  });
  port = await portProm.promise;
  await sleep(200);
  let stopped = false;
  return {
    port,
    get url() {
      return `http://localhost:${port}/query`;
    },
    get username() {
      return options.username || "username";
    },
    get password() {
      return options.password || "password";
    },
    get srtoken() {
      return options.srtoken || "0123456789123456";
    },
    stop: function stopTajriba() {
      if (!stopped) {
        taj.kill("SIGKILL");
        stopped = true;
      }
    }
  };
}
async function withTajriba(fn, options = {}) {
  const srv = await startTajriba(options);
  try {
    await fn(srv);
  } catch (err) {
    console.error(err);
    process.exit(1);
  } finally {
    srv.stop();
  }
}
function sleep(ms) {
  return new Promise((r) => setTimeout(r, ms));
}

// src/admin/classic/classic.ts
var import_tajriba5 = require("@empirica/tajriba");
var import_zod3 = require("zod");

// src/utils/random.ts
function pickRandom(items) {
  const random = Math.floor(Math.random() * items.length);
  return items[random];
}
function shuffle(a) {
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}
function selectRandom(arr, num) {
  return shuffle(arr.slice()).slice(0, num);
}

// src/admin/classic/helpers.ts
function scopeConstructor(input) {
  return [
    input,
    {
      get(key) {
        const attr = input.attributes?.find((a) => a.key === key);
        if (!attr) {
          return;
        }
        return attr.val ? JSON.parse(attr.val) : void 0;
      },
      set: (key, value, ao) => {
        const attr = input.attributes?.find((a) => a.key === key);
        if (attr) {
          attr.val = JSON.stringify(value);
          return;
        }
        const props = {
          key,
          val: JSON.stringify(value),
          ...ao
        };
        if (!input.attributes) {
          input.attributes = [];
        }
        input.attributes.push(props);
      }
    }
  ];
}
function attrs(attrs2) {
  const result = [];
  for (const attr of attrs2) {
    const {
      append,
      immutable,
      index,
      key,
      nodeID,
      private: privat,
      protected: protecte,
      value
    } = attr;
    result.push({
      append,
      immutable,
      index,
      key,
      nodeID,
      private: privat,
      protected: protecte,
      val: JSON.stringify(value)
    });
  }
  return result;
}

// src/admin/classic/models.ts
var import_tajriba4 = require("@empirica/tajriba");
var import_zod = require("zod");
var isString = import_zod.z.string().parse;
var isOptionalNumber = import_zod.z.number().optional().parse;
var endedStatuses = ["ended", "terminated", "failed"];
var reservedKeys = [
  "batchID",
  "gameID",
  "stageID",
  "roundID",
  "start",
  "ended",
  "timerID"
];
var lobbyConfigSchema = import_zod.z.object({
  kind: import_zod.z.union([import_zod.z.literal("shared"), import_zod.z.literal("individual")]),
  duration: import_zod.z.number().min(1),
  strategy: import_zod.z.union([import_zod.z.literal("fail"), import_zod.z.literal("ignore")]),
  extensions: import_zod.z.number().min(1).optional()
});
var indexSortable = (a, b) => a.get("index") - b.get("index");
var Batch = class extends Scope2 {
  get isRunning() {
    return this.get("status") === "running";
  }
  get games() {
    return this.scopesByKindMatching("game", "batchID", this.id);
  }
  addGame(attributes) {
    if (!Array.isArray(attributes)) {
      const newAttr = [];
      for (const key in attributes) {
        newAttr.push({
          key,
          value: attributes[key]
        });
      }
      attributes = newAttr;
    }
    const [scope, accessors] = scopeConstructor({
      kind: "game",
      attributes: attrs([
        ...attributes.filter((a) => !reservedKeys.includes(a.key)),
        {
          key: "batchID",
          value: this.id,
          immutable: true
        },
        {
          key: "start",
          value: false,
          protected: true
        },
        {
          key: "ended",
          value: false,
          protected: true
        }
      ])
    });
    this.addScopes([scope]);
    return accessors;
  }
  end(reason) {
    if (this.hasEnded) {
      return;
    }
    this.set("status", "ended");
    this.set("endedReason", reason);
  }
  get hasEnded() {
    return endedStatuses.includes(this.get("status"));
  }
  get lobbyConfig() {
    return lobbyConfigSchema.parse(this.get("lobbyConfig"));
  }
};
var BatchOwned = class extends Scope2 {
  get batch() {
    return this.scopeByKey("batchID");
  }
};
var Game = class extends BatchOwned {
  get rounds() {
    const rounds = this.scopesByKindMatching("round", "gameID", this.id);
    rounds.sort(indexSortable);
    return rounds;
  }
  get stages() {
    const stages = this.scopesByKindMatching("stage", "gameID", this.id);
    stages.sort(indexSortable);
    return stages;
  }
  get players() {
    return this.scopesByKindMatching("player", "gameID", this.id);
  }
  get currentStage() {
    return this.scopeByKey("stageID");
  }
  get currentRound() {
    return this.currentStage?.round;
  }
  get hasEnded() {
    return endedStatuses.includes(this.get("status"));
  }
  // The game has started, but it might not be running yet, it might still be in
  // the gameStart callbacks.
  // This will always be true once the game has started (even after the game
  // ends).
  get hasStarted() {
    return Boolean(this.get("start"));
  }
  get hasNotStarted() {
    return !this.hasStarted;
  }
  // Game has passed the gameStart callbacks and is currently running. This will
  // be true until the game ends.
  get isRunning() {
    return this.get("status") === "running";
  }
  get lobbyConfig() {
    return this.batch.lobbyConfig;
  }
  // Starts the game if it is not already started.
  start() {
    if (!this.get("start")) {
      this.set("start", true);
    }
  }
  async assignPlayer(player) {
    if (this.hasEnded) {
      throw new Error("cannot assign player to ended Game");
    }
    const previousGameID = player.get("gameID");
    const previousGameTreatment = player.get("treatment");
    const treatment = this.get("treatment");
    if (!treatment) {
      warn(`game without treatment: ${this.id}`);
    }
    player.set("gameID", this.id);
    if (treatment) {
      player.set("treatment", treatment);
    }
    if (previousGameTreatment && JSON.stringify(previousGameTreatment) !== JSON.stringify(treatment)) {
      if (previousGameID) {
        warn(
          `reassigning player from ${previousGameID} to ${this.id} with different treatments`
        );
      } else {
        warn(`reassigning player to ${this.id} with different treatment`);
      }
    }
    if (previousGameID) {
      await this.scopeByID(previousGameID)?.removePlayer(player);
    }
    await this.addPlayer(player);
  }
  // Add player to running game
  async addPlayer(player) {
    if (!this.isRunning) {
      await this.addLinks([
        {
          link: true,
          participantIDs: [player.participantID],
          nodeIDs: [this.id]
        }
      ]);
      return;
    }
    const otherParticipantIDs = [];
    const groupID = isString(this.get("groupID"));
    const newPlayerNodeIDs = [this.id, groupID];
    const otherNodeIDs = [];
    const stage = this.currentStage;
    if (!stage) {
      return;
    }
    const timerID = stage.get("timerID");
    if (timerID) {
      newPlayerNodeIDs.push(timerID);
    }
    newPlayerNodeIDs.push(stage.id);
    const round = stage.round;
    if (!round) {
      return;
    }
    newPlayerNodeIDs.push(round.id);
    const playerGameID = await this.createPlayerGame(player);
    const playerRoundID = await round.createPlayerRound(player);
    const playerStageID = await stage.createPlayerStage(player);
    if (!playerGameID || !playerRoundID || !playerStageID) {
      return;
    }
    newPlayerNodeIDs.push(player.id);
    newPlayerNodeIDs.push(playerGameID);
    newPlayerNodeIDs.push(playerRoundID);
    newPlayerNodeIDs.push(playerStageID);
    otherNodeIDs.push(player.id);
    otherNodeIDs.push(playerGameID);
    otherNodeIDs.push(playerRoundID);
    otherNodeIDs.push(playerStageID);
    for (const plyr of this.players) {
      if (player !== plyr) {
        newPlayerNodeIDs.push(plyr.id);
        newPlayerNodeIDs.push(isString(plyr.get(`playerGameID-${this.id}`)));
        newPlayerNodeIDs.push(isString(plyr.get(`playerRoundID-${round.id}`)));
        newPlayerNodeIDs.push(isString(plyr.get(`playerStageID-${stage.id}`)));
        otherParticipantIDs.push(plyr.participantID);
      }
    }
    await this.addLinks([
      // Add links for new player with games and other players.
      {
        link: true,
        participantIDs: [player.participantID],
        nodeIDs: newPlayerNodeIDs
      },
      // Add links for other players with new player.
      {
        link: true,
        participantIDs: otherParticipantIDs,
        nodeIDs: otherNodeIDs
      }
    ]);
  }
  // Remove player from running game
  async removePlayer(player) {
    if (!this.isRunning) {
      await this.addLinks([
        {
          link: false,
          participantIDs: [player.participantID],
          nodeIDs: [this.id]
        }
      ]);
      return;
    }
    const participantIDs = [player.participantID];
    const otherParticipantIDs = [];
    const groupID = isString(this.get("groupID"));
    const nodeIDs = [this.id, groupID, player.id];
    const otherNodeIDs = [player.id];
    const stage = this.currentStage;
    if (!stage) {
      return;
    }
    const timerID = stage.get("timerID");
    if (timerID) {
      nodeIDs.push(timerID);
    }
    nodeIDs.push(stage.id);
    const round = stage.round;
    if (!round) {
      return;
    }
    const players = [...this.players, player];
    for (const plyr of players) {
      nodeIDs.push(isString(plyr.get(`playerRoundID-${round.id}`)));
      nodeIDs.push(isString(plyr.get(`playerStageID-${stage.id}`)));
      nodeIDs.push(isString(plyr.get(`playerGameID-${this.id}`)));
      if (player.id !== plyr.id) {
        nodeIDs.push(plyr.id);
        otherParticipantIDs.push(plyr.participantID);
      } else {
        otherNodeIDs.push(isString(plyr.get(`playerRoundID-${round.id}`)));
        otherNodeIDs.push(isString(plyr.get(`playerStageID-${stage.id}`)));
        otherNodeIDs.push(isString(plyr.get(`playerGameID-${this.id}`)));
      }
    }
    await this.addLinks([
      { link: false, participantIDs, nodeIDs },
      {
        link: false,
        participantIDs: otherParticipantIDs,
        nodeIDs: otherNodeIDs
      }
    ]);
  }
  addRound(attributes) {
    if (!Array.isArray(attributes)) {
      const newAttr = [];
      for (const key in attributes) {
        newAttr.push({
          key,
          value: attributes[key]
        });
      }
      attributes = newAttr;
    }
    const batchID = this.get("batchID");
    if (!batchID) {
      throw new Error("missing batch ID on game");
    }
    const game = this;
    const gameID = game.id;
    let roundIndex = isOptionalNumber(this._tmpRoundIndex);
    if (roundIndex === void 0) {
      roundIndex = isOptionalNumber(game.get("roundIndex"));
    }
    if (roundIndex === void 0) {
      roundIndex = -1;
    }
    roundIndex += 1;
    this._tmpRoundIndex = roundIndex;
    game.set("roundIndex", this._tmpRoundIndex);
    const [scope, accessors] = scopeConstructor({
      kind: "round",
      attributes: attrs([
        ...attributes.filter((a) => !reservedKeys.includes(a.key)),
        {
          key: "index",
          value: roundIndex,
          immutable: true
        },
        {
          key: "gameID",
          value: gameID,
          immutable: true
        },
        {
          key: "batchID",
          value: batchID,
          immutable: true
        },
        {
          key: "start",
          value: false,
          protected: true
        },
        {
          key: "ended",
          value: false,
          protected: true
        }
      ])
    });
    const roundProm = this.addScopes([scope]);
    const stageAdds = [];
    const addStage = (attributes2) => {
      if (!Array.isArray(attributes2)) {
        const newAttr = [];
        for (const key in attributes2) {
          newAttr.push({
            key,
            value: attributes2[key]
          });
        }
        attributes2 = newAttr;
      }
      const durAttr = attributes2.find((a) => a.key === "duration");
      const res = import_zod.z.number().int().gte(1).safeParse(durAttr?.value);
      if (!res.success) {
        throw new Error(`stage duration invalid: ${res.error}`);
      }
      const [scope2, accessors2] = scopeConstructor({
        kind: "stage",
        attributes: attrs([
          ...attributes2.filter((a) => !reservedKeys.includes(a.key)),
          {
            key: "gameID",
            value: gameID,
            immutable: true
          },
          {
            key: "batchID",
            value: batchID,
            immutable: true
          },
          {
            key: "start",
            value: false,
            protected: true
          },
          {
            key: "ended",
            value: false,
            protected: true
          }
        ])
      });
      stageAdds.push(scope2);
      return accessors2;
    };
    this.addFinalizer(async () => {
      this._tmpRoundIndex = void 0;
      let rounds;
      try {
        rounds = await roundProm;
      } catch (err) {
        error(`failed to create round: ${err}`);
        return;
      }
      if (rounds.length < 1) {
        error(`failed to create round`);
        return;
      }
      const roundID = rounds[0].id;
      const round = this.scopeByID(roundID);
      if (!round) {
        throw "round not found in round finalizer";
      }
      let stageIndex = isOptionalNumber(round.get("stageIndex")) || 0;
      for (const scope2 of stageAdds) {
        const durAttr = scope2.attributes.find((a) => a.key === "duration");
        if (!durAttr || !durAttr.val) {
          error(`stage duration not found`);
          continue;
        }
        const res = import_zod.z.number().int().gte(1).safeParse(JSON.parse(durAttr.val));
        if (!res.success) {
          throw new Error(`stage duration invalid: ${res.error}`);
        }
        const duration = res.data;
        scope2.attributes.push({
          key: "roundID",
          val: JSON.stringify(roundID),
          immutable: true
        });
        let steps;
        try {
          steps = await this.addSteps([{ duration }]);
        } catch (err) {
          error(`failed to create steps: ${err}`);
          return;
        }
        if (steps.length < 1) {
          error(`failed to create steps`);
          return;
        }
        const stepID = steps[0].id;
        scope2.attributes.push({
          key: "timerID",
          val: JSON.stringify(stepID),
          immutable: true
        });
        scope2.attributes.push({
          key: "index",
          val: `${stageIndex}`,
          immutable: true
        });
        stageIndex++;
      }
      round.set("stageIndex", stageIndex);
      await this.addScopes(stageAdds);
    });
    return {
      ...accessors,
      addStage
    };
  }
  end(status, reason) {
    if (this.hasEnded) {
      return;
    }
    if (!endedStatuses.includes(status)) {
      warn(`game: attempting to end game with wrong status`);
      return;
    }
    this.set("status", status);
    this.set("endedReason", reason);
    const stage = this.currentStage;
    if (!stage) {
      return;
    }
    stage.end("ended", reason);
  }
  async createPlayerGame(player) {
    const key = `playerGameID-${this.id}`;
    if (player.get(key)) {
      return isString(player.get(key));
    }
    const batchID = isString(this.get("batchID"));
    const playerGames = await this.addScopes([
      {
        kind: "playerGame",
        attributes: attrs([
          {
            key: "batchID",
            value: batchID,
            immutable: true
          },
          {
            key: "gameID",
            value: this.id,
            immutable: true
          },
          {
            key: "playerID",
            value: player.id,
            immutable: true
          }
        ])
      }
    ]);
    if (playerGames.length < 1) {
      error(`failed to create playerGame`);
      return;
    }
    player.set(key, playerGames[0].id);
    return playerGames[0].id;
  }
};
var GameOwned = class extends BatchOwned {
  get currentGame() {
    return this.scopeByKey("gameID");
  }
};
var Player = class extends GameOwned {
  get game() {
    const game = this.currentGame;
    if (!game) {
      return;
    }
    const key = `playerGameID-${game.id}`;
    return this.scopeByKey(key);
  }
  get currentRound() {
    return this.currentStage?.round;
  }
  get round() {
    const round = this.currentRound;
    if (!round) {
      return;
    }
    const key = `playerRoundID-${round.id}`;
    return this.scopeByKey(key);
  }
  get currentStage() {
    return this.currentGame?.currentStage;
  }
  get stage() {
    const stage = this.currentStage;
    if (!stage) {
      return;
    }
    const key = `playerStageID-${stage.id}`;
    return this.scopeByKey(key);
  }
  exit(reason) {
    if (this.get("ended")) {
      return;
    }
    this.set("ended", reason);
  }
  hasUpdated() {
    if (super.hasUpdated()) {
      return true;
    }
    return Boolean(
      this.round?.hasUpdated() || this.stage?.hasUpdated() || this.game?.hasUpdated()
    );
  }
};
var PlayerGame = class extends GameOwned {
};
var PlayerRound = class extends GameOwned {
};
var PlayerStage = class extends GameOwned {
  get stage() {
    return this.scopeByKey("stageID");
  }
  get player() {
    return this.scopeByKey("playerID");
  }
};
var minStageDuration = 5;
var maxStageDuration = 1e9;
var Round = class extends GameOwned {
  get stages() {
    const stages = this.scopesByKindMatching(
      "stage",
      "roundID",
      this.id
    );
    stages.sort(indexSortable);
    return stages;
  }
  addStage(attributes) {
    if (!Array.isArray(attributes)) {
      const newAttr = [];
      for (const key in attributes) {
        newAttr.push({
          key,
          value: attributes[key]
        });
      }
      attributes = newAttr;
    }
    const durAttr = attributes.find((a) => a.key === "duration");
    const res = import_zod.z.number().int().gte(minStageDuration).lte(maxStageDuration).safeParse(durAttr?.value);
    if (!res.success) {
      throw new Error(`stage duration invalid: ${res.error}`);
    }
    const duration = res.data;
    const batchID = this.get("batchID");
    if (!batchID) {
      throw new Error("missing batch ID on round");
    }
    const gameID = this.get("gameID");
    if (!gameID) {
      throw new Error("missing game ID on round");
    }
    const stageIndex = import_zod.z.number().parse(this.get("stageIndex") || -1) + 1;
    this.set("stageIndex", stageIndex);
    const [scope, accessors] = scopeConstructor({
      kind: "stage",
      attributes: attrs([
        ...attributes.filter((a) => !reservedKeys.includes(a.key)),
        {
          key: "index",
          value: stageIndex,
          immutable: true
        },
        {
          key: "roundID",
          value: this.id,
          immutable: true
        },
        {
          key: "gameID",
          value: gameID,
          immutable: true
        },
        {
          key: "batchID",
          value: batchID,
          immutable: true
        },
        {
          key: "start",
          value: false,
          protected: true
        },
        {
          key: "ended",
          value: false,
          protected: true
        }
      ])
    });
    this.addFinalizer(async () => {
      let steps;
      try {
        steps = await this.addSteps([{ duration }]);
      } catch (err) {
        error(`failed to create steps: ${err}`);
        return;
      }
      if (steps.length < 1) {
        error(`failed to create steps`);
        return;
      }
      const stepID = steps[0].id;
      scope.attributes.push({
        key: "timerID",
        val: JSON.stringify(stepID),
        immutable: true
      });
      this.addScopes([scope]);
    });
    return accessors;
  }
  async createPlayerRound(player) {
    const key = `playerRoundID-${this.id}`;
    if (player.get(key)) {
      return isString(player.get(key));
    }
    const gameID = isString(this.get("gameID"));
    const batchID = isString(this.get("batchID"));
    const playerRounds = await this.addScopes([
      {
        kind: "playerRound",
        attributes: attrs([
          {
            key: "batchID",
            value: batchID,
            immutable: true
          },
          {
            key: "gameID",
            value: gameID,
            immutable: true
          },
          {
            key: "roundID",
            value: this.id,
            immutable: true
          },
          {
            key: "playerID",
            value: player.id,
            immutable: true
          }
        ])
      }
    ]);
    if (playerRounds.length < 1) {
      error(`failed to create playerRound`);
      return;
    }
    player.set(key, playerRounds[0].id);
    return playerRounds[0].id;
  }
};
var Stage = class extends GameOwned {
  get round() {
    return this.scopeByKey("roundID");
  }
  isCurrent() {
    return this.currentGame?.get("stageID") === this.id;
  }
  end(status, reason) {
    if (this.get("ended")) {
      return;
    }
    this.set("status", status);
    this.set("endedReason", reason);
    this.addTransitions([
      {
        from: import_tajriba4.State.Running,
        to: import_tajriba4.State.Ended,
        nodeID: this.get("timerID"),
        cause: reason
      }
    ]);
  }
  async createPlayerStage(player) {
    const key = `playerStageID-${this.id}`;
    if (player.get(key)) {
      return isString(player.get(key));
    }
    const roundID = isString(this.get("roundID"));
    const gameID = isString(this.get("gameID"));
    const batchID = isString(this.get("batchID"));
    const playerStages = await this.addScopes([
      {
        kind: "playerStage",
        attributes: attrs([
          {
            key: "batchID",
            value: batchID,
            immutable: true
          },
          {
            key: "gameID",
            value: gameID,
            immutable: true
          },
          {
            key: "roundID",
            value: roundID,
            immutable: true
          },
          {
            key: "stageID",
            value: this.id,
            immutable: true
          },
          {
            key: "playerID",
            value: player.id,
            immutable: true
          }
        ])
      }
    ]);
    if (playerStages.length < 1) {
      error(`failed to create playerStage`);
      return;
    }
    player.set(key, playerStages[0].id);
    return playerStages[0].id;
  }
};
var Context = class {
};
var classicKinds = {
  batch: Batch,
  game: Game,
  player: Player,
  playerGame: PlayerGame,
  playerRound: PlayerRound,
  playerStage: PlayerStage,
  round: Round,
  stage: Stage
};
var EventProxy = class {
  constructor(ctx) {
    this.ctx = ctx;
  }
  // Returns all loaded Batches.
  get batches() {
    return Array.from(this.ctx.scopesByKind("batch").values());
  }
  // Returns all loaded Games accross Batches.
  get games() {
    return Array.from(this.ctx.scopesByKind("game").values());
  }
  // Returns all loaded Players accross all Games.
  get players() {
    return Array.from(this.ctx.scopesByKind("player").values());
  }
};
function evt(ctx) {
  return new EventProxy(ctx);
}

// src/admin/classic/schemas.ts
var import_zod2 = require("zod");
var treatmentSchema = import_zod2.z.record(import_zod2.z.string().min(1), import_zod2.z.any());
var batchConfigSchema = import_zod2.z.discriminatedUnion("kind", [
  import_zod2.z.object({
    kind: import_zod2.z.literal("custom"),
    config: import_zod2.z.any()
  }),
  import_zod2.z.object({
    kind: import_zod2.z.literal("simple"),
    config: import_zod2.z.object({
      count: import_zod2.z.number().int().positive(),
      treatments: import_zod2.z.object({
        factors: treatmentSchema
      }).array()
    })
  }),
  import_zod2.z.object({
    kind: import_zod2.z.literal("complete"),
    config: import_zod2.z.object({
      treatments: import_zod2.z.object({
        count: import_zod2.z.number().int().positive(),
        treatment: import_zod2.z.object({
          factors: treatmentSchema
        })
      }).array()
    })
  })
]);

// src/admin/classic/classic.ts
var isGame = import_zod3.z.instanceof(Game).parse;
var isRound = import_zod3.z.instanceof(Round).parse;
var isStage = import_zod3.z.instanceof(Stage).parse;
var isString2 = import_zod3.z.string().parse;
function Classic({
  disableAssignment,
  disableIntroCheck,
  disableGameCreation,
  disableBatchAutoend = false
} = {}) {
  return function(_) {
    const online = /* @__PURE__ */ new Map();
    const playersForParticipant = /* @__PURE__ */ new Map();
    const stageForStepID = /* @__PURE__ */ new Map();
    async function assignplayer(ctx, player, skipGameIDs) {
      if (disableAssignment) {
        return;
      }
      if (player.get("gameID")) {
        return;
      }
      for (const batch of evt(ctx).batches) {
        if (!batch.isRunning) {
          continue;
        }
        let availableGames = [];
        for (const game2 of batch.games) {
          if (!game2.hasStarted && (!skipGameIDs || !skipGameIDs?.includes(game2.id))) {
            availableGames.push(game2);
          }
        }
        if (availableGames.length === 0) {
          continue;
        }
        if (player.get("treatment")) {
          availableGames = availableGames.filter(
            (g) => deepEqual(g.get("treatment"), player.get("treatment"))
          );
        }
        if (availableGames.length === 0) {
          continue;
        }
        const game = pickRandom(availableGames);
        await game.assignPlayer(player);
        return;
      }
      if (player.get("gameID") !== void 0) {
        player.set("ended", "no more games");
      }
    }
    function checkShouldOpenExperiment(ctx) {
      let shouldOpenExperiment = false;
      LOOP:
        for (const batch of evt(ctx).batches) {
          if (!batch.isRunning) {
            continue;
          }
          for (const game of batch.games) {
            if (!game.hasStarted) {
              shouldOpenExperiment = true;
              break LOOP;
            }
          }
        }
      ctx.globals.set("experimentOpen", shouldOpenExperiment);
    }
    function tryToStartGame(ctx, game) {
      if (game.get("stageID"))
        return;
      if (game.stages.length === 0) {
        return;
      }
      const groupID = isString2(game.get("groupID"));
      const players = game.players.filter((p) => !p.get("ended"));
      const participantIDs = [];
      const nodeIDs = [game.id, groupID];
      for (const player of players) {
        nodeIDs.push(player.id);
        participantIDs.push(player.participantID);
        const playerGameID = player.get(`playerGameID-${game.id}`);
        if (!playerGameID) {
          return;
        }
        nodeIDs.push(playerGameID);
      }
      ctx.addLinks([{ link: true, participantIDs, nodeIDs }]);
      const round = isRound(game.rounds[0]);
      if (round.stages.length === 0) {
        return;
      }
      const stage = isStage(round.stages[0]);
      game.set("stageID", stage.id);
      round.set("start", true);
    }
    _.on("PARTICIPANT_CONNECT" /* ParticipantConnect */, async (ctx, { participant }) => {
      online.set(participant.id, participant);
      const player = playersForParticipant.get(participant.id);
      if (!player) {
        await ctx.addScopes([
          {
            attributes: attrs([
              {
                key: "participantID",
                value: participant.id,
                immutable: true
              },
              {
                key: "participantIdentifier",
                value: participant.identifier,
                immutable: true
              }
            ]),
            kind: "player"
          }
        ]);
      } else {
        await assignplayer(ctx, player);
      }
    });
    _.on("PARTICIPANT_DISCONNECT" /* ParticipantDisconnect */, (_2, { participant }) => {
      online.delete(participant.id);
    });
    _.on("player", async (ctx, { player }) => {
      const participantID = isString2(player.get("participantID"));
      player.participantID = participantID;
      playersForParticipant.set(participantID, player);
      ctx.addLinks([
        {
          link: true,
          participantIDs: [player.participantID],
          nodeIDs: [player.id]
        }
      ]);
      if (online.has(participantID)) {
        await assignplayer(ctx, player);
      }
    });
    _.on("batch", (_2, { batch }) => {
      if (disableGameCreation || batch.get("initialized")) {
        return;
      }
      batch.set("initialized", true);
      const config2 = batchConfigSchema.parse(batch.get("config"));
      switch (config2.kind) {
        case "simple":
          for (let i = 0; i < config2.config.count; i++) {
            const treatment = pickRandom(config2.config.treatments).factors;
            batch.addGame([
              {
                key: "treatment",
                value: treatment,
                immutable: true
              }
            ]);
          }
          break;
        case "complete":
          for (const t of config2.config.treatments) {
            for (let i = 0; i < t.count; i++) {
              batch.addGame([
                {
                  key: "treatment",
                  value: t.treatment.factors,
                  immutable: true
                }
              ]);
            }
          }
          break;
        default:
          warn("callbacks: batch created without a config");
          return;
      }
    });
    _.unique.on(
      "batch",
      "status",
      async (ctx, { batch, status }) => {
        switch (status) {
          case "running": {
            for (const [_2, player] of playersForParticipant) {
              if (player.participantID) {
                await assignplayer(ctx, player);
              }
            }
            checkShouldOpenExperiment(ctx);
            break;
          }
          case "terminated":
            for (const game of batch.games) {
              game.end(status, "batch ended");
            }
            checkShouldOpenExperiment(ctx);
            break;
          case "ended":
            checkShouldOpenExperiment(ctx);
            break;
          case "created":
            break;
          default:
            warn("unknown batch status:", status);
            break;
        }
      }
    );
    _.unique.on("game", "status", (ctx, { game, status }) => {
      switch (status) {
        case "running": {
          tryToStartGame(ctx, game);
          checkShouldOpenExperiment(ctx);
          break;
        }
        case "ended":
        case "failed":
        case "terminated":
          for (const player of game.players) {
            player.set("ended", `game ${status}`);
          }
          const finishedBatch = !disableBatchAutoend && game.batch.games.every((g) => g.hasEnded);
          if (finishedBatch) {
            game.batch.end("all games finished");
          }
          checkShouldOpenExperiment(ctx);
          break;
        default:
          warn(`unkown game status: ${status}`);
          break;
      }
    });
    _.on("game", async (ctx, { game }) => {
      if (game.get("groupID")) {
        return;
      }
      let groups;
      try {
        groups = await ctx.addGroups([{ participantIDs: [] }]);
      } catch (err) {
        error(`failed to create game group: ${err}`);
        return;
      }
      if (groups.length < 1) {
        error(`failed to create game groups`);
        return;
      }
      const groupID = groups[0].id;
      game.set("groupID", groupID);
    });
    _.on("stage", "gameID", async (ctx, { stage }) => {
      if (!stage.currentGame?.isRunning) {
        return;
      }
      tryToStartGame(ctx, stage.currentGame);
    });
    _.after("stage", "timerID", (_2, { stage, timerID }) => {
      stageForStepID.set(timerID, stage);
    });
    function getNextStage(stage, game) {
      if (game.hasEnded) {
        return { stop: true, nextStage: void 0, nextRound: void 0 };
      }
      const currentRound = isRound(stage.round);
      let nextRound = currentRound;
      const roundStages = currentRound.stages;
      let nextStage = roundStages[stage.get("index") + 1];
      if (!nextStage) {
        const gameRounds = game.rounds;
        nextRound = gameRounds[currentRound.get("index") + 1];
        if (!nextRound) {
          return { stop: true, nextStage: void 0, nextRound: void 0 };
        }
        nextStage = nextRound.stages[0];
        if (!nextStage) {
          return { stop: true, nextStage: void 0, nextRound: void 0 };
        }
      }
      return { nextStage, nextRound, stop: false };
    }
    _.on("player", "introDone", async (ctx, { player }) => {
      if (disableIntroCheck || !player.currentGame) {
        return;
      }
      const game = isGame(player.currentGame);
      const treatment = treatmentSchema.parse(game.get("treatment"));
      const playerCount = treatment["playerCount"];
      const readyPlayers = game.players.filter(
        (p) => p.get("introDone") && !p.get("ended")
      );
      if (readyPlayers.length < playerCount) {
        trace("introDone: not enough players ready yet");
        return;
      }
      if (game.hasStarted) {
        trace("introDone: game already started");
        return;
      }
      const players = selectRandom(readyPlayers, playerCount);
      const playersIDS = players.map((p) => p.id);
      for (const plyr of game.players) {
        if (!playersIDS.includes(plyr.id)) {
          plyr.set("gameID", null);
          await assignplayer(ctx, plyr, [game.id]);
        }
      }
      trace("introDone: starting game");
      game.start();
    });
    _.unique.before(
      "game",
      "start",
      async (_2, { game, start }) => {
        if (!start) {
          return;
        }
        for (const player of game.players) {
          await game.createPlayerGame(player);
        }
      }
    );
    _.unique.after("game", "start", (_2, { game, start }) => {
      if (!start) {
        return;
      }
      game.set("status", "running");
    });
    _.unique.before(
      "round",
      "start",
      async (_2, { round, start }) => {
        if (!start) {
          return;
        }
        const game = isGame(round.currentGame);
        for (const player of game.players) {
          await round.createPlayerRound(player);
        }
      }
    );
    _.unique.after(
      "round",
      "start",
      (ctx, { round, start }) => {
        if (!start)
          return;
        const game = isGame(round.currentGame);
        const stageID = isString2(game.get("stageID"));
        const stage = isStage(game.stages.find((s) => s.id === stageID));
        if (stage.get("start")) {
          return;
        }
        const participantIDs = [];
        const nodeIDs = [round.id];
        for (const player of game.players) {
          participantIDs.push(player.participantID);
          nodeIDs.push(isString2(player.get(`playerRoundID-${round.id}`)));
        }
        ctx.addLinks([{ link: true, participantIDs, nodeIDs }]);
        stage.set("start", true);
      }
    );
    _.unique.before(
      "stage",
      "start",
      async (_2, { stage, start }) => {
        if (!start)
          return;
        const game = isGame(stage.currentGame);
        for (const player of game.players) {
          await stage.createPlayerStage(player);
        }
      }
    );
    _.unique.after(
      "stage",
      "start",
      (ctx, { stage, start }) => {
        if (!start)
          return;
        if (stage.get("started")) {
          return;
        }
        stage.set("started", true);
        const game = isGame(stage.currentGame);
        const timerID = isString2(stage.get("timerID"));
        const participantIDs = [];
        const nodeIDs = [stage.id, timerID];
        for (const player of game.players) {
          participantIDs.push(player.participantID);
          nodeIDs.push(isString2(player.get(`playerStageID-${stage.id}`)));
        }
        ctx.addLinks([{ link: true, participantIDs, nodeIDs }]);
        ctx.addTransitions([
          {
            from: import_tajriba5.State.Created,
            to: import_tajriba5.State.Running,
            nodeID: timerID,
            cause: "stage start"
          }
        ]);
      }
    );
    _.after(
      "playerStage",
      "submit",
      (ctx, { playerStage, submit }) => {
        if (!submit)
          return;
        if (!playerStage.stage || !playerStage.stage.isCurrent()) {
          return;
        }
        const players = playerStage.player.currentGame.players;
        if (players.length === 0) {
          warn("callbacks: no players onSubmit");
          return;
        }
        const haveAllPlayersSubmitted = players.every(
          (p) => p.get("ended") || !online.has(p.get("participantID")?.toString()) || p.stage?.get("submit")
        );
        if (haveAllPlayersSubmitted) {
          ctx.addTransitions([
            {
              from: import_tajriba5.State.Running,
              to: import_tajriba5.State.Ended,
              nodeID: isString2(playerStage.stage.get("timerID")),
              cause: "players submitted"
            }
          ]);
          trace(`all player submitted, transitioning`);
        } else {
          trace(`not all player submitted`);
        }
      }
    );
    _.unique.after(
      "stage",
      "ended",
      (ctx, { stage, ended }) => {
        if (!ended)
          return;
        const game = isGame(stage.currentGame);
        const timerID = isString2(stage.get("timerID"));
        const round = isRound(stage.round);
        const participantIDs = [];
        const nodeIDs = [stage.id, timerID];
        for (const player of game.players) {
          participantIDs.push(player.participantID);
          nodeIDs.push(isString2(player.get(`playerStageID-${stage.id}`)));
        }
        ctx.addLinks([{ link: false, participantIDs, nodeIDs }]);
        const { stop, nextRound, nextStage } = getNextStage(stage, game);
        if (stop) {
          round.set("ended", true);
          return;
        }
        if (round.id !== nextRound.id) {
          round.set("ended", true);
        } else {
          game.set("stageID", nextStage.id);
          nextStage.set("start", true);
        }
      }
    );
    _.unique.after(
      "round",
      "ended",
      (ctx, { round, ended }) => {
        if (!ended)
          return;
        const game = isGame(round.currentGame);
        const stage = isStage(game.currentStage);
        const participantIDs = [];
        const nodeIDs = [round.id];
        for (const player of game.players) {
          participantIDs.push(player.participantID);
          nodeIDs.push(isString2(player.get(`playerRoundID-${round.id}`)));
        }
        ctx.addLinks([{ link: false, participantIDs, nodeIDs }]);
        const { stop, nextRound, nextStage } = getNextStage(stage, game);
        if (stop) {
          game.set("stageID", null);
          game.set("ended", true);
          return;
        }
        game.set("stageID", nextStage.id);
        nextRound.set("start", true);
      }
    );
    _.unique.after("game", "ended", (_2, { game, ended }) => {
      if (!ended)
        return;
      game.end("ended", "end of game");
    });
    _.on(
      "TRANSITION_ADD" /* TransitionAdd */,
      (_2, { step, transition: { from, to } }) => {
        const stage = stageForStepID.get(step.id);
        if (!stage) {
          return;
        }
        debug(`transition stage: ${from} => ${to}`);
        if (from === import_tajriba5.State.Running && to === import_tajriba5.State.Ended) {
          const stage2 = isStage(stageForStepID.get(step.id));
          if (!stage2.get("ended")) {
            stage2.set("ended", true);
          }
        }
      }
    );
  };
}

// src/admin/classic/api/api.ts
var import_tajriba6 = require("@empirica/tajriba");
var Scope3 = class {
  constructor(conn, edge) {
    this.conn = conn;
    this.edge = edge;
    this._attributes = /* @__PURE__ */ new Map();
    for (const edge2 of this.edge.attributes.edges) {
      this._attributes.set(edge2.node.key, new Attribute3(edge2.node));
    }
  }
  get id() {
    return this.edge.id;
  }
  get attributes() {
    return Array.from(this._attributes.values()).filter(
      (a) => !a.key.startsWith("ran-") && !a.key.startsWith("playerGameID") && !a.key.startsWith("playerRoundID") && !a.key.startsWith("playerStageID")
    );
  }
  allAttributes() {
    return this._attributes;
  }
};
var Attribute3 = class {
  constructor(edge) {
    this.edge = edge;
    if (edge.val) {
      this._value = JSON.parse(edge.val);
    }
  }
  get id() {
    return this.edge.id;
  }
  get key() {
    return this.edge.key;
  }
  get value() {
    return this._value;
  }
};
var Player3 = class extends Scope3 {
};
var Batch3 = class extends Scope3 {
};
var Game2 = class extends Scope3 {
};
var PlayerGame2 = class extends Scope3 {
};
var Round2 = class extends Scope3 {
};
var PlayerRound2 = class extends Scope3 {
};
var Stage2 = class extends Scope3 {
};
var PlayerStage3 = class extends Scope3 {
};
var Conn = class {
  constructor(tajriba) {
    this.tajriba = tajriba;
  }
  stop() {
    this.tajriba.stop();
  }
  players() {
    return this.scopesByKind("player", Player3);
  }
  batches() {
    return this.scopesByKind("batch", Batch3);
  }
  games() {
    return this.scopesByKind("game", Game2);
  }
  rounds() {
    return this.scopesByKind("round", Round2);
  }
  stages() {
    return this.scopesByKind("stage", Stage2);
  }
  playerGames() {
    return this.scopesByKind("playerGame", PlayerGame2);
  }
  playerRounds() {
    return this.scopesByKind("playerRound", PlayerRound2);
  }
  playerStages() {
    return this.scopesByKind("playerStage", PlayerStage3);
  }
  scopesByKind(kind, cnstrctr) {
    return this.filteredScopes({ kinds: [kind] }, cnstrctr);
  }
  async *filteredScopes(filter, cnstrctr) {
    const args = {
      first: 100,
      filter
    };
    while (true) {
      const scopes = await this.tajriba.scopes(args);
      for (const edge of scopes?.edges ?? []) {
        yield new cnstrctr(this, edge.node);
      }
      if (!scopes?.pageInfo.hasNextPage) {
        break;
      } else {
        args.after = scopes.pageInfo.endCursor;
      }
    }
  }
};
async function connect(tajURL, token, srtoken, clientName = "api") {
  const tajriba = await import_tajriba6.Tajriba.createAndAwait(tajURL);
  if (!token) {
    token = await tajriba.registerService(clientName, srtoken);
  }
  return new Conn(await tajriba.sessionAdmin(token));
}

// src/admin/classic/export/export_csv.ts
var import_archiver = __toESM(require("archiver"), 1);
var import_fs2 = __toESM(require("fs"), 1);
var import_stream_buffers = __toESM(require("stream-buffers"), 1);
var BOM = "\uFEFF";
async function exportCSV(conn, output) {
  const archive = (0, import_archiver.default)("zip");
  const stream = import_fs2.default.createWriteStream(output);
  const prom = promiseHandle();
  stream.on("close", function() {
    console.log("Finalizing archive (" + archive.pointer() + " bytes)");
    prom.result();
  });
  archive.on("warning", function(err) {
    console.warn(err);
  });
  archive.on("error", function(err) {
    console.error(err);
    throw err;
  });
  archive.pipe(stream);
  const a = archive;
  await processType(a, "batches", conn.batches.bind(conn));
  await processType(a, "games", conn.games.bind(conn));
  await processType(a, "playerGames", conn.playerGames.bind(conn));
  await processType(a, "rounds", conn.rounds.bind(conn));
  await processType(a, "playerRounds", conn.playerRounds.bind(conn));
  await processType(a, "stages", conn.stages.bind(conn));
  await processType(a, "playerStages", conn.playerStages.bind(conn));
  await processType(a, "players", conn.players.bind(conn));
  archive.finalize();
  await prom.promise;
}
async function processType(archive, fileName, it) {
  console.log("processing", fileName);
  const file = newFile(archive, fileName, "csv");
  const keys = /* @__PURE__ */ new Set();
  for await (const record of it()) {
    for (const attr of record.attributes) {
      keys.add(attr.key);
    }
  }
  const keyArr = Array.from(keys.values());
  file.put(encodeCells(keyArr));
  for await (const record of it()) {
    const attrs2 = record.attributes;
    const line = [];
    LOOP:
      for (const key of keyArr) {
        for (const attr of attrs2) {
          if (attr.key === key) {
            line.push(cast(attr.value));
            continue LOOP;
          }
        }
        line.push(void 0);
      }
    file.put(encodeCells(line));
  }
  file.stop();
}
function newFile(archive, name, extension) {
  const file = new import_stream_buffers.default.ReadableStreamBuffer();
  archive.append(file, { name: `${name}.${extension}` });
  file.put(BOM);
  return file;
}
var quoteMark = '"';
var doubleQuoteMark = '""';
var quoteRegex = /"/g;
var encodeCells = (line) => {
  const row = line.slice(0);
  for (var i = 0, len = row.length; i < len; i++) {
    if (row[i] === void 0) {
      row[i] = "";
      continue;
    }
    row[i] = JSON.stringify(row[i]);
    if (row[i].indexOf(quoteMark) !== -1) {
      row[i] = row[i].replace(quoteRegex, doubleQuoteMark);
    }
    if (row[i].indexOf(",") !== -1 || row[i].indexOf("\\n") !== -1) {
      row[i] = quoteMark + row[i] + quoteMark;
    }
  }
  return row.join(",") + "\n";
};
var cast = (out) => {
  if (Array.isArray(out)) {
    return out.map((a) => cast(a)).join(",");
  } else if (out instanceof Date) {
    return out.toISOString();
  } else if (typeof out === "object" && out !== null) {
    return JSON.stringify(out);
  } else if (typeof out === "string") {
    return out.replace(/\n/g, "\\n");
  } else if (out === false || out === 0) {
    return out.toString();
  } else {
    return (out || "").toString();
  }
};

// src/admin/classic/export/export.ts
async function exportJSON(_, __) {
  throw new Error("JSON export not implemented");
}
var ExportFormat = /* @__PURE__ */ ((ExportFormat2) => {
  ExportFormat2["CSV"] = "csv";
  ExportFormat2["JSON"] = "json";
  return ExportFormat2;
})(ExportFormat || {});
async function runExport(url, token, srtoken, format, output) {
  const taj = await connect(url, token, srtoken);
  switch (format) {
    case "csv" /* CSV */:
      await exportCSV(taj, output);
      break;
    case "json" /* JSON */:
      await exportJSON(taj, output);
      break;
    default:
      throw new Error(`Unknown format ${format}`);
  }
  taj.stop();
  console.log("finished");
}

// src/admin/classic/loader.ts
var import_zod4 = require("zod");
var string = import_zod4.z.string();
function ClassicLoader(_) {
  _.on("start", function(ctx) {
    ctx.participantsSub();
    ctx.scopeSub({ kinds: ["batch", "player"] });
  });
  _.on("batch", "status", function(ctx, { batch, status }) {
    if (["running", "created"].includes(status)) {
      ctx.scopeSub({
        kvs: [{ key: "batchID", val: JSON.stringify(batch.id) }]
      });
    }
  });
  _.on("stage", "timerID", function(ctx, { timerID }) {
    ctx.transitionsSub(string.parse(timerID));
  });
}

// src/admin/classic/lobby.ts
var import_tajriba7 = require("@empirica/tajriba");
var import_zod5 = require("zod");
var nanosecond = 1;
var microsecond = 1e3 * nanosecond;
var millisecond = 1e3 * microsecond;
var second = 1e3 * millisecond;
var lobbyTimerKey = "lobbyTimerID";
var individualTimerGameKey = "lobbyTimerGameID";
function Lobby(_ = {}) {
  return function(_2) {
    _2.on("player", "introDone", async (ctx, { player }) => {
      const game = player.currentGame;
      if (!game) {
        return;
      }
      switch (game.lobbyConfig.kind) {
        case "shared":
          await setupSharedLobbyTimeout(ctx, game);
          break;
        case "individual":
          await setupIndividualLobbyTimeout(ctx, game, player);
          break;
      }
    });
    const string2 = import_zod5.z.string();
    _2.on("game", lobbyTimerKey, function(ctx, params) {
      ctx.transitionsSub(string2.parse(params[lobbyTimerKey]));
    });
    _2.on("player", lobbyTimerKey, function(ctx, params) {
      ctx.transitionsSub(string2.parse(params[lobbyTimerKey]));
    });
    _2.on(
      "TRANSITION_ADD" /* TransitionAdd */,
      (ctx, { step, transition: { from, to } }) => {
        debug("lobby: lobby transition check");
        if (from !== import_tajriba7.State.Running || to !== import_tajriba7.State.Ended) {
          return;
        }
        expiredSharedLobbyTimeout(ctx, step);
        expiredIndividualLobbyTimeout(ctx, step);
      }
    );
  };
}
async function setupIndividualLobbyTimeout(ctx, game, player) {
  if (player.get(lobbyTimerKey) && player.get(individualTimerGameKey) === game.id) {
    trace("lobby: individual timer already set", game.lobbyConfig);
    return;
  }
  const stepID = await getTimer(ctx, game.lobbyConfig.duration);
  if (!stepID) {
    error("lobby: timer not created");
    return;
  }
  player.set(lobbyTimerKey, stepID);
  player.set(individualTimerGameKey, game.id);
  ctx.addTransitions([
    {
      from: import_tajriba7.State.Created,
      to: import_tajriba7.State.Running,
      nodeID: stepID,
      cause: "lobby timer start"
    }
  ]);
}
async function expiredIndividualLobbyTimeout(ctx, step) {
  const players = ctx.scopesByKindMatching(
    "player",
    lobbyTimerKey,
    step.id
  );
  if (!players.length) {
    return;
  }
  const player = players[0];
  const game = player.currentGame;
  if (!game || game.hasStarted || player.get(individualTimerGameKey) !== game.id) {
    return;
  }
  player.exit("lobby timed out");
}
async function setupSharedLobbyTimeout(ctx, game) {
  if (game.get(lobbyTimerKey)) {
    trace("lobby: lobby already exists", game.lobbyConfig);
    return;
  }
  const stepID = await getTimer(ctx, game.lobbyConfig.duration);
  if (!stepID) {
    error("lobby: timer not created");
    return;
  }
  debug("lobby: lobby created", stepID);
  game.set(lobbyTimerKey, stepID);
  try {
    await ctx.addTransitions([
      {
        from: import_tajriba7.State.Created,
        to: import_tajriba7.State.Running,
        nodeID: stepID,
        cause: "lobby timer start"
      }
    ]);
  } catch (e) {
    debug("lobby: failed to start lobby timeout", e);
  }
}
async function expiredSharedLobbyTimeout(ctx, step) {
  const games = ctx.scopesByKindMatching("game", lobbyTimerKey, step.id);
  if (!games.length) {
    debug("lobby: game for lobby not found");
    return;
  }
  const game = games[0];
  debug("lobby: lobby for game", game.id);
  if (game.hasStarted) {
    debug("lobby: game for lobby started");
    return;
  }
  const readyPlayers = game.players.filter((p) => p.get("introDone"));
  if (readyPlayers.length === 0) {
    game.set(lobbyTimerKey, null);
    return;
  }
  switch (game.lobbyConfig.strategy) {
    case "fail":
      debug("lobby: failing game");
      game.end("failed", "shared lobby timeout");
      break;
    case "ignore":
      debug("lobby: starting game");
      for (const player of game.players) {
        if (!player.get("introDone")) {
          player.exit("lobby timed out before reached intro");
        }
      }
      game.start();
      break;
  }
}
async function getTimer(ctx, duration) {
  try {
    const dur = duration / second;
    debug("lobby: creating lobby timeout for", dur, "seconds");
    const steps = await ctx.addSteps([{ duration: dur }]);
    return steps[0]?.id;
  } catch (err) {
    return;
  }
}

// src/admin/classic/proxy.ts
var ClassicListenersCollector = class extends ListenersCollector {
  /**
   * onGameStart is triggered just before the game start. It is a great place to
   * create rounds and stages and initialize values on the game, the players,
   * the rounds, and the stages.
   *
   * Players are accessible on the game, `game.players`.
   * You can add Rounds to a Game with `game.addRound({ some: "attribute" })`.
   * `game.AddRound` returns a Round object. On the Round object, you can create
   * Stages: `round.addStage({ some: "value" })`.
   *
   * @example
   * ```js
   * const round = game.addRound({
   *   name: "Round 1 - Jelly Beans",
   *   task: "jellybeans",
   * });
   * round.addStage({ name: "Answer", duration: 300 });
   * round.addStage({ name: "Result", duration: 120 });
   *
   * game.players.forEach((player) => player.set("score", 0));
   * ```
   * */
  onGameStart(cb) {
    this.unique.on(
      "game",
      "start",
      (_, { game, start }) => {
        if (!start)
          return;
        cb({ game });
      }
    );
  }
  onRoundStart(cb) {
    this.unique.on(
      "round",
      "start",
      (_, { round, start }) => {
        if (!start)
          return;
        cb({ round });
      }
    );
  }
  onStageStart(cb) {
    this.unique.on(
      "stage",
      "start",
      (_, { stage, start }) => {
        if (!start)
          return;
        cb({ stage });
      }
    );
  }
  onStageEnded(cb) {
    this.unique.on(
      "stage",
      "ended",
      (_, { stage, ended }) => {
        if (!ended)
          return;
        cb({ stage });
      }
    );
  }
  onRoundEnded(cb) {
    this.unique.on(
      "round",
      "ended",
      (_, { round, ended }) => {
        if (!ended)
          return;
        cb({ round });
      }
    );
  }
  onGameEnded(cb) {
    this.unique.on(
      "game",
      "ended",
      (_, { game, ended }) => {
        if (!ended)
          return;
        cb({ game });
      }
    );
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Attributes,
  Batch,
  Classic,
  ClassicListenersCollector,
  ClassicLoader,
  Context,
  EventContext,
  ExportFormat,
  Game,
  Globals,
  ListenersCollector,
  ListenersCollectorProxy,
  Lobby,
  Player,
  PlayerGame,
  PlayerRound,
  PlayerStage,
  Round,
  Scope,
  Scopes,
  SharedGlobals,
  Stage,
  TajribaAdminAccess,
  TajribaEvent,
  classicKinds,
  evt,
  runExport,
  withTajriba
});
/*! Bundled license information:

tmp/lib/tmp.js:
  (*!
   * Tmp
   *
   * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
   *
   * MIT Licensed
   *)
*/
//# sourceMappingURL=admin-classic.cjs.map