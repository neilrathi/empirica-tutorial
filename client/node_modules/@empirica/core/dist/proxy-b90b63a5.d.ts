import { b as Scope, E as EventContext, L as ListenersCollector } from './context-d910830c.js';
import { j as JsonValue, c as AttributeOptions, C as Constructor } from './scopes-fb583eb4.js';

declare type AttrInput = {
    append?: boolean;
    immutable?: boolean;
    index?: number;
    key: string;
    nodeID?: string;
    private?: boolean;
    protected?: boolean;
    value: JsonValue;
    vector?: boolean;
};

declare const endedStatuses: string[];
declare type EndedStatuses = (typeof endedStatuses)[number];
declare class Batch extends Scope<Context, ClassicKinds> {
    get isRunning(): boolean;
    get games(): Game[];
    addGame(attributes: {
        [key: string]: JsonValue;
    } | AttrInput[]): {
        readonly get: (key: string) => any;
        readonly set: (key: string, value: JsonValue, ao?: Partial<AttributeOptions> | undefined) => void;
    };
    end(reason: string): void;
    get hasEnded(): boolean;
    get lobbyConfig(): {
        extensions?: number | undefined;
        kind: "shared" | "individual";
        duration: number;
        strategy: "ignore" | "fail";
    };
}
declare class BatchOwned extends Scope<Context, ClassicKinds> {
    get batch(): Batch | undefined;
}
declare class Game extends BatchOwned {
    private _tmpRoundIndex;
    get rounds(): Round[];
    get stages(): Stage[];
    get players(): Player[];
    get currentStage(): Stage | undefined;
    get currentRound(): Round | undefined;
    get hasEnded(): boolean;
    get hasStarted(): boolean;
    get hasNotStarted(): boolean;
    get isRunning(): boolean;
    get lobbyConfig(): {
        extensions?: number | undefined;
        kind: "shared" | "individual";
        duration: number;
        strategy: "ignore" | "fail";
    };
    start(): void;
    assignPlayer(player: Player): Promise<void>;
    private addPlayer;
    private removePlayer;
    addRound(attributes: {
        [key: string]: JsonValue;
    } | AttrInput[]): {
        addStage: (attributes: AttrInput[] | {
            [key: string]: JsonValue;
        }) => {
            readonly get: (key: string) => any;
            readonly set: (key: string, value: JsonValue, ao?: Partial<AttributeOptions> | undefined) => void;
        };
        get: (key: string) => any;
        set: (key: string, value: JsonValue, ao?: Partial<AttributeOptions> | undefined) => void;
    };
    end(status: EndedStatuses, reason: string): void;
    createPlayerGame(player: Player): Promise<string | undefined>;
}
declare class GameOwned extends BatchOwned {
    get currentGame(): Game | undefined;
}
declare class Player extends GameOwned {
    participantID?: string;
    get game(): PlayerGame | undefined;
    get currentRound(): Round | undefined;
    get round(): PlayerRound | undefined;
    get currentStage(): Stage | undefined;
    get stage(): PlayerStage | undefined;
    exit(reason: string): void;
    hasUpdated(): boolean;
}
declare class PlayerGame extends GameOwned {
}
declare class PlayerRound extends GameOwned {
}
declare class PlayerStage extends GameOwned {
    get stage(): Stage | undefined;
    get player(): Player | undefined;
}
declare class Round extends GameOwned {
    get stages(): Stage[];
    addStage(attributes: {
        [key: string]: JsonValue;
    } | AttrInput[]): {
        readonly get: (key: string) => any;
        readonly set: (key: string, value: JsonValue, ao?: Partial<AttributeOptions> | undefined) => void;
    };
    createPlayerRound(player: Player): Promise<string | undefined>;
}
declare class Stage extends GameOwned {
    get round(): Round | undefined;
    isCurrent(): boolean;
    end(status: EndedStatuses, reason: string): void;
    createPlayerStage(player: Player): Promise<string | undefined>;
}
declare class Context {
}
declare type ClassicKinds = {
    batch: Constructor<Batch>;
    game: Constructor<Game>;
    player: Constructor<Player>;
    playerGame: Constructor<PlayerGame>;
    playerRound: Constructor<PlayerRound>;
    playerStage: Constructor<PlayerStage>;
    round: Constructor<Round>;
    stage: Constructor<Stage>;
};
declare const classicKinds: {
    batch: typeof Batch;
    game: typeof Game;
    player: typeof Player;
    playerGame: typeof PlayerGame;
    playerRound: typeof PlayerRound;
    playerStage: typeof PlayerStage;
    round: typeof Round;
    stage: typeof Stage;
};
declare class EventProxy {
    private ctx;
    constructor(ctx: EventContext<Context, ClassicKinds>);
    get batches(): Batch[];
    get games(): Game[];
    get players(): Player[];
}
declare function evt(ctx: EventContext<Context, ClassicKinds>): EventProxy;

declare type ClassicConfig = {
    disableAssignment?: boolean;
    disableIntroCheck?: boolean;
    disableGameCreation?: boolean;
    disableBatchAutoend?: boolean;
};
declare function Classic({ disableAssignment, disableIntroCheck, disableGameCreation, disableBatchAutoend, }?: ClassicConfig): (_: ListenersCollector<Context, ClassicKinds>) => void;

/** ClassicLoader loads. */
declare function ClassicLoader(
/** This is the listener */
_: ListenersCollector<Context, ClassicKinds>): void;

/** Collects event listeners. */
declare class ClassicListenersCollector extends ListenersCollector<Context, ClassicKinds> {
    /**
     * onGameStart is triggered just before the game start. It is a great place to
     * create rounds and stages and initialize values on the game, the players,
     * the rounds, and the stages.
     *
     * Players are accessible on the game, `game.players`.
     * You can add Rounds to a Game with `game.addRound({ some: "attribute" })`.
     * `game.AddRound` returns a Round object. On the Round object, you can create
     * Stages: `round.addStage({ some: "value" })`.
     *
     * @example
     * ```js
     * const round = game.addRound({
     *   name: "Round 1 - Jelly Beans",
     *   task: "jellybeans",
     * });
     * round.addStage({ name: "Answer", duration: 300 });
     * round.addStage({ name: "Result", duration: 120 });
     *
     * game.players.forEach((player) => player.set("score", 0));
     * ```
     * */
    onGameStart(cb: (props: {
        game: Game;
    }) => void): void;
    onRoundStart(cb: (props: {
        round: Round;
    }) => void): void;
    onStageStart(cb: (props: {
        stage: Stage;
    }) => void): void;
    onStageEnded(cb: (props: {
        stage: Stage;
    }) => void): void;
    onRoundEnded(cb: (props: {
        round: Round;
    }) => void): void;
    onGameEnded(cb: (props: {
        game: Game;
    }) => void): void;
}

export { AttrInput as A, Batch as B, Classic as C, EventProxy as E, Game as G, Player as P, Round as R, Stage as S, ClassicListenersCollector as a, ClassicLoader as b, classicKinds as c, Context as d, ClassicKinds as e, ClassicConfig as f, PlayerGame as g, PlayerRound as h, PlayerStage as i, evt as j };
