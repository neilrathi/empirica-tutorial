import {
  warn
} from "./chunk-TIKLWCJI.js";

// src/shared/tajriba_connection.ts
import { Tajriba } from "@empirica/tajriba";

// src/utils/object.ts
import { BehaviorSubject } from "rxjs";
function bs(init) {
  return new BehaviorSubject(init);
}
function bsu(init = void 0) {
  return new BehaviorSubject(init);
}
function deepEqual(obj1, obj2) {
  if (obj1 === obj2)
    return true;
  if (isPrimitive(obj1) && isPrimitive(obj2))
    return obj1 === obj2;
  if (Object.keys(obj1).length !== Object.keys(obj2).length)
    return false;
  for (let key in obj1) {
    if (!(key in obj2))
      return false;
    if (!deepEqual(obj1[key], obj2[key]))
      return false;
  }
  return true;
}
function isPrimitive(obj) {
  return obj !== Object(obj);
}

// src/shared/tajriba_connection.ts
var ErrNotConnected = new Error("not connected");
var TajribaConnection = class {
  constructor(url) {
    this.url = url;
    this._connected = bs(false);
    this._connecting = bs(true);
    this._stopped = bs(false);
    this.tajriba = Tajriba.connect(this.url);
    this._connected.next(this.tajriba.connected);
    this.tajriba.on("connected", () => {
      this._connected.next(true);
      this._connecting.next(false);
    });
    this.tajriba.on("disconnected", () => {
      this._connected.next(false);
      this._connecting.next(true);
    });
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    return this._connected;
  }
  get stopped() {
    return this._stopped;
  }
  async sessionParticipant(token, pident) {
    if (!this._connected.getValue()) {
      throw ErrNotConnected;
    }
    return await this.tajriba.sessionParticipant(token, pident);
  }
  async sessionAdmin(token) {
    if (!this._connected.getValue()) {
      throw ErrNotConnected;
    }
    return await this.tajriba.sessionAdmin(token);
  }
  stop() {
    if (this._stopped.getValue()) {
      return;
    }
    if (this.tajriba) {
      this.tajriba.removeAllListeners("connected");
      this.tajriba.removeAllListeners("disconnected");
      this.tajriba.stop();
    }
    this._connecting.next(false);
    this._connected.next(false);
    this._stopped.next(true);
  }
};

// src/admin/observables.ts
import { Subject, concatMap, takeUntil } from "rxjs";
async function awaitObsValue(obs, value) {
  let res;
  const prom = new Promise((r) => {
    res = r;
  });
  const unsub = obs.subscribe((val2) => {
    if (val2 === value) {
      res(val2);
    }
  });
  const val = await prom;
  unsub.unsubscribe();
  return val;
}
function subscribeAsync(obs, fn) {
  const cancel = new Subject();
  obs.pipe(concatMap(fn), takeUntil(cancel)).subscribe();
  return {
    closed: false,
    unsubscribe() {
      if (this.closed) {
        warn("closing a closed async observable subscription");
        return;
      }
      this.closed = true;
      cancel.next();
      cancel.unsubscribe();
    }
  };
}

export {
  bs,
  bsu,
  deepEqual,
  ErrNotConnected,
  TajribaConnection,
  awaitObsValue,
  subscribeAsync
};
//# sourceMappingURL=chunk-DGXLC63B.js.map