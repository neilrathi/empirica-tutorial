import { TajribaAdmin, SubAttributesPayload, SetAttributeInput, AddScopeInput, AddGroupInput, LinkInput, AddStepInput, TransitionInput, State } from '@empirica/tajriba';
import { A as Attribute, a as Attributes$1, G as Globals$1, j as JsonValue, c as AttributeOptions, S as ScopeConstructor, l as Scopes$1, g as ScopeUpdate, f as ScopeIdent, h as Scope$1 } from './scopes-fb583eb4.js';
import { T as TajribaConnection } from './tajriba_connection-cec7bb43.js';
import { Observable, BehaviorSubject } from 'rxjs';

declare type AttributeMsg = {
    attribute?: Attribute;
    done: boolean;
};
declare class Attributes extends Attributes$1 {
    protected attrsByKind: Map<string, Map<string, Map<string, Attribute>>>;
    private attribSubs;
    subscribeAttribute(kind: string, key: string): Observable<AttributeMsg>;
    protected next(scopeIDs: string[]): void;
}

declare class AdminConnection {
    private resetToken;
    private _tajriba;
    private _connected;
    private _connecting;
    private _stopped;
    private sub;
    constructor(taj: TajribaConnection, tokens: BehaviorSubject<string | null | undefined>, resetToken: () => void);
    stop(): void;
    get connecting(): BehaviorSubject<boolean>;
    get connected(): BehaviorSubject<boolean>;
    get stopped(): BehaviorSubject<boolean>;
    get admin(): BehaviorSubject<TajribaAdmin | undefined>;
}

declare class Globals extends Globals$1 {
    private globalScopeID;
    private setAttributes;
    constructor(globals: Observable<SubAttributesPayload>, globalScopeID: string, setAttributes: (input: SetAttributeInput[]) => Promise<unknown>);
    set(key: string, value: JsonValue, ao?: Partial<AttributeOptions>): void;
}

declare class Scopes<Context, Kinds extends {
    [key: string]: ScopeConstructor<Context, Kinds>;
}> extends Scopes$1<Context, Kinds, Scope<Context, Kinds>> {
    readonly taj: TajribaAdminAccess;
    private kindSubs;
    constructor(scopesObs: Observable<ScopeUpdate>, donesObs: Observable<string[]>, ctx: Context, kinds: Kinds, attributes: Attributes, taj: TajribaAdminAccess);
    protected next(scopeIDs: string[]): void;
    protected create(scopeClass: ScopeConstructor<Context, Kinds>, scope: ScopeIdent): Scope<Context, Kinds>;
}
declare class Scope<Context, Kinds extends {
    [key: string]: ScopeConstructor<Context, Kinds>;
}> extends Scope$1<Context, Kinds> {
    private scopes;
    constructor(ctx: Context, scope: ScopeIdent, scopes: Scopes<Context, Kinds>, attributes: Attributes);
    protected scopeByID<T extends Scope<Context, Kinds>>(id: string): T | undefined;
    protected scopeByKey<T extends Scope<Context, Kinds>>(key: string): T | undefined;
    protected scopesByKind<T extends Scope<Context, Kinds>>(kind: keyof Kinds): Map<string, T>;
    protected scopesByKindID<T extends Scope<Context, Kinds>>(kind: keyof Kinds, id: string): T | undefined;
    protected scopesByKindMatching<T extends Scope<Context, Kinds>>(kind: keyof Kinds, key: string, val: string): T[];
    protected addScopes(input: AddScopeInput[]): Promise<AddScopePayload[]>;
    protected addGroups(input: AddGroupInput[]): Promise<{
        id: string;
    }[]>;
    protected addLinks(input: LinkInput[]): Promise<AddLinkPayload[]>;
    protected addSteps(input: AddStepInput[]): Promise<StepPayload[]>;
    protected addTransitions(input: TransitionInput[]): Promise<AddTransitionPayload[]>;
    protected addFinalizer(cb: Finalizer): void;
}

declare type KV = {
    key: string;
    val: string;
};
interface ScopeSubscriptionInput {
    /** ids of the matching Scopes. */
    ids: string[];
    /** kinds of the matching Scopes. */
    kinds: string[];
    /** keys to Attributes in matching Scope. */
    keys: string[];
    /** kvs to Attributes in matching Scope. */
    kvs: KV[];
    /** names of the matching Scopes. */
    names: string[];
}
interface Subs {
    participants: boolean;
    scopes: {
        ids: string[];
        kinds: string[];
        names: string[];
        keys: string[];
        kvs: KV[];
    };
    transitions: string[];
}
declare class Subscriptions<Context, Kinds extends {
    [key: string]: ScopeConstructor<Context, Kinds>;
}> {
    private scopeKinds;
    private scopeIDs;
    private scopeNames;
    private scopeKeys;
    private scopeKVSet;
    private scopeKVs;
    private participantSub;
    private transitionsSubs;
    private dirty;
    last: Subs;
    get subs(): Subs;
    newSubs(): Subs | undefined;
    scopeSub(input: Partial<ScopeSubscriptionInput>): void;
    participantsSub(): void;
    transitionsSub(nodeID: string): void;
}

declare type Subscriber<Context, Kinds extends {
    [key: string]: ScopeConstructor<Context, Kinds>;
}> = (subs: ListenersCollector<Context, Kinds>) => void;
declare enum TajribaEvent {
    TransitionAdd = "TRANSITION_ADD",
    ParticipantConnect = "PARTICIPANT_CONNECT",
    ParticipantDisconnect = "PARTICIPANT_DISCONNECT"
}
declare enum ListernerPlacement {
    Before = 0,
    None = 1,
    After = 2
}
declare type EvtCtxCallback<Context, Kinds extends {
    [key: string]: ScopeConstructor<Context, Kinds>;
}> = (ctx: EventContext<Context, Kinds>, props: any) => void;
declare class ListenersCollector<Context, Kinds extends {
    [key: string]: ScopeConstructor<Context, Kinds>;
}> {
    get unique(): ListenersCollectorProxy<Context, Kinds>;
    on(kind: "start" | "ready", callback: (ctx: EventContext<Context, Kinds>) => void): void;
    on(event: TajribaEvent, callback: EvtCtxCallback<Context, Kinds>): void;
    on<Kind extends string>(kind: Kind, callback: EvtCtxCallback<Context, Kinds>): void;
    on<Kind extends keyof Kinds>(kind: Kind, key: string, callback: EvtCtxCallback<Context, Kinds>, uniqueCall?: boolean): void;
    before(kindOrEvent: string, keyOrNodeIDOrEventOrCallback?: string | TajribaEvent | EvtCtxCallback<Context, Kinds> | ((ctx: EventContext<Context, Kinds>) => void), callback?: EvtCtxCallback<Context, Kinds>, uniqueCall?: boolean): void;
    after(kindOrEvent: string, keyOrNodeIDOrEventOrCallback?: string | TajribaEvent | EvtCtxCallback<Context, Kinds> | ((ctx: EventContext<Context, Kinds>) => void), callback?: EvtCtxCallback<Context, Kinds>, uniqueCall?: boolean): void;
    protected registerListerner(placement: ListernerPlacement, kindOrEvent: string, keyOrNodeIDOrEventOrCallback?: string | TajribaEvent | EvtCtxCallback<Context, Kinds> | ((ctx: EventContext<Context, Kinds>) => void), callback?: EvtCtxCallback<Context, Kinds>, uniqueCall?: boolean): void;
}
declare class ListenersCollectorProxy<Context, Kinds extends {
    [key: string]: ScopeConstructor<Context, Kinds>;
}> extends ListenersCollector<Context, Kinds> {
    private coll;
    constructor(coll: ListenersCollector<Context, Kinds>);
    protected registerListerner(placement: ListernerPlacement, kindOrEvent: string, keyOrNodeIDOrEventOrCallback?: string | TajribaEvent | EvtCtxCallback<Context, Kinds> | ((ctx: EventContext<Context, Kinds>) => void), callback?: EvtCtxCallback<Context, Kinds>): void;
}
interface SubscriptionCollector {
    scopeSub: (...inputs: Partial<ScopeSubscriptionInput>[]) => void;
    participantsSub: () => void;
    transitionsSub: (stepID: string) => void;
}
declare class EventContext<Context, Kinds extends {
    [key: string]: ScopeConstructor<Context, Kinds>;
}> {
    constructor(
    /** @internal */
    subs: SubscriptionCollector, 
    /** @internal */
    taj: TajribaAdminAccess, 
    /** @internal */
    scopes: Scopes<Context, Kinds>);
    scopesByKind<T extends Scope<Context, Kinds>>(kind: keyof Kinds): Map<string, T>;
    scopesByKindID<T extends Scope<Context, Kinds>>(kind: keyof Kinds, id: string): T | undefined;
    scopesByKindMatching<T extends Scope<Context, Kinds>>(kind: keyof Kinds, key: string, val: string): T[];
    scopeSub(...inputs: Partial<ScopeSubscriptionInput>[]): void;
    participantsSub(): void;
    transitionsSub(stepID: string): void;
    addScopes(input: AddScopeInput[]): Promise<AddScopePayload[]>;
    addGroups(input: AddGroupInput[]): Promise<{
        id: string;
    }[]>;
    addLinks(input: LinkInput[]): Promise<AddLinkPayload[]>;
    addSteps(input: AddStepInput[]): Promise<StepPayload[]>;
    addTransitions(input: TransitionInput[]): Promise<AddTransitionPayload[]>;
    protected addFinalizer(cb: Finalizer): void;
    get globals(): Globals;
}

declare class AdminContext<Context, Kinds extends {
    [key: string]: ScopeConstructor<Context, Kinds>;
}> {
    private ctx;
    private kinds;
    readonly tajriba: TajribaConnection;
    adminConn: AdminConnection | undefined;
    private sub?;
    private runloop;
    private adminSubs;
    private adminStop;
    private subs;
    private constructor();
    static init<Context, Kinds extends {
        [key: string]: ScopeConstructor<Context, Kinds>;
    }>(url: string, tokenFile: string, serviceName: string, serviceRegistrationToken: string, ctx: Context, kinds: Kinds): Promise<AdminContext<Context, Kinds>>;
    stop(): Promise<void>;
    register(subscriber: Subscriber<Context, Kinds> | ListenersCollector<Context, Kinds>): void;
    private initOrStop;
    private initSubs;
    private stopSubs;
}
interface StepPayload {
    id: string;
    duration: number;
}
interface AddLinkPayload {
    nodes: {
        id: string;
    }[];
    participants: {
        id: string;
    }[];
}
interface AddTransitionPayload {
    id: string;
    from: State;
    to: State;
}
interface AddScopePayload {
    id: string;
    name?: string | null | undefined;
    kind?: string | null | undefined;
    attributes: {
        edges: {
            node: {
                id: string;
                private: boolean;
                protected: boolean;
                immutable: boolean;
                key: string;
                val?: string | null | undefined;
                index?: number | null | undefined;
            };
        }[];
    };
}
declare type Finalizer = () => Promise<void>;
declare class TajribaAdminAccess {
    readonly addFinalizer: (cb: Finalizer) => void;
    readonly addScopes: (input: AddScopeInput[]) => Promise<AddScopePayload[]>;
    readonly addGroups: (input: AddGroupInput[]) => Promise<{
        id: string;
    }[]>;
    readonly addLinks: (input: LinkInput[]) => Promise<AddLinkPayload[]>;
    readonly addSteps: (input: AddStepInput[]) => Promise<StepPayload[]>;
    readonly addTransitions: (input: TransitionInput[]) => Promise<AddTransitionPayload[]>;
    readonly globals: Globals;
    constructor(addFinalizer: (cb: Finalizer) => void, addScopes: (input: AddScopeInput[]) => Promise<AddScopePayload[]>, addGroups: (input: AddGroupInput[]) => Promise<{
        id: string;
    }[]>, addLinks: (input: LinkInput[]) => Promise<AddLinkPayload[]>, addSteps: (input: AddStepInput[]) => Promise<StepPayload[]>, addTransitions: (input: TransitionInput[]) => Promise<AddTransitionPayload[]>, globals: Globals);
}

export { Attributes as A, EventContext as E, Finalizer as F, Globals as G, KV as K, ListenersCollector as L, Subscriber as S, TajribaEvent as T, AdminConnection as a, Scope as b, Scopes as c, Subscriptions as d, ScopeSubscriptionInput as e, Subs as f, AttributeMsg as g, AdminContext as h, TajribaAdminAccess as i, AddLinkPayload as j, AddScopePayload as k, AddTransitionPayload as l, StepPayload as m, EvtCtxCallback as n, ListenersCollectorProxy as o };
